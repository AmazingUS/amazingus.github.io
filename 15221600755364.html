<!doctype html>
<html class="no-js" lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>
     Android编程权威指南 笔记(01~06) - TIME TO GO 
  </title>
   
  <link href="atom.xml" rel="alternate" title="TIME TO GO" type="application/atom+xml">
  <link rel="stylesheet" href="asset/css/foundation.min.css" />
  <link rel="stylesheet" href="asset/css/docs.css" />
  <script src="asset/js/vendor/modernizr.js"></script>
  <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
  <script type="text/javascript">
    function before_search() {
      var searchVal = 'site: ' + document.getElementById('search_input').value;
      document.getElementById('search_q').value = searchVal;
      return true;
    }
  </script>
</head>

<body class="antialiased hide-extras">
  <div class="marketing off-canvas-wrap" data-offcanvas>
    <div class="inner-wrap">


      <nav class="top-bar docs-bar hide-for-small" data-topbar>
        <section class="top-bar-section">
          <div class="row">
            <div style="position: relative;width:100%;">
              <div style="position: absolute; width:100%;">
                <ul id="main-menu" class="left">
                  
                  <li id="">
                    <a target="self" href="index.html">Home</a>
                  </li>
                  
                  <li id="">
                    <a target="_self" href="archives.html">Archives</a>
                  </li>
                  
                </ul>
                <ul class="right" id="search-wrap">
                  <li>
                    <form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
                      <input type="hidden" id="search_q" name="q" value="" />
                      <input tabindex="1" type="search" id="search_input" placeholder="Search" />
                    </form>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </section>
      </nav>

      <nav class="tab-bar show-for-small">
        <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
          <span> &nbsp; TIME TO GO</span>
        </a>
      </nav>

      <aside class="left-off-canvas-menu">
        <ul class="off-canvas-list">
          <li>
            <a href="index.html">HOME</a>
          </li>
          <li>
            <a href="archives.html">Archives</a>
          </li>
          <li>
            <a href="about.html">ABOUT</a>
          </li>
          <li>
            <label>Categories</label>
          </li>
          
        </ul>
      </aside>
      <a class="exit-off-canvas" href="#"></a>
      <section id="main-content" role="main" class="scroll-container"> <script type="text/javascript">
  $(function () {
    $('#menu_item_index').addClass('is_active');
    $('#sidebar').parent().parent().hide();
  });
</script>

<div class="row">
  <div class="large-12 medium-12 columns">
    <div class="markdown-body article-wrap">

      <div class="article">
        
        <h1>Android编程权威指南 笔记(01~06)</h1>
        <div class="read-more clearfix">
          <span class="date">2018/3/27</span>
           
          <span class="comments">
             
          </span>
        </div>
      </div>

      <div class="article-content">
        <ul>
<li>
<a href="#toc_0">第1章 Android开发初体验</a>
<ul>
<li>
<a href="#toc_1">1.4 用户界面设计</a>
</li>
<li>
<a href="#toc_2">1.5 从布局XML到视图对象</a>
</li>
<li>
<a href="#toc_3">1.6 组件的实际应用</a>
</li>
<li>
<a href="#toc_4">1.7 创建提示消息</a>
</li>
<li>
<a href="#toc_5">1.9 深入学习：Android编译过程</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">第2章 Android与MVC设计模式</a>
<ul>
<li>
<a href="#toc_7">2.1 创建新类</a>
</li>
<li>
<a href="#toc_8">2.2 Android与MVC设计模式</a>
</li>
<li>
<a href="#toc_9">2.6 添加图标资源</a>
</li>
<li>
<a href="#toc_10">2.9 挑战练习：从按钮到图标按钮</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">第3章 activity的生命周期</a>
<ul>
<li>
<a href="#toc_12">3.0. 概述</a>
</li>
<li>
<a href="#toc_13">3.1 日志跟踪理解activity生命周期</a>
</li>
<li>
<a href="#toc_14">3.2 设备旋转与activity生命周期</a>
</li>
<li>
<a href="#toc_15">3.3 保存数据以应对设备旋转</a>
</li>
<li>
<a href="#toc_16">3.4 再探activity生命周期</a>
</li>
<li>
<a href="#toc_17">3.5 深入学习：activity内存清理现状</a>
</li>
</ul>
</li>
<li>
<a href="#toc_18">第4章 Android应用的调试</a>
<ul>
<li>
<a href="#toc_19">4.1 异常与栈跟踪</a>
</li>
<li>
<a href="#toc_20">4.2 Android特有的调试工具</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">第5章 第二个activity</a>
<ul>
<li>
<a href="#toc_22">5.1 创建第二个activity</a>
</li>
<li>
<a href="#toc_23">5.2 启动activity</a>
</li>
<li>
<a href="#toc_24">5.3 activity间传递数据</a>
</li>
<li>
<a href="#toc_25">5.4 activity的使用与管理</a>
</li>
</ul>
</li>
<li>
<a href="#toc_26">第6章 第Android SDK版本与兼容</a>
<ul>
<li>
<a href="#toc_27">6.1 Android SDK版本</a>
</li>
<li>
<a href="#toc_28">6.2 Android编程与兼容性问题</a>
</li>
<li>
<a href="#toc_29">6.3 使用Android开发者文档</a>
</li>
</ul>
</li>
</ul>


<span id="more"></span><!-- more -->   

<h3 id="toc_0">第1章 Android开发初体验</h3>

<h4 id="toc_1">1.4 用户界面设计</h4>

<ul>
<li><p>布局XML文件的根元素组件必须指定Android XML资源文件的命名空间属性xmlns:android（此处属性值为<code>http://schemas.android.com/apk/res/android</code>）；</p></li>
<li><p>android:layout_width、layout_height属性：</p>

<ul>
<li>match_parent：视图与其父视图大小相同，(之前已废弃的fill_parent等价于此）；</li>
<li>wrap_content：视图根据其显示内容自动调整大小；</li>
</ul></li>
<li><p>字符串资源</p>

<ul>
<li><p>一个默认名称为string.xml（可取其他名称）的XML文件，存放在app/res/valus/目录下；</p>

<pre><code>&lt;/resources&gt;&lt;string name=&quot;true_button&quot;&gt;True&lt;/string&gt;&lt;/resources&gt;
</code></pre></li>
<li><p>一个项目也可以有多个字符串文件，只需将这些文件放app/res/valus/目录下，含有一个resources根元素及多个string子元素即可，应用就能找到并正确使用它们；</p></li>
<li><p>定义好后，引用时使用@string/NAME；</p></li>
</ul></li>
</ul>

<h4 id="toc_2">1.5 从布局XML到视图对象</h4>

<ul>
<li><p>AppCompatActivity是Activity的一个子类，为了Android旧系统提供兼容性支持；</p></li>
<li><p>Activity的<code>public void setContentView(int layoutResID)</code>方法：根据传入的布局资源ID，生成该布局的视图，其包含的组件也随之实例化，并放置在屏幕上；</p></li>
<li><p>资源是应用非代码形式的内容（如图片、音频、XML文件），都放置app/res的子目录下，布局资源文件在app/res/layout下，字符串资源文件在res/values下；</p></li>
<li><p><strong>可以使用资源ID在代码中获取相应的资源，如R.layout.activity_quiz（activity_quiz.xml的资源ID）、R.string.app_name</strong>；</p></li>
<li><p>R.java文件是项目中自动生成的包含所有资源ID；修改相关资源后，R.java会自动更新（有时失效）；</p></li>
<li><p><strong>Android自动为布局文件、各个字符串生成资源ID，但是布局文件中的组件需要手动设置<code>android:id</code>属性后才生成相应的资源ID；</strong></p>

<ul>
<li><strong>在设置该属性值时，需要添加+标示，如android:id=&quot;@+id/true_button&quot;；</strong></li>
<li><strong>布局文件中引用时则不需要添加+，如@id/true_button；</strong></li>
<li><strong>代码中引用时使用<code>R.id.xxx</code>，如R.id.true_button；</strong></li>
</ul></li>
</ul>

<h4 id="toc_3">1.6 组件的实际应用</h4>

<ul>
<li><p>Activity的<code>public View findViewById(int id)</code>：根据资源ID返回已生成的组件视图对象（注意要类型转换）；</p></li>
<li><p>Android应用属于典型的事件驱动类型，应用启动后即开始等待行为事件的发生；为响应某个事件而创建的对象叫作监听器，监听器就是实现特定监听接口的对象，比如监听点击事件，需要实现View.OnClickListenter接口；</p></li>
<li><p><code>btn.setOnClickListener(OnClickListener)</code>就是给btn设置监听对象，建议使用<code>匿名内部类</code>来实现监听对象；</p></li>
</ul>

<h4 id="toc_4">1.7 创建提示消息</h4>

<ul>
<li><p>Toast类的<code>public static Toast makeText(Context context, int resId, int duration)</code>：</p>

<ul>
<li>context参数通常是Activity的一个实例（Activity本身就是Context的子类）；</li>
<li>resId参数是toast要显示字符串消息的资源ID（Toast必须借助context才能找到并使用字符串的资源ID）；</li>
<li>duration参数同时是两个Toast常量的一个，用来指定停留时间；</li>
<li>创建一个toast；之后再调用show()方法在屏幕上显示Toast消息；</li>
</ul></li>
<li><p><strong>在匿名内部类中调用Toast的makeText()方法时，注意传入的context参数不能是this（此时的this是匿名类监听器），应该是XXActivity.this；</strong></p></li>
</ul>

<h4 id="toc_5">1.9 深入学习：Android编译过程</h4>

<ul>
<li><p>在XXActivity类的onCreate()方法中调用setContentView()方法时：XXActivity会使用LayoutInflater类实例化布局文件中定义的每一个View对象（基于反射机制）；</p></li>
<li><p>处理在XML文件中定义视图外，也可以在Activity中使用代码创建视图类（但是建议展现层与逻辑层分离）；</p></li>
</ul>

<h3 id="toc_6">第2章 Android与MVC设计模式</h3>

<h4 id="toc_7">2.1 创建新类</h4>

<ul>
<li>生成getter、setter方法注意事项：

<ul>
<li>Android的命名规范是变量以m前缀、静态量以s前缀；若直接Generate Getter and Setter则生成getter、setter方法时会带相关前缀，如getMText()、setMText()；</li>
<li>Setting-&gt;Editor-&gt;Code Style-&gt;Java-&gt;Code Generation勾选“Prefer longer names”并在相应项输入m、s，取消生成代码时带相关m、s前缀；</li>
</ul></li>
</ul>

<h4 id="toc_8">2.2 Android与MVC设计模式</h4>

<ul>
<li>Android中的MVC

<ul>
<li>M通常是我们创建的定制类，V是Android自带的视图类和我们定制开发的视图类，C是Activity、Fragment、Service子类；</li>
<li>M对象与V对象是不能直接交互的；</li>
</ul></li>
</ul>

<h4 id="toc_9">2.6 添加图标资源</h4>

<ul>
<li><p>图标资源主要分为以下像素密度屏幕：mdpi（约160dpi）、hdpi（约240dpi）、xhdpi（约320dpi）、xxhdpi（约480dpi）；</p></li>
<li><p>所有大小的图片资源都会被安装在设备中，Android系统知道如何为不同设备提供最佳匹配；若应用不包含设备对应的像素密度的图片，Android系统在运行时会自动找可到可用的图片资源，并针对该设备进行适配；</p></li>
<li><p>将不同像素密度的图片资源（文件名必须是小写且无空格，后缀名为png、jpg、gif）放到对应的res/drawable-mdpi、drawable-hdpi、drawable-xhdpi、drawable-xxhdpi目录中，Android会自动为其分配资源ID；图片资源ID不需要按照屏幕密度匹配引用，系统知道如何显示，直接引用即可；</p></li>
<li><p><strong>在XML资源文件中，通过资源类型和资源名称，可引用其他资源；比如，以@string/开头的定义是引用字符串资源，以@drawable/开头的定义是引用drawable资源；</strong></p></li>
</ul>

<h4 id="toc_10">2.9 挑战练习：从按钮到图标按钮</h4>

<ul>
<li>ImageButton继承于ImageView，Button继承于TextView；</li>
</ul>

<h3 id="toc_11">第3章 activity的生命周期</h3>

<h4 id="toc_12">3.0. 概述</h4>

<ul>
<li><p>每个Activity实例都有其生命周期，其在运行（前台可见）、暂停（可见）、停止（不可见）状态间进行转换；</p></li>
<li><p>每次状态转换都会有对应的Activity方法将状态改变的消息通知给activity（onCreate、onStart、onResume、onPause、onStop、onDestroy这些方法由系统调用，不可自己手动调用；覆盖这些方法时需先调用super方法）；</p></li>
<li><p>通常重写onCreate(Bundle)方法，进行实例化组件并将它们放置在屏幕上（调用setContentView(int)方法）、引用已实例化的组件、为组件设置监听器以处理用户交互、访问外部模型数据；</p>

<p><img src="media/15221600755364/activity_life.png" alt="activity_life" style="width:423px;"/></p></li>
</ul>

<h4 id="toc_13">3.1 日志跟踪理解activity生命周期</h4>

<ul>
<li><p>Android的android.util.Log类能够发送日志信息到系统级别的共享日志中心，其有几个日志记录方法，比如<code>public static int d(String tag, String msg)</code></p></li>
<li><p>实例解析</p>

<ul>
<li>a. Activity启动时，依次调用<code>onCreate、onStart、onResume方法</code>；</li>
<li>b. 按Home键后，依次调用<code>onPause、onStop方法</code>；（Activity不销毁，能存活多久无法保证，系统回收内存时会先销毁那些停止的Activity；系统Settings中启用Don’t keep activities选项，此时也会调用onDestroy方法）</li>
<li>c. 从最近应用列表中启动，依次调用<code>onStart、onResume方法</code>；</li>
<li>d. 按退出键，依次调用<code>onPause、onStop、onDestroy方法</code>，Activity被销毁；</li>
<li>e. 关闭屏幕，处理方式和按Home键一样；</li>
</ul></li>
<li><p><strong>若当前Activity界面被完全或部分遮挡（如弹出窗口），那么其会被系统暂停，用户无法同其交互，弹出窗口关闭后会继续运行；</strong></p></li>
</ul>

<h4 id="toc_14">3.2 设备旋转与activity生命周期</h4>

<ul>
<li><p>旋转设备会改变<code>设备配置（Device Configuration）</code>；设备配置是用来描述设备当前状态的一系列特征（屏幕方向、密度、尺寸、键盘类型、底座模式、语言等）；</p></li>
<li><p>为匹配不同的设备配置，应用会提供不同的备选资源，如适配屏幕分辨率添加多套图片资源；</p></li>
<li><p>在运行过程中，设备配置发生改变会触发使用<strong>可能存在的更合适的资源</strong>来匹配新的设备配置，如旋转屏幕会加载新的布局文件，即当前的Activity被销毁并重新创建；注意有些设备配置是固定的，比如屏幕密度；</p></li>
<li><p>创建水平模式布局：</p>

<ul>
<li><strong>a. 右键点击res目录后，选择新建<code>Android resource directory</code>，<code>Resource type</code>选择<code>layout</code>，<code>Source Set</code>保持<code>main</code>不变；</strong></li>
<li><strong>b. 将<code>Available qulifiers</code>中的<code>Orientation</code>移到选择区中，之后<code>Screen Orientation</code>选择<code>Landscape</code>，并确保目录名显示为<code>layout-land</code>；</strong></li>
<li><strong>c. 点击OK即创建了res/layout-land，land后缀名是配置修饰符的一个例子；</strong></li>
<li><strong>d. 之后就可以在res/layout-land创建水平模式的布局文件了（或者从res/layout中复制布局文件再修改）；</strong></li>
</ul></li>
<li><p>当设备处于水平方向时，系统会在res/layout-land目录中寻找布局资源，若没有则使用res/layout目录下的；其他情况在res/layout目录下寻找；</p></li>
<li><p><strong>不同屏幕方向的布局资源文件必须是相同的文件名，这样才能以同一资源ID被引用；</strong></p></li>
<li><p>FrameLayout子视图的位置排列取决于它们各自的android:layout_gravity属性；</p></li>
</ul>

<h4 id="toc_15">3.3 保存数据以应对设备旋转</h4>

<ul>
<li><p>在应用运行中，只要设备配置发生变化，Android就销毁当前activity并再创建新的activity；</p></li>
<li><p><strong>activity的<code>protected void onSaveInstanceState(Bundle outState)</code>方法（注意别重写错了）：</strong></p>

<ul>
<li><strong>在按Home键、设置配置发生变化后两种情况下，activity在调用onStop()方法之前系统都会调用此方法；</strong></li>
<li><strong>按后退键不会，按后退键表示告诉Android该activity完了要将其从内存中抹掉，自然也就没有必要重建保存数据了；</strong></li>
<li><strong>该方法的默认实现就是将所有activity视图的状态数据保存在Bundle对象中；</strong></li>
</ul></li>
<li><p>Bunle是存储字符串键与限定类型（基本数据类型、实现Serializable/Parcelable接口的对象）值之间映射关系（键值对）的一种结构，相关方法如putInt、getInt；</p></li>
<li><p><strong>不建议在Bundle中保存定制类对象，因为取回的对象可能已经过时了</strong>；</p></li>
<li><p><strong>可通过覆盖onSaveInstanceState()方法，将一些数据保存在bundle中，然后在onCreate()方法中取回这些数据；比如处理屏幕旋转的数据保存；</strong></p></li>
</ul>

<h4 id="toc_16">3.4 再探activity生命周期</h4>

<ul>
<li><p><strong>重写onSaveInstanceState()方法不仅仅用于处理与设备旋转相关的问题</strong>，也可以处理以下场景：</p>

<ul>
<li>当用户离开当前activity用户界面，或Android需要回收内存时activity被销毁（如用户按了HOME后播放视频或玩游戏）；</li>
<li>Android从不会为了回收内存去销毁正在运行的activity（处于运行或暂停状态），而是会销毁处于停止状态的activity；</li>
<li><strong>此时不用担心数据丢失，系统会调用onSaveInstanceState()方法将用户数据保存到Bundle对象中，之后系统会将该Bundle对象放入<code>activity记录</code>中；</strong></li>
<li><strong>在需要恢复activity时，操作系统可以使用暂存的<code>activity记录</code>重新激活activity；</strong></li>
</ul></li>
<li><p><strong>注意，activity进入<code>暂存状态</code>并不一定需要调用onDestroy()方法；因此常见的做法是：</strong></p>

<ul>
<li><strong>重写onSaveInstanceState()方法，在Bundle对象中保存当前activity的小的或暂存状态的数据；</strong></li>
<li><strong>重写onStop()方法，保存永久性数据，如用户编辑的文字等；onStop()方法被调用后，activity随时可能会被系统销毁，所以用它保存永久性数据；</strong></li>
</ul></li>
<li><p><strong>当用户按了后退键后，系统会彻底销毁当前的activity，此时暂存的activity记录也被清除；此外系统重启，暂存的activity记录也会被清除；</strong></p></li>
</ul>

<h4 id="toc_17">3.5 深入学习：activity内存清理现状</h4>

<ul>
<li><strong>低内存状态下，Android直接从内存清除整个应用进程（包含所有的activity），目前还做不到只销毁单个activity；</strong></li>
</ul>

<h3 id="toc_18">第4章 Android应用的调试</h3>

<h4 id="toc_19">4.1 异常与栈跟踪</h4>

<ul>
<li>调试方法

<ul>
<li>a. 查看异常调用栈；</li>
<li>b. 使用Log；</li>
<li>c. 使用断点（Run-&gt;View Breakpoints管理断点，
也可以设置异常断点捕获特定类型的异常）;</li>
</ul></li>
</ul>

<h4 id="toc_20">4.2 Android特有的调试工具</h4>

<ul>
<li><p>Android Lint：</p>

<ul>
<li>静态分析器，检查所有潜在的问题，比如使用错误的资源ID导致错误的类型转换， <code>mButton= (Button)findViewById(R.id.a_text_view);</code>；</li>
<li>Anylyze-&gt;Inspect Code手动运行Android Lint；</li>
</ul></li>
<li><p>R文件错误处理方式：</p>

<ul>
<li>a. 检查资源文件XML的有效性；</li>
<li>b. 清理工程；</li>
<li>c. 使用Gradle同步项目；</li>
<li>d. 运行Android Lint检查；</li>
</ul></li>
</ul>

<h3 id="toc_21">第5章 第二个activity</h3>

<h4 id="toc_22">5.1 创建第二个activity</h4>

<ul>
<li><p>创建新的activity至少涉及三个文件：Java类、XML布局和应用的manifest文件；</p></li>
<li><p><code>tools:text属性</code>用于在Android Studio中预览TextView的显示，运行时显示还是使用<code>android:text属性</code>；</p></li>
<li><p>项目的app/manifest目录中的AndroidManifest.xml是用来向Android操作系统描述应用信息，比如声明activity：<code>&lt;activity android:name=&quot;.XXActivity&quot;&gt;&lt;/activity&gt;</code>，name可取完整包路径，也可取.类名；</p></li>
</ul>

<h4 id="toc_23">5.2 启动activity</h4>

<ul>
<li><p>activity的<code>public void startActivity(Intent intent)</code></p>

<ul>
<li>一个activity启动另外一个activity的最简单的方式；</li>
<li>调用请求会发给了操作系统的ActivityManager，ActivityManager负责创建Activity实例并调用其onCreate()方法；</li>
<li>参数intent标示启动哪个Activity；</li>
</ul></li>
<li><p><strong>Intent对象是Component用于与操作系统通信的一种媒介工具；Component有activity、service、broadcast receiver、content provider；</strong></p></li>
<li><p>构造函数<code>public Intent(Context packageContext, Class&lt;?&gt; cls)</code>：</p>

<ul>
<li>Class参数告诉ActivityManager启动哪个activity（其会先检查指定的Class是否在manifest配置文件中声明过，若没有则抛出ActivityNotFoundException异常）；</li>
<li>Context参数告诉ActivityManager在哪里可以找到它；</li>
</ul></li>
<li><p><strong>显式与隐式Intent</strong></p>

<ul>
<li><strong>通过指定Context与Class对象，然后调用intent的构造方法来创建Intent，则创建的是显式Intent；同一应用中使用显式Intent来启动activity；</strong></li>
<li><strong>一个应用的activity若需要启动另一个应用的activity，可以通过创建隐式Intent来处理；</strong></li>
</ul></li>
</ul>

<h4 id="toc_24">5.3 activity间传递数据</h4>

<ul>
<li><p><strong>intent extra（传递数据的媒介）：</strong></p>

<ul>
<li>extra可以是任意数据，其为包含在Intent中的键值结构数据；</li>
<li>可以添加多个extra到同一个intent上；</li>
<li><strong>调用intent的<code>public Intent putExtra(String name, boolean value)</code>给intent添加数据，一个参数是固定的String类型的键，另一个参数值可以是多种数据类型，该方法返回intent自身（可以进行链式编程）；</strong></li>
<li><strong>调用intent的<code>public boolean getBooleanExtra(String name, boolean defaultValue)</code>获取extra中的数据；</strong></li>
</ul></li>
<li><p><strong>子activity从父activity获取信息：</strong></p>

<ul>
<li><strong>调用子activity的<code>getIntent()</code>方法获取由startActivity(Intent)、startActivityForResult(Intent intent, int requestCode)方法转发的Intent对象；之后从中获取信息；</strong></li>
<li><strong>常用场景技巧：在子activity中创建一个生成intent的静态方法，来提供给父activity调用，这样就不用关心父activity的来源及extra中键的定义，也提高了封装性；</strong></li>
</ul></li>
<li><p><strong>父activity从子activity获取返回信息：</strong></p>

<ul>
<li><p><strong>第一步、调用父activity的<code>public void startActivityForResult(Intent intent, int requestCode)</code>方法启动子activity；</strong></p>

<ul>
<li><strong>第一参数Inttent同上述；</strong></li>
<li><strong>第二个参数为<code>请求代码</code>；请求代码是先发送给子 activity，然后再返回给父activity的整数值，由用户定义；在一个activity启动多个不同类型的子activity，且需要判断消息回馈方时就会用请求代码requestCode；</strong></li>
</ul></li>
<li><p><strong>第二步、实现子activity发送返回信息给父activity，有以下两种方法可用：</strong></p>

<ul>
<li><strong>a. 子activity调用<code>public final void setResult(int resultCode)</code>方法；</strong></li>
<li><strong>b. 子activity调用<code>public final void setResult(int resultCode, Intent data)</code>方法；</strong></li>
</ul></li>
<li><p><strong>resultCode</strong></p>

<ul>
<li><strong>用于父activity区分子activity的不同操作（如取消、确定等）；</strong></li>
<li>可以是预定义的常量<code>Activity.RESULT_OK</code>（-1，默认值）、<code>Activity.RESULT_CANCELED</code>（0），也可以是自定义的resultCode（写<code>Activity.RESULT_FIRST_USER</code>（1））；</li>
<li>子activity可以不调用setResult()方法；

<ul>
<li>若没有调用，则操作系统发送默认的resultCode（Activity.RESULT_OK）；</li>
<li>若没有调用且按了后退按钮，则操作系统发送Activity.RESULT_CANCELED；</li>
</ul></li>
</ul></li>
<li><p><strong>第三步、重写onActivityResult()方法来处理返回结果；点击返回键返回时，ActivityManager会调用父activity的<code>protected void onActivityResult(int requestCode, int resultCode, Intent data)</code>方法，参数来自于之前启动子activity设置的requestCode和子activity设置的resultCode、intent；</strong></p></li>
</ul></li>
<li><p><strong>startActivity与startActivityForResult的区别：</strong></p>

<ul>
<li><strong>startActivity：仅仅是启动另一个Activity，不会回退到原来的Activity；若想跳回则必须再次调用startActivity来启动原来的Activity；</strong></li>
<li><strong>startActivityForResult：按返回键可直接回退到原来的Activity，当子Activity执行完finish()方法后，会自动回调<code>父Activity的onActivityResult()</code>方法；</strong></li>
</ul></li>
<li><p>除了点击返回键退出外，还可以调用activity的finish()方法也能将子activity回退（回退栈弹出）；</p></li>
</ul>

<h4 id="toc_25">5.4 activity的使用与管理</h4>

<ul>
<li><p>manifest中，XXActivity声明intent-filter子元素被设置为<code>launcher activity</code>；</p>

<pre><code>&lt;intent-filter&gt; 
    &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; 
    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
&lt;/intent-filter&gt;
</code></pre></li>
<li><p>ActivityManager维护则一个非特定应用独享的<code>回退栈</code>，所有应用的activity都共享该回退栈；这也是ActivityManager被设计成操作系统级的activity管理器来负责启动应用activity的原因之一；</p></li>
<li><p>不局限于单个应用，回退栈作为一个整体共享给操作系统及设备使用；</p></li>
</ul>

<h3 id="toc_26">第6章 第Android SDK版本与兼容</h3>

<h4 id="toc_27">6.1 Android SDK版本</h4>

<ul>
<li>API版本与设备固件版本：

<ul>
<li>API 19：KitKat，Android 4.4；</li>
<li>API 21：Lollipop，Android 5.0；</li>
<li>API 22：Lollipop，Android 5.1；</li>
</ul></li>
</ul>

<h4 id="toc_28">6.2 Android编程与兼容性问题</h4>

<ul>
<li><p>应用模块的build.gradle文件有三个属性值：compileSdkVersion、minSdkVersion、targetSdkVersion；</p>

<ul>
<li>compileSdkVersion：独占该文件；</li>
<li>minSdkVersion、targetSdkVersion虽然也设置在该文件中，但它们的作用是覆盖和设置配置文件AndroidManifest.xml；</li>
</ul></li>
<li><p><strong>SDK最低版本（minSdkVersion）：</strong></p>

<ul>
<li>若设备上的系统版本低于该值，系统将拒绝该应用的安装；</li>
</ul></li>
<li><p><strong>SDK目标版本（targetSdkVersion）：</strong></p>

<ul>
<li>应用是为哪个API级别设计的，多数情况下目标版本就是最新发布的Android版本；</li>
<li>新发布的SDK版本可能会改变应用在设备上的显示方式，甚至连操作系统后台运行行为都会受到影响；</li>
<li><strong>降低SDK目标版本可以保证，即便运行在高于目标版本的设备上，应用的运行行为仍然和SDK目标版本保持一致，新版本的变化会被忽略；</strong></li>
</ul></li>
<li><p><strong>SDK编译版本（compileSdkVersion）：</strong></p>

<ul>
<li>该设置不会出现在AndroidManifest中；</li>
<li>minSdkVersion、targetSdkVersion会通知给操作系统，而compileSdkVersion只是开发者与编译器之间的私有信息，用于使用时、编译时查找SDK中的类和方法；</li>
<li><strong>当Android新版本发布时，更新SDK编译版本，就可以使用新版本引入的方法和类了；</strong></li>
</ul></li>
<li><p>修改build.gradle文件后，需要同步一下Gradle才能生效（Tools -&gt; Android -&gt; Sync Project with Gradle Files），之后项目重新编译；</p></li>
<li><p><strong>若minSdkVersion和compileSdkVersion的差异较大，由此带来兼容问题需要处理；比如，调用了KitKat（API 19）以后的SDK代码的应用，运行在KitKat设备上会崩溃；</strong></p></li>
<li><p>受益用于<code>Android Lint</code>，在低版本系统上调用高版本的API，Android Lint会提示编译错误；Analyze -&gt; Inspect Code手动触发Lint；解决办法：</p>

<ul>
<li>提高minSdkVersion；</li>
<li><p>将高版本API置于检查Android设备版本的条件语句中（运行时检查）；</p>

<pre><code class="language-java">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {
    // TODO
} else {
    // TODO
}
</code></pre></li>
</ul></li>
<li><p><strong>Build.VERSION.SDK_INT为当前运行的设备的版本， Build.VERSION_CODES.LOLLIPOP等常量表示常见的Android版本号；</strong> 版本号清单参看网页<code>http://developer.android.com/reference/android/os/Build. VERSION_CODES.html</code>；</p></li>
</ul>

<h4 id="toc_29">6.3 使用Android开发者文档</h4>

<ul>
<li><p>Android开发文档：分为设计（UI设计规范）、开发（SDK文档）、发布（应用市场发布），<code>http://developer.android.com/</code>；</p></li>
<li><p>开发参考文档左侧，可以选择<code>API level</code>进行高版本API的过滤；</p></li>
</ul>

      </div>

      <div class="row">
        <div class="large-6 columns">
          <p class="text-left" style="padding:15px 0px;">
            
            <a href="15225894269717.html" title="Previous Post: Android编程权威指南 笔记(07~12)">&laquo; Android编程权威指南 笔记(07~12)</a>
            
          </p>
        </div>
        <div class="large-6 columns">
          <p class="text-right" style="padding:15px 0px;">
            
            <a href="15230908846113.html" title="Next Post: Android Studio配置使用">Android Studio配置使用 &raquo;</a>
            
          </p>
        </div>
      </div>

      <div class="comments-wrap">
        <div class="share-comments">
            
        </div>
      </div>

    </div>
  </div> <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">

      <div id="site-info" class="site-info">
        
        <h1>TIME TO GO</h1>
        <div class="site-des">It is just a matter of time.</div>
        <div class="social">
                    
          <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
        </div>
      </div>

      

      <div id="site-categories" class="side-item ">
        <div class="side-header">
          <h2>Categories</h2>
        </div>
        <div class="side-content">
          <p class="cat-list">
            
          </p>
        </div>
      </div>

      <div id="site-categories" class="side-item">
        <div class="side-header">
          <h2>Recent Posts</h2>
        </div>
        <div class="side-content">
          <ul class="posts-list">
              <li class="post">
              <a href="15626010144789.html">iOS状态栏</a>
              </li>
                 <li class="post">
              <a href="15622540495294.html">iOS屏幕方向</a>
              </li>
                 <li class="post">
              <a href="15590636648081.html">OpenCV配置使用</a>
              </li>
                 <li class="post">
              <a href="15590617242967.html">Sublime配置使用教程</a>
              </li>
                 <li class="post">
              <a href="15580276420967.html">iOS照片框架</a>
              </li>
                                             
          </ul>
        </div>
      </div>

    </div>
  </div>
</div>

</div> <div class="page-bottom clearfix">
  <div class="row">
    <p class="copyright">Copyright &copy; 2015 Powered by
      <a target="_blank" href="">ME</a>
    </p>
  </div>
</div>
</section>

</div>
</div>

 
<script src="asset/js/foundation.min.js"></script>
<script>
  $(document).foundation();
  function fixSidebarHeight() {
    var w1 = $('.markdown-body').height();
    var w2 = $('#sidebar').height();
    if (w1 > w2) { $('#sidebar').height(w1); };
  }
  $(function () {
    fixSidebarHeight();
  })
  $(window).load(function () {
    fixSidebarHeight();
  });
</script>   
</body>

</html>