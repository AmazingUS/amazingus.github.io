<!doctype html>
<html class="no-js" lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>
     Swift版本间差异 - TIME TO GO 
  </title>
   
  <link href="atom.xml" rel="alternate" title="TIME TO GO" type="application/atom+xml">
  <link rel="stylesheet" href="asset/css/foundation.min.css" />
  <link rel="stylesheet" href="asset/css/docs.css" />
  <script src="asset/js/vendor/modernizr.js"></script>
  <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
  <script type="text/javascript">
    function before_search() {
      var searchVal = 'site: ' + document.getElementById('search_input').value;
      document.getElementById('search_q').value = searchVal;
      return true;
    }
  </script>
</head>

<body class="antialiased hide-extras">
  <div class="marketing off-canvas-wrap" data-offcanvas>
    <div class="inner-wrap">


      <nav class="top-bar docs-bar hide-for-small" data-topbar>
        <section class="top-bar-section">
          <div class="row">
            <div style="position: relative;width:100%;">
              <div style="position: absolute; width:100%;">
                <ul id="main-menu" class="left">
                  
                  <li id="">
                    <a target="self" href="index.html">Home</a>
                  </li>
                  
                  <li id="">
                    <a target="_self" href="archives.html">Archives</a>
                  </li>
                  
                </ul>
                <ul class="right" id="search-wrap">
                  <li>
                    <form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
                      <input type="hidden" id="search_q" name="q" value="" />
                      <input tabindex="1" type="search" id="search_input" placeholder="Search" />
                    </form>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </section>
      </nav>

      <nav class="tab-bar show-for-small">
        <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
          <span> &nbsp; TIME TO GO</span>
        </a>
      </nav>

      <aside class="left-off-canvas-menu">
        <ul class="off-canvas-list">
          <li>
            <a href="index.html">HOME</a>
          </li>
          <li>
            <a href="archives.html">Archives</a>
          </li>
          <li>
            <a href="about.html">ABOUT</a>
          </li>
          <li>
            <label>Categories</label>
          </li>
          
        </ul>
      </aside>
      <a class="exit-off-canvas" href="#"></a>
      <section id="main-content" role="main" class="scroll-container"> <script type="text/javascript">
  $(function () {
    $('#menu_item_index').addClass('is_active');
    $('#sidebar').parent().parent().hide();
  });
</script>

<div class="row">
  <div class="large-12 medium-12 columns">
    <div class="markdown-body article-wrap">

      <div class="article">
        
        <h1>Swift版本间差异</h1>
        <div class="read-more clearfix">
          <span class="date">2018/5/10</span>
           
          <span class="comments">
             
          </span>
        </div>
      </div>

      <div class="article-content">
        <ul>
<li>
<a href="#toc_0">一、@objc</a>
</li>
<li>
<a href="#toc_1">二、 #selector</a>
<ul>
<li>
<a href="#toc_2">1. 定义格式</a>
</li>
<li>
<a href="#toc_3">2. 方法定义规定</a>
</li>
<li>
<a href="#toc_4">3. self</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">三、懒加载</a>
<ul>
<li>
<a href="#toc_6">1. 懒加载情景</a>
</li>
<li>
<a href="#toc_7">2. 延迟属性与闭包</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">四、dispatch_once</a>
</li>
<li>
<a href="#toc_9">五、单例模式</a>
</li>
</ul>


<h4 id="toc_0">一、@objc</h4>

<ul>
<li>将用Swift写的API暴露给ObjC使用，需要增加@objc关键字；</li>
</ul>

<p><strong>1). Swift 3.0</strong></p>

<ul>
<li><p>a. 编译器默认给继承于NSObject的类的所有方法都隐式添加@objc；缺点是大量@objc导致二进制文件增大；</p>

<pre><code class="language-swift">class MyClass: NSObject {
    func print() { } // 包含隐式的 @objc
}
</code></pre></li>
</ul>

<span id="more"></span><!-- more -->

<p><strong>2). Swift 4.0</strong></p>

<ul>
<li><strong>a. 隐式添加@objc只存在以下场景：覆盖父类的ObjC方法、符合一个ObjC的协议；</strong></li>
<li><p>b. 显式给方法添加@objc；</p>

<pre><code>class MyClass: NSObject {
    @objc func print() { } // 显示加上 @objc
}
</code></pre></li>
<li><p>c. 若类名前加@objcMembers，则其及其扩展、子类的所有方法都隐式添加@objc；</p>

<pre><code class="language-swift">@objcMembers class MyClass: NSObject {
    func print() { } // 包含隐式的 @objc
}

extension MyClass {
    func a() { } // 包含隐式的 @objc
}
</code></pre></li>
<li><p>d. 若扩展名前加@objc，则该扩展的所有方法都隐式添加@objc；</p>

<pre><code class="language-swift">class MyClass { }

@objc extension MyClass {
    func a() { } // 包含隐式的 @objc
}
</code></pre></li>
<li><p>e. 若扩展名前加@noobjc，则该扩展的所有方法都不会隐式添加@objc（排除类名前加@objcMembers的影响）；</p>

<pre><code class="language-swift">@objcMembers class MyClass : NSObject {
    func print() { } // 包含隐式的 @objc
}

@nonobjc extension MyClass {
    func a() { } // 不会包含隐式的 @objc
}
</code></pre></li>
<li><p><strong>设置Xcode的<code>Build Settings</code>中的<code>Swift 3 @objc Inference</code>，决定是否继续采用Swift 3.0隐式添加@objc的模式；</strong></p></li>
</ul>

<h4 id="toc_1">二、 #selector</h4>

<h5 id="toc_2">1. 定义格式</h5>

<p><strong>1). Swift 2.2前</strong></p>

<pre><code class="language-swift">// 无参数
Selector(&quot;btnDidClick&quot;)
// 有参数
Selector(&quot;btnDidClick:&quot;)
</code></pre>

<p><strong>2). Swift 2.2</strong></p>

<pre><code class="language-swift">// 无参数
#selector(btnDidClick)
// 有参数，参数名称使用下划线；具体方法的参数名称可任意设置
#selector(btnDidClick(_:))
</code></pre>

<p><strong>3). Swift 3.0</strong></p>

<pre><code class="language-swift">// 无参数
#selector(btnDidClick)
// 有参数，参数名称必须具体给出；具体方法的参数名称必须一致
#selector(btnDidClick(btn:))
</code></pre>

<h5 id="toc_3">2. 方法定义规定</h5>

<ul>
<li><strong>#selector使用到了ObjC运行时，所以方法必须要能被ObjC访问才行（加@objc修饰符）；</strong></li>
</ul>

<p><strong>1). Swift 3.0</strong></p>

<ul>
<li><strong>只有当方法的权限为<code>private</code>，才需要加@objc修饰符，否则不需要添加；</strong></li>
</ul>

<p><strong>2). Swift 4.0</strong></p>

<ul>
<li>所有的方法都要加@objc修饰符，不论其权限是否为private；</li>
</ul>

<h5 id="toc_4">3. self</h5>

<ul>
<li><p><strong><code>btn.addTarget(self, action: #selector()...</code>中的self是动态的；比如在A中初始化了B，B中的btn初始化时进行了<code>addTarget(self...</code>，则此时self为A而不是B；</strong></p></li>
<li><p><strong>解决上述问题的方式有两种：一种是不在A中初始化B，一种是写成<code>btn.addTarget(B.self, action: #selector()...</code></strong>；</p></li>
</ul>

<h4 id="toc_5">三、懒加载</h4>

<h5 id="toc_6">1. 懒加载情景</h5>

<ul>
<li><strong>全局的常/变量都是懒加载的，不需要标记lazy；</strong></li>
<li><strong>标记为<code>static</code>的常/变量存储属性（类属性）也都是懒加载的，不需要标记lazy；（补充：class只能修饰计算属性，而计算属性只能使用var修饰）</strong></li>
<li><strong>延迟属性，必须使用<code>lazy var</code>标记；（延迟属性只能使用var修饰，不能使用let修饰）</strong></li>
</ul>

<h5 id="toc_7">2. 延迟属性与闭包</h5>

<ul>
<li><p><strong>延迟属性使用<code>lazy var</code>标记声明，其初始值可以是直接创建，也可以使用闭包创建；</strong></p>

<pre><code class="language-swift">// 直接创建
lazy var person1: Person = Person()

// 闭包创建
lazy var person2: Person = {
    let person = Person()
    p.name = &quot;Tom&quot;
    print(&quot;Tom...&quot;)
    return person
}()
</code></pre></li>
<li><p><strong>使用闭包不仅仅可以给延迟属性（lazy var）设置初始值，也可以给全局的常/变量、类的属性、对象的属性进行初始值，计算属性本质通过闭包实现的；</strong></p>

<pre><code class="language-swift">let i = {
    return 0
}()

class Person {
    static let a = {
        return 1
    }()
    var b = {
        return 2
    }()
}
</code></pre></li>
<li><p>在布局UI控件的时候也可以使用闭包来完成初始化赋值，这样更便于复用、更简洁；</p>

<pre><code class="language-swift">let leftButton: UIButton = {
    let button = UIButton(frame: buttonSize)
    button.backgroundColor = .black
    button.titleLabel?.text = &quot;left&quot;
    return button
}()

let rightButton: UIButton = {
    let button = UIButton(frame: buttonSize)
    button.backgroundColor = .black
    button.titleLabel?.text = &quot;right&quot;
    return button
}()
</code></pre></li>
<li><p><strong>延迟属性使用闭包创建，在闭包中使用self不会产生循环引用；全局的常/变量、类的属性、对象的属性使用闭包创建，无在闭包中使用self；</strong></p></li>
</ul>

<h4 id="toc_8">四、dispatch_once</h4>

<ul>
<li><p>Swift 3.0废弃了dispatch_once，但是<strong>全局的常/变量</strong>和<strong>标记为<code>static</code>的常/变量存储属性</strong>底层实现都是使用dispatch_once机制且线程安全的，它们都是只会执行一次；延迟属性是对象属性，会被执行多次；</p></li>
<li><p>也可以通过手动给DispatchQueue扩展一个方法实现dispatch_once的功能；<code>objc_sync_enter、objc_sync_exit</code>等价于OC中的<code>@synchronized(TOKEN) { }</code>；</p>

<pre><code class="language-swift">public extension DispatchQueue {
    private static var _onceTracker = [String]()

    public static func once(token: String, block: ()-&gt;Void) {
        objc_sync_enter(self)
        defer {
            objc_sync_exit(self)
        }

        if _onceTracker.contains(token) {
            return
        }
        _onceTracker.append(token)
        block()
    }

    public static func once(block: ()-&gt;Void) {
        let token = #file + &quot;:&quot; + #function + &quot;:&quot; + String(#line)
        self.once(token: token, block: block)
    }
}
</code></pre>

<pre><code class="language-swift">// usage1
private let _onceToken = UUID().uuidString

print(_onceToken)
DispatchQueue.once(token: _onceToken) {
    // TODO
}

// usage2
DispatchQueue.once {
    // TODO
}
</code></pre></li>
</ul>

<h4 id="toc_9">五、单例模式</h4>

<p><strong>1). Swift 1.2之前</strong></p>

<ul>
<li><p>类不支持存储型类型属性（let、var），结构体支持；</p>

<pre><code class="language-swift">// OC移植版
class MyManager {
    // 类型计算属性，相当于类方法（可访问类型属性、或全局量）
    class var sharedManager : MyManager {
        // 嵌套定义结构体：借助该结构体存储该单例对象
        struct Static {
            static var onceToken : dispatch_once_t = 0
            static var staticInstance : MyManager? = nil
        }

        dispatch_once(&amp;Static.onceToken) {
            Static.staticInstance = MyManager()
        }

        return Static.staticInstance!
    }
}
</code></pre>

<pre><code class="language-swift">// 简化版：不使用dispatch_once
class MyManager {
    class var sharedManager : MyManager {
        // 嵌套定义结构体：借助该结构体存储该单例对象
        struct Static {
            static let sharedInstance : MyManager = MyManager()
        }

        return Static.sharedInstance
    }
}
</code></pre>

<pre><code>// 优化版：使用 私有的全局量 存储单例对象
private let sharedInstance = MyManager()

class MyManager  {
    class var sharedManager : MyManager {
        return sharedInstance
    }
}
</code></pre></li>
</ul>

<p><strong>2). Swift 1.2</strong></p>

<ul>
<li><p><strong>类开始支持存储型类型属性（let、var）；</strong></p>

<pre><code>class MyManager {
    private static let sharedInstance : MyManager = MyManager()
    class var sharedManager : MyManager {
        return sharedInstance
    }
    private init() {}
}
</code></pre>

<pre><code>// 最终版
class MyManager  {
    static let sharedInstance = MyManager()
    private init() {}
}
</code></pre></li>
</ul>

<p><strong>3). 补充（ObjC单例）</strong></p>

<pre><code class="language-ObjC">@interface MyManager : NSObject
    
+ (instancetype)sharedManager;
    
@end
</code></pre>

<pre><code class="language-ObjC">/**
 *  饿汉式，类被加载时就创建唯一实例
 */
@implementation MyManager
    
// 标示唯一的实例，该static全局变量的作用域仅限于当前文件内部
static id _instance;
    
// 当类被加载到OC运行时环境（内存）时调用（一个类只会被加载1次）
+ (void)load {
    NSLog(@&quot;load...&quot;);
    // 创建该类的唯一实例（因为在load这里就使用了类，故initialize也被调用）
    _instance = [[self alloc] init]; 
}
    
// 当第一次使用该类的时候调用
+ (void)initialize {
    NSLog(@&quot;initialize...&quot;);
}
    
// alloc方法的内部会调用该方法
+ (id)allocWithZone:(struct _NSZone *)zone {
    if (_instance == nil) { // 防止多次创建
        _instance = [super allocWithZone:zone];
    }
    return _instance;
}
    
// copy方法的内部会调用该方法（由于是对象方法，对象已存在，不需要判断直接返回对象）
- (id)copyWithZone:(NSZone *)zone {
    return _instance;
}
    
+ (instancetype)sharedManager {
    return _instance; // 直接返回已创建的实例
}
    
@end
</code></pre>

<pre><code class="language-ObjC">/**
 *  懒汉式，使用时再创建唯一实例
 */
@implementation MyManager
    
static id _instance;
    
+ (id)allocWithZone:(struct _NSZone *)zone {
    if (_instance == nil) { // 防止频繁加锁
        @synchronized(self) {
            if (_instance == nil) { // 防止多次创建
                _instance = [super allocWithZone:zone];
            }
        }
    }
    // GCD
    // static dispatch_once_t onceToken;
    // dispatch_once(&amp;onceToken, ^{
    //     _instace = [super allocWithZone:zone];
    // });
    return _instance;
}
    
- (id)copyWithZone:(NSZone *)zone {
    return _instance;
}
    
+ (instancetype)sharedManager {
    if (_instance == nil) { // 防止频繁加锁
        @synchronized(self) {
            if (_instance == nil) { // 防止多次创建
                _instance = [[self alloc] init];
            }
        }
    }
    // GCD
    // static dispatch_once_t onceToken;
    // dispatch_once(&amp;onceToken, ^{
    //     _instace = [super allocWithZone:zone];
    // });
    return _instance;
}
    
@end
</code></pre>

<pre><code class="language-ObjC">// MRC情况下还需要实现以下方法
- (oneway void)release {}
- (id)autorelease { return self; }
- (id)retain { return self; }
- (NSUInteger)retainCount { return 1; }
</code></pre>

      </div>

      <div class="row">
        <div class="large-6 columns">
          <p class="text-left" style="padding:15px 0px;">
            
            <a href="15285683833705.html" title="Previous Post: 错误、异常的处理（Java、ObjC、Swift）">&laquo; 错误、异常的处理（Java、ObjC、Swift）</a>
            
          </p>
        </div>
        <div class="large-6 columns">
          <p class="text-right" style="padding:15px 0px;">
            
            <a href="15237039848080.html" title="Next Post: Android编程权威指南 笔记(19~24)">Android编程权威指南 笔记(19~24) &raquo;</a>
            
          </p>
        </div>
      </div>

      <div class="comments-wrap">
        <div class="share-comments">
            
        </div>
      </div>

    </div>
  </div> <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">

      <div id="site-info" class="site-info">
        
        <h1>TIME TO GO</h1>
        <div class="site-des">It is just a matter of time.</div>
        <div class="social">
                    
          <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
        </div>
      </div>

      

      <div id="site-categories" class="side-item ">
        <div class="side-header">
          <h2>Categories</h2>
        </div>
        <div class="side-content">
          <p class="cat-list">
            
          </p>
        </div>
      </div>

      <div id="site-categories" class="side-item">
        <div class="side-header">
          <h2>Recent Posts</h2>
        </div>
        <div class="side-content">
          <ul class="posts-list">
              <li class="post">
              <a href="15339807662944.html">Ubuntu使用教程</a>
              </li>
                 <li class="post">
              <a href="15332159757050.html">证书、SSL、HTTPS</a>
              </li>
                 <li class="post">
              <a href="15327896998795.html">Python中的常见问题</a>
              </li>
                 <li class="post">
              <a href="15288255574523.html">Python3笔记(19实战)</a>
              </li>
                 <li class="post">
              <a href="15285683833705.html">错误、异常的处理（Java、ObjC、Swift）</a>
              </li>
                                             
          </ul>
        </div>
      </div>

    </div>
  </div>
</div>

</div> <div class="page-bottom clearfix">
  <div class="row">
    <p class="copyright">Copyright &copy; 2015 Powered by
      <a target="_blank" href="">ME</a>
    </p>
  </div>
</div>
</section>

</div>
</div>

 
<script src="asset/js/foundation.min.js"></script>
<script>
  $(document).foundation();
  function fixSidebarHeight() {
    var w1 = $('.markdown-body').height();
    var w2 = $('#sidebar').height();
    if (w1 > w2) { $('#sidebar').height(w1); };
  }
  $(function () {
    fixSidebarHeight();
  })
  $(window).load(function () {
    fixSidebarHeight();
  });
</script>   
</body>

</html>