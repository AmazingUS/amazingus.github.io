<!doctype html>
<html class="no-js" lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>
     Swift知识点总结 - TIME TO GO 
  </title>
   
  <link href="atom.xml" rel="alternate" title="TIME TO GO" type="application/atom+xml">
  <link rel="stylesheet" href="asset/css/foundation.min.css" />
  <link rel="stylesheet" href="asset/css/docs.css" />
  <script src="asset/js/vendor/modernizr.js"></script>
  <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
  <script type="text/javascript">
    function before_search() {
      var searchVal = 'site: ' + document.getElementById('search_input').value;
      document.getElementById('search_q').value = searchVal;
      return true;
    }
  </script>
</head>

<body class="antialiased hide-extras">
  <div class="marketing off-canvas-wrap" data-offcanvas>
    <div class="inner-wrap">


      <nav class="top-bar docs-bar hide-for-small" data-topbar>
        <section class="top-bar-section">
          <div class="row">
            <div style="position: relative;width:100%;">
              <div style="position: absolute; width:100%;">
                <ul id="main-menu" class="left">
                  
                  <li id="">
                    <a target="self" href="index.html">Home</a>
                  </li>
                  
                  <li id="">
                    <a target="_self" href="archives.html">Archives</a>
                  </li>
                  
                </ul>
                <ul class="right" id="search-wrap">
                  <li>
                    <form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
                      <input type="hidden" id="search_q" name="q" value="" />
                      <input tabindex="1" type="search" id="search_input" placeholder="Search" />
                    </form>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </section>
      </nav>

      <nav class="tab-bar show-for-small">
        <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
          <span> &nbsp; TIME TO GO</span>
        </a>
      </nav>

      <aside class="left-off-canvas-menu">
        <ul class="off-canvas-list">
          <li>
            <a href="index.html">HOME</a>
          </li>
          <li>
            <a href="archives.html">Archives</a>
          </li>
          <li>
            <a href="about.html">ABOUT</a>
          </li>
          <li>
            <label>Categories</label>
          </li>
          
        </ul>
      </aside>
      <a class="exit-off-canvas" href="#"></a>
      <section id="main-content" role="main" class="scroll-container"> <script type="text/javascript">
  $(function () {
    $('#menu_item_index').addClass('is_active');
    $('#sidebar').parent().parent().hide();
  });
</script>

<div class="row">
  <div class="large-12 medium-12 columns">
    <div class="markdown-body article-wrap">

      <div class="article">
        
        <h1>Swift知识点总结</h1>
        <div class="read-more clearfix">
          <span class="date">2018/5/10</span>
           
          <span class="comments">
             
          </span>
        </div>
      </div>

      <div class="article-content">
        <ul>
<li>
<a href="#toc_0">一、@objc</a>
</li>
<li>
<a href="#toc_1">二、#selector</a>
<ul>
<li>
<a href="#toc_2">（一）定义的格式</a>
</li>
<li>
<a href="#toc_3">（二）方法定义的规定</a>
</li>
<li>
<a href="#toc_4">（三）self问题</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">三、懒加载</a>
<ul>
<li>
<a href="#toc_6">（一）懒加载情景</a>
</li>
<li>
<a href="#toc_7">（二）延迟属性与闭包</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">四、dispatch_once</a>
</li>
<li>
<a href="#toc_9">五、单例模式</a>
</li>
<li>
<a href="#toc_10">六、Equatable、Hashable协议</a>
<ul>
<li>
<a href="#toc_11">（一）Objective-C的 ==、isEqual:、isEqualToString:、hash</a>
</li>
<li>
<a href="#toc_12">（二）swift的 === 、==、Equatable、Hashable、Comparable</a>
</li>
</ul>
</li>
<li>
<a href="#toc_13">七、NSString、String编码</a>
<ul>
<li>
<a href="#toc_14">（一）NSString</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">八、构造器</a>
</li>
<li>
<a href="#toc_16">九、错误处理方式</a>
</li>
<li>
<a href="#toc_17">十、扩展、协议</a>
</li>
<li>
<a href="#toc_18">十一、编译器合成 (synthesize)</a>
</li>
<li>
<a href="#toc_19">十二、代理</a>
</li>
<li>
<a href="#toc_20">十三、KVO、KVC</a>
</li>
<li>
<a href="#toc_21">十四、常见错误</a>
</li>
</ul>


<h4 id="toc_0">一、@objc</h4>

<ul>
<li><p>作用：将Swift API暴露给ObjC使用，需要增加@objc关键字；</p></li>
<li><p><strong>1、Swift 3.0</strong></p>

<ul>
<li><p>a. 编译器默认给继承于NSObject的类的所有方法都隐式添加@objc；缺点是大量@objc导致二进制文件增大；</p>

<pre><code class="language-swift">class MyClass: NSObject {
    func print() { } // 包含隐式的 @objc
}
</code></pre></li>
</ul>

<span id="more"></span><!-- more --></li>
<li><p><strong>2、Swift 4.0</strong></p>

<ul>
<li><strong>a. 隐式添加@objc只存在以下场景：覆盖父类的ObjC方法、符合一个ObjC的协议；</strong></li>
<li><p>b. 显式给方法添加@objc；</p>

<pre><code>class MyClass: NSObject {
    @objc func print() { } // 显示加上 @objc
}
</code></pre></li>
<li><p>c. 若类名前加@objcMembers，则其及其扩展、子类的所有方法都隐式添加@objc；</p>

<pre><code class="language-swift">@objcMembers class MyClass: NSObject {
    func print() { } // 包含隐式的 @objc
}

extension MyClass {
    func a() { } // 包含隐式的 @objc
}
</code></pre></li>
<li><p>d. 若扩展名前加@objc，则该扩展的所有方法都隐式添加@objc；</p>

<pre><code class="language-swift">class MyClass { }

@objc extension MyClass {
    func a() { } // 包含隐式的 @objc
}
</code></pre></li>
<li><p>e. 若扩展名前加@noobjc，则该扩展的所有方法都不会隐式添加@objc（排除类名前加@objcMembers的影响）；</p>

<pre><code class="language-swift">@objcMembers class MyClass : NSObject {
    func print() { } // 包含隐式的 @objc
}

@nonobjc extension MyClass {
    func a() { } // 不会包含隐式的 @objc
}
</code></pre></li>
<li><p><strong>设置Xcode的<code>Build Settings</code>中的<code>Swift 3 @objc Inference</code>，决定是否继续采用Swift 3.0隐式添加@objc的模式；</strong></p></li>
</ul></li>
</ul>

<h4 id="toc_1">二、#selector</h4>

<h5 id="toc_2">（一）定义的格式</h5>

<ul>
<li><p><strong>1、Swift 2.2前</strong></p>

<pre><code class="language-swift">// 无参数
Selector(&quot;btnDidClick&quot;)
// 有参数
Selector(&quot;btnDidClick:&quot;)
</code></pre></li>
<li><p><strong>2、Swift 2.2</strong></p>

<pre><code class="language-swift">// 无参数
#selector(btnDidClick)
// 有参数，参数名称使用下划线；具体方法的参数名称可任意设置
#selector(btnDidClick(_:))
</code></pre></li>
<li><p><strong>3、Swift 3.0</strong></p>

<pre><code class="language-swift">// 无参数
#selector(btnDidClick)
// 有参数，参数名称必须具体给出；具体方法的参数名称必须一致
#selector(btnDidClick(btn:))
</code></pre></li>
</ul>

<h5 id="toc_3">（二）方法定义的规定</h5>

<ul>
<li><p><strong>#selector使用到了ObjC运行时，所以方法必须要能被ObjC访问才行（加@objc修饰符）；</strong></p></li>
<li><p><strong>1、Swift 3.0</strong></p>

<ul>
<li><strong>只有当方法的权限为<code>private</code>，才需要加@objc修饰符，否则不需要添加；</strong></li>
</ul></li>
<li><p><strong>2、Swift 4.0</strong></p>

<ul>
<li>所有的方法都要加@objc修饰符，不论其权限是否为private；</li>
</ul></li>
</ul>

<h5 id="toc_4">（三）self问题</h5>

<ul>
<li><p><strong><code>btn.addTarget(self, action: #selector()...</code>中的self是动态的；比如在A中初始化了B，B中的btn初始化时进行了<code>addTarget(self...</code>，则此时self为A而不是B；</strong></p></li>
<li><p><strong>解决上述问题的方式有两种：一种是不在A中初始化B，一种是写成<code>btn.addTarget(B.self, action: #selector()...</code></strong>；</p></li>
</ul>

<h4 id="toc_5">三、懒加载</h4>

<h5 id="toc_6">（一）懒加载情景</h5>

<ul>
<li><strong>全局的常量变量都是懒加载的，不需要标记lazy；（补充：Swift的static和ObjC的不一样，只能在类型定义中使用）</strong></li>
<li><strong>标记为<code>static</code>的存储型的类型属性（常量变量）也是懒加载的，不需要标记lazy；（补充：static可以修饰存储型的和计算型的类型属性，class可以修饰类类型的计算型的类型属性）</strong></li>
<li><strong>延迟属性：必须使用<code>lazy var</code>标记；（延迟属性只能使用var修饰，不能使用let修饰）</strong></li>
</ul>

<h5 id="toc_7">（二）延迟属性与闭包</h5>

<ul>
<li><p><strong>延迟属性使用<code>lazy var</code>标记声明，其初始值可以使用直接方式创建，也可以使用闭包方式创建；</strong></p>

<pre><code class="language-swift">// 直接方式创建
lazy var person1: Person = Person()

// 闭包方式创建
lazy var person2: Person = {
    let person = Person()
    p.name = &quot;Tom&quot;
    print(&quot;Tom...&quot;)
    return person
}()
</code></pre></li>
<li><p><strong>闭包不仅仅可以给延迟属性（lazy var）设置初始值，也可以给全局的常/变量、类的属性、对象的属性进行初始值，计算属性本质通过闭包实现的；</strong></p>

<pre><code class="language-swift">let i = {
    return 0
}()

class Person {
    static let a = {
        return 1
    }()
    var b = {
        return 2
    }()
}
</code></pre></li>
<li><p>在布局UI控件的时候，也可以使用闭包方式来完成初始化赋值，这样更便于复用、更简洁；</p>

<pre><code class="language-swift">let leftButton: UIButton = {
    let button = UIButton(frame: buttonSize)
    button.backgroundColor = .black
    button.titleLabel?.text = &quot;left&quot;
    return button
}()

let rightButton: UIButton = {
    let button = UIButton(frame: buttonSize)
    button.backgroundColor = .black
    button.titleLabel?.text = &quot;right&quot;
    return button
}()
</code></pre></li>
<li><p><strong>延迟属性使用闭包方式创建，在闭包中使用self不会产生循环引用；全局的常/变量、类的属性、对象的属性使用闭包方式创建，在闭包中无法使用self；</strong></p></li>
</ul>

<h4 id="toc_8">四、dispatch_once</h4>

<ul>
<li><p>Swift 3.0废弃了dispatch_once，但是<strong>全局的常/变量</strong>和<strong>标记为<code>static</code>的常/变量存储属性</strong>底层实现都是使用dispatch_once机制且线程安全的，它们都是只会执行一次；延迟属性是对象属性，会被执行多次；</p></li>
<li><p>也可以通过手动给DispatchQueue扩展一个方法实现dispatch_once的功能；<code>objc_sync_enter、objc_sync_exit</code>等价于OC中的<code>@synchronized(TOKEN) { }</code>；</p>

<pre><code class="language-swift">public extension DispatchQueue {
    private static var _onceTracker = [String]()

    public static func once(token: String, block: ()-&gt;Void) {
        objc_sync_enter(self)
        defer {
            objc_sync_exit(self)
        }

        if _onceTracker.contains(token) {
            return
        }
        _onceTracker.append(token)
        block()
    }

    public static func once(block: ()-&gt;Void) {
        let token = #file + &quot;:&quot; + #function + &quot;:&quot; + String(#line)
        self.once(token: token, block: block)
    }
}
</code></pre>

<pre><code class="language-swift">// usage1
private let _onceToken = UUID().uuidString

print(_onceToken)
DispatchQueue.once(token: _onceToken) {
    // TODO
}

// usage2
DispatchQueue.once {
    // TODO
}
</code></pre></li>
</ul>

<h4 id="toc_9">五、单例模式</h4>

<ul>
<li><p><strong>1、 Swift 1.2之前</strong></p>

<ul>
<li><p><strong>类不支持类型存储型属性（let、var），结构体支持；</strong></p>

<pre><code class="language-swift">// OC移植版
class MyManager {
    // 类型计算属性，相当于类方法（可访问类型属性、或全局量）
    class var sharedManager : MyManager {
        // 嵌套定义结构体：借助该结构体存储该单例对象
        struct Static {
            static var onceToken : dispatch_once_t = 0
            static var staticInstance : MyManager? = nil
        }

        dispatch_once(&amp;Static.onceToken) {
            Static.staticInstance = MyManager()
        }

        return Static.staticInstance!
    }
}
</code></pre>

<pre><code class="language-swift">// 简化版：不使用dispatch_once
class MyManager {
    class var sharedManager : MyManager {
        // 嵌套定义结构体：借助该结构体存储该单例对象
        struct Static {
            static let sharedInstance : MyManager = MyManager()
        }

        return Static.sharedInstance
    }
}
</code></pre>

<pre><code>// 优化版：使用 私有的全局量 存储单例对象
private let sharedInstance = MyManager()

class MyManager  {
    class var sharedManager : MyManager {
        return sharedInstance
    }
}
</code></pre></li>
</ul></li>
<li><p><strong>2、Swift 1.2开始</strong></p>

<ul>
<li><p><strong>类开始支持类型存储型属性（let、var）；</strong></p>

<pre><code>class MyManager {
    private static let sharedInstance : MyManager = MyManager()
    class var sharedManager : MyManager {
        return sharedInstance
    }
    private init() {}
}
</code></pre>

<pre><code>// 最终版
class MyManager  {
    static let sharedInstance = MyManager()
    private init() {}
}
</code></pre></li>
</ul></li>
<li><p><strong>3、补充（ObjC单例）</strong></p>

<pre><code class="language-ObjC">@interface MyManager : NSObject

+ (instancetype)sharedManager;

@end
</code></pre>

<pre><code class="language-ObjC">/**
 *  饿汉式，类被加载时就创建唯一实例
 */
@implementation MyManager

// 标示唯一的实例，该static全局变量的作用域仅限于当前文件内部
static id _instance;

// 当类被加载到OC运行时环境（内存）时调用（一个类只会被加载1次）
+ (void)load {
    NSLog(@&quot;load...&quot;);
    // 创建该类的唯一实例（因为在load这里就使用了类，故initialize也被调用）
    _instance = [[self alloc] init]; 
}

// 当第一次使用该类的时候调用
+ (void)initialize {
    NSLog(@&quot;initialize...&quot;);
}

// alloc方法的内部会调用该方法
+ (id)allocWithZone:(struct _NSZone *)zone {
    if (_instance == nil) { // 防止多次创建
        _instance = [super allocWithZone:zone];
    }
    return _instance;
}

// copy方法的内部会调用该方法（由于是对象方法，对象已存在，不需要判断直接返回对象）
- (id)copyWithZone:(NSZone *)zone {
    return _instance;
}

+ (instancetype)sharedManager {
    return _instance; // 直接返回已创建的实例
}

@end
</code></pre>

<pre><code class="language-ObjC">/**
 *  懒汉式，使用时再创建唯一实例
 */
@implementation MyManager

static id _instance;

+ (id)allocWithZone:(struct _NSZone *)zone {
    if (_instance == nil) { // 防止频繁加锁
        @synchronized(self) {
            if (_instance == nil) { // 防止多次创建
                _instance = [super allocWithZone:zone];
            }
        }
    }
    // GCD
    // static dispatch_once_t onceToken;
    // dispatch_once(&amp;onceToken, ^{
    //     _instace = [super allocWithZone:zone];
    // });
    return _instance;
}

- (id)copyWithZone:(NSZone *)zone {
    return _instance;
}

+ (instancetype)sharedManager {
    if (_instance == nil) { // 防止频繁加锁
        @synchronized(self) {
            if (_instance == nil) { // 防止多次创建
                _instance = [[self alloc] init];
            }
        }
    }
    // GCD
    // static dispatch_once_t onceToken;
    // dispatch_once(&amp;onceToken, ^{
    //     _instace = [super allocWithZone:zone];
    // });
    return _instance;
}

@end
</code></pre>

<pre><code class="language-ObjC">// MRC情况下还需要实现以下方法
- (oneway void)release {}
- (id)autorelease { return self; }
- (id)retain { return self; }
- (NSUInteger)retainCount { return 1; }
</code></pre></li>
</ul>

<h4 id="toc_10">六、Equatable、Hashable协议</h4>

<h5 id="toc_11">（一）Objective-C的 ==、isEqual:、isEqualToString:、hash</h5>

<ul>
<li><p>1、== 操作符</p>

<ul>
<li>对于对象类型，判断连个两个对象的内存地址是否相同，相同返回true，否则返回false；</li>
</ul></li>
<li><p>2、isEqual:方法</p>

<ul>
<li><strong>默认情况下，比较两个对象的内存地址是否相同；</strong></li>
<li>系统自带的某些类型（如Foundation中的NSString、NSArray等）会重写该方法，改变默认的判断规则（不比较地址，而是比较两个对象的内容）；</li>
<li><strong>对于我们自定义类型的对象，若有判等需求，需要重写该方法；</strong></li>
<li>重写的建议规则：

<ul>
<li>a. 判断传入的对象是否是nil，若是直接返回NO；</li>
<li>b. == 运算符判断是否是同一对象，若相同直接返回YES；</li>
<li>c. 判断是否是同一类型，若不同直接返回NO；</li>
<li>d. 根据场景使用相应的属性进行判等操作，返回最终的操作结果；</li>
</ul></li>
</ul></li>
<li><p>3、isEqualToString:方法</p>

<ul>
<li>NSString的特有方法，只比较字符串本身的内容是否一致，不比较内存地址；</li>
<li>类似的还有isEqualToArray、isEqualToDictionary等；</li>
</ul></li>
<li><p><strong>4、hash方法</strong></p>

<ul>
<li><strong>返回当前对象的hash值，默认值为当前对象的内存地址（<code>p (NSUInteger)self</code>）；</strong></li>
<li><strong>作用：为了加快数据的查找速度；</strong>

<ul>
<li><strong>a. 原始的遍历查询的速度为O(n)，使用基于hash值的Hash Table数据结构的查询速度为O(1)；</strong></li>
<li><strong>b. 一般情况下，不同对象的hash值是不一样；但是某些情况下却是一样的，这时候就出现“hash碰撞”了；故hash值是对象判等的必要非充分条件；</strong></li>
</ul></li>
<li><strong>在对象被添加到NSSet、设置为NSDictionary的key等涉及到Hash Table数据结构时，hash方法会被调用；</strong></li>
<li><strong>重写的建议规则：对相关属性的hash值作XOR运算，如<code>return [_name hash] ^ [_age hash];</code></strong></li>
</ul></li>
<li><p><strong>5、hash方法 与 isEqual:方法的关系</strong></p>

<ul>
<li><strong>由于hash的可以加快查找速度，但可能出现“hash碰撞”，故在应用时，会先调用hash方法根据hash值，快速排除不相等的数据，之后若hash值相同再调用isEqual:方法，作最终的判等操作；这样既加快了速度又不失准确性；</strong><br/></li>
</ul></li>
<li><p><strong>6、自定义类型的对象的<code>判等操作</code></strong></p>

<ul>
<li><strong>若不涉及到Hash Table数据结构的判等操作，无需重写hash方法，只重写isEqual:方法即可；</strong></li>
<li><strong>若涉及到Hash Table数据结构的判等操作，重写hash方法后，也必须重写isEqual:方法；</strong>

<ul>
<li><strong>原因：当时两个对象的内存地址不同时（不同对象），重写hash方法让hash值相同（不相同就快速判定为不相等，这就另当别论了），但是系统还要调用isEqual:方法进行判等，而isEqual:方法的默认行为就是比较内存地址是否相同；</strong></li>
<li><strong>hash方法是加快判等速度，并不能决定所有的判等结果；</strong></li>
</ul></li>
</ul></li>
</ul>

<h5 id="toc_12">（二）swift的 === 、==、Equatable、Hashable、Comparable</h5>

<ul>
<li><p>1、=== 操作符</p>

<ul>
<li>swift中的 === 操作符等价于OC中的 == 操作符，比较的是对象的内存地址；</li>
</ul></li>
<li><p>2、== 操作符、Equatable协议</p>

<ul>
<li><strong>Swift的原生类中没有提供isEqual:方法，其使用 == 操作符的进行两个元素的判等；（等价于OC中的isEqual:方法）</strong></li>
<li><strong>之所以可以对实例使用 == 操作符进行比较，就是因为操作符所操作的类型实现了Equatable协议；若没有实现该协议，则无法使用 == 操作符；</strong></li>
<li><strong>Equatable协议中定义了 <code>static func ==(lhs: Self, rhs: Self) -&gt; Bool</code> 方法要求；</strong></li>
<li><strong>Swift原生类型<code>几乎都</code>实现了Equatable协议；</strong></li>
<li><p><strong>继承于NSObject的Swift类型</strong></p>

<ul>
<li><strong>a. 默认遵循Equatable；</strong></li>
<li><strong>b. 并且 == 操作符的默认实现是调用isEqual(_ object: Any?)方法，而该方法的默认实现是比较内存地址（字符串等类已替换了默认实现）；</strong></li>
<li><strong>c. 因此，可以直接使用 == 进行判等；</strong></li>
<li><p><strong>d. 若认为 == 操作符的默认实现不合理，可以重新实现 == 操作符，但是不需要声明遵循Equatable了（重复了）；</strong></p>

<pre><code class="language-swift">static func ==(lhs: Object, rhs: Object) -&gt; Bool {
    return lhs.text == rhs.text
}
</code></pre></li>
</ul></li>
<li><p><strong>Equatable协议的协议扩展提供了!= 操作符的默认实现；</strong></p>

<pre><code class="language-swift">extension Equatable {
    public static func !=(lhs: Self, rhs: Self) -&gt; Bool {
        return !(lhs == rhs)
    }
}
</code></pre></li>
</ul></li>
<li><p>3、Hashable协议</p>

<ul>
<li>作用等价于OC中的hash方法；若一个对象想作为Dictionary的key，就必须实现Hashable协议；</li>
<li><strong>计算hash值，是通过实现该协议的 <code>var hashValue: Int { get }</code> 属性要求来完成的； hash值推荐计算方法与OC的一样；</strong></li>
<li><strong>与OC中的“重写hash方法后，也必须重写isEqual:方法”类似，在Swift中，Hashable协议继承于Equatable协议；故实现该协议时，需要同时实现 <code>var hashValue: Int { get }</code> 属性要求、<code>static func ==(lhs: Self, rhs: Self) -&gt; Bool</code> 方法要求</strong></li>
<li><p><strong>Swift 4.2开始，为了简化hash值的计算，该协议废弃了<code>var hashValue: Int { get }</code> 属性要求，添加了 <code>func hash(into hasher: inout Hasher)</code> 方法要求（<code>在该方法要求的实现中，调用hasher.combine()传入需要纳入Hash计算的Hashable数据成员即可</code>），该方法会在系统计算hash值时被自动调用；</strong></p>

<pre><code class="language-swift">// Swift 4.2之前，实现Hashable协议
struct Person: Hashable {
    var name: String
    var age: Int

    static func ==(lhs: Person, rhs: Person) -&gt; Bool {
        return lhs.name == rhs.name &amp;&amp; lhs.age == rhs.age
    }

    var hashValue: Int {
        return name.hashValue ^ age.hashValue
    }
}
</code></pre>

<pre><code>// Swift 4.2开始，实现Hashable协议
struct Person: Hashable {
    var name: String
    var age: Int

    static func ==(lhs: Person, rhs: Person) -&gt; Bool {
        return lhs.name == rhs.name &amp;&amp; lhs.age == rhs.age
    }

    func hash(into hasher: inout Hasher) {
        hasher.combine(age)
        hasher.combine(name)
    }
}
</code></pre>

<ul>
<li><p><strong>为了兼容Swift 4.2之前实现Hashable协议的代码，编译器会自动生成 <code>func hash(into hasher: inout Hasher)</code> 的实现，但会提示hashValue已过时的警告；</strong></p>

<pre><code class="language-swift">func hash(into hasher: inout Hasher) {
    hasher.combine(self.hashValue)
}
</code></pre></li>
</ul></li>
</ul></li>
<li><p>4、Comparable协议</p>

<ul>
<li><strong>Equatable协议是对<code>相等性</code>进行比较，而Comparable协议是对<code>顺序</code>进行比较；</strong></li>
<li><p><strong>该协议有以下4个方法要求，并且由于<code>其继承Equatable协议</code>，其一共有6个方法；</strong></p>

<pre><code class="language-swift">static func &lt;(lhs: Self, rhs: Self) -&gt; Bool
static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool
static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool
static func &gt;(lhs: Self, rhs: Self) -&gt; Bool
</code></pre></li>
<li><p><strong>实现了Comparable协议，就可以使用 <code>==、!=、&lt;、&lt;=、&gt;=、&gt;</code> 操作符进行比较了；</strong></p></li>
<li><p><strong>Swift标准库为 <code>!=、&lt;=、&gt;=、&gt;</code> 这4个操作符提供了默认的实现（通过 <code>==、&lt;</code> 可推导出）；故只需要实现 <code>==、&lt;</code> 操作符，即可完整地实现该协议；</strong></p></li>
</ul></li>
</ul>

<h4 id="toc_13">七、NSString、String编码</h4>

<h5 id="toc_14">（一）NSString</h5>

<ul>
<li><strong>NSString是建立在Unicode之上的，但是NSString在开发的时候（1994年），Unicode还是16位的，之后Unicode才扩展到21位；</strong></li>
<li><strong>所以，NSString对象代表的是用UTF-16编码的码元组成的数组；相应地，length方法的返回值也是字符串包含的码元个数（而不是字符个数）</strong>；</li>
<li><code>[NSString length]</code>返回返回值与实际（可见）字符数不符，有以下场景：

<ul>
<li><strong>a. 基本多文种平面外的字符</strong>：BMP里所有的字符在UTF-16里都可以用一个码元表示，其余的字符都需要两个码元（一个代理对），如emoji字符；</li>
<li><strong>b. 组合字符序列</strong>：字母é是以分解形式（e + ´）编码（默认），算作两个码元；某些字母，也可以调用precomposedStringWithCanonicalMapping方法，以合成形式编码；</li>
<li><strong>c. 变体序列</strong>：它们和分解形式的组合字符序列的工作方式一样，因此变体选择符也算作单独的字符；</li>
</ul></li>
<li>参考：<code>https://objccn.io/issue-9-1/</code></li>
</ul>

<h4 id="toc_15">八、构造器</h4>

<ul>
<li><p><strong>1、无参默认构造器</strong></p>

<ul>
<li><strong>a. Swift将为<code>所有的存储型属性，都有默认值</code>并且<code>没有定义任何构造器（类：指定构造器）</code>的<code>结构体</code>或<code>基类</code>，提供一个无参默认构造器</strong>；</li>
<li><strong>b. 可选的var属性若没有显式设置默认值，则有隐式默认值nil，可选的let属性没有默认值；</strong></li>
<li>c. 调用该无参默认构造器，可以创建一个所有属性值都设置为默认值的实例；</li>
</ul></li>
<li><p><strong>2、结构体的成员逐一构造器</strong></p>

<ul>
<li><strong>a. Swift还将为<code>没有定义任何构造器</code>的<code>结构体</code>，提供一个成员逐一构造器，<code>即使有的存储型属性，没有默认值</code>；</strong></li>
<li>b. 可选的var属性若没有显式设置默认值，则有隐式默认值nil，可选的let属性没有默认值；</li>
<li>c. 该成员逐一构造器的参数名称与成员属性名相同，调用其可以进行传值来完成对成员属性的初始赋值；</li>
</ul></li>
<li><p><strong>3、自定义构造器</strong></p>

<ul>
<li>a. 若自定义任何构造器，则Swift不会提供<code>无参默认构造器</code>、<code>成员逐一构造器</code>；</li>
<li><strong>b. 在自定义任何构造器中，必须初始化<code>所有没有默认值的存储型属性</code>；</strong></li>
<li><strong>c. 技巧：给自定义构造器的参数添加<code>默认参数值</code>，这样也可以在调用时不传递构造参数，相对于又提供了<code>一个隐式的无参默认构造器</code>；</strong></li>
</ul></li>
<li><p><strong>4、指定构造器、便利构造器</strong></p>

<ul>
<li>Swift的类类型的构造器可以分为两种类型：指定构造器(Designated Initializer)、便利构造器(Convenience Initializer)，值类型的构造器没有区分；</li>
</ul></li>
<li><p><strong>5、构造器的继承</strong></p>

<ul>
<li><strong>子类默认不会继承父类的构造器；但是若满足某些条件，父类的构造器还是可以继承给子类，这意味着不必复写父类的构造器；</strong></li>
<li><strong>首先必须<code>子类新增的存储属性</code>都提供了<code>默认值</code>，那么则</strong>：

<ul>
<li><strong>a. 若子类中没有新增任何自定义的指定构造器（新增便利构造器可有可无），那么子类会自动继承父类的所有指定构造器；</strong></li>
<li><strong>b. 若子类提供了所有父类的指定构造器的实现（无论是通过继承来的，还是自定义实现的），（新增便利构造器可有可无），那么子类自动继承所有父类的便利构造器；</strong>

<ul>
<li><strong>注：子类自定义实现的父类的指定构造器时，可以重写，也可以将其实现为便利构造器；</strong></li>
</ul></li>
</ul></li>
</ul></li>
<li><p><strong>6、构造器的重写、覆盖</strong></p>

<ul>
<li><strong>a. 父类的指定构造器可以被<code>子类重写</code>成指定构造器（必须添加override）、便利构造器（不必添加override）；</strong></li>
<li><strong>b. 父类的便利构造器可以被<code>子类覆盖</code>为指定构造器、便利构造器，不必添加override；</strong></li>
</ul></li>
<li><p><strong>7、补充</strong></p>

<ul>
<li><strong>Objective-C</strong>

<ul>
<li><strong>a. Objective-C中的类几乎派生自NSObject；所有类的都有<code>init</code>初始化方法，无论该方法是否是NS_DESIGNATED_INITIALIZER；</strong></li>
<li><strong>b. 若类没有指定NS_DESIGNATED_INITIALIZER，则默认把<code>init</code>作为NS_DESIGNATED_INITIALIZER；</strong></li>
<li><strong>c. 若类指定NS_DESIGNATED_INITIALIZER，那么<code>init</code>将只是一个普通的初始化方法；</strong></li>
</ul></li>
<li><p><strong>Swift</strong></p>

<ul>
<li><p><strong>a. Swift中的纯Swift类默认不派生任何类；当类自定义指定构造器时，将导致不自动生成默认的<code>init()</code>初始化方法（指定构造器），除非手动自定义，否则调用时无法使用<code>ClassName()</code>形式初始化；而子类之后是否使用override修饰当前类中的<code>init()</code>，取决于父类是否有该方法；</strong></p>

<pre><code class="language-swift">class AAA {
    init(aaa: Int) {
    }
}

class BBB: AAA {
    init() { // 不需要加override
        super.init(aaa: 1)
    }
}

//let aaa = AAA() // ❌，没有改构造器了
//let aaa = AAA(aaa: 0) // ✅
//let bbb = BBB() // ✅
//let bbb = BBB(aaa: 0) // ❌，不会继承
</code></pre></li>
<li><p><strong>b. Swift中的Objective-C类（如UIKit的类）派生自NSObject，所有类的都有<code>init()</code>初始化方法，该方法是指定构造器，还是便利构造器，判断规则同上面的Objective-C的；</strong></p></li>
<li><p><strong>c. Swift中的<code>UIView</code>类有两个指定构造器：<code>public init(frame: CGRect)</code>、<code>public init?(coder aDecoder: NSCoder)</code>，而<code>init()</code>为便利构造器；</strong></p>

<ul>
<li><strong>当自定义的子类，自定义指定构造器时，所有构造器不会被继承，但<code>init?(coder aDecoder: NSCoder)</code>必须有，所以要重写（这里重写使用<code>required</code>，而不是<code>override</code>修饰）</strong>；</li>
<li><strong>注意：由于自定义指定构造器，子类将没有<code>init(frame: CGRect)</code>、<code>init()</code>构造器；</strong></li>
</ul></li>
<li><p><strong>d. Swift中的<code>UIViewController</code>类有两个指定构造器：<code>public init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)</code>、<code>public init?(coder aDecoder: NSCoder)</code>，而<code>init()</code>为便利构造器；规则同<code>UIView</code>；</strong></p>

<pre><code class="language-swift">class AAAViewController: UIViewController {  
}

//let aaa1 = AAAViewController() // ✅
//let aaa2 = AAAViewController(coder: xxx) // ✅
//let aaa3 = AAAViewController(nibName: nil, bundle: nil) // ✅
</code></pre>

<pre><code class="language-swift">class BBBViewController: UIViewController {
    // 这里init为指定构造器，父类中的init为便利构造器，故不需要加override；
    // 只能调用super的init(nibName: nil, bundle: nil)、init?(coder aDecoder: NSCoder)，而不能是init()
    init() {
        super.init(nibName: nil, bundle: nil)
        // OR
        // super.init(coder: NSCoder())! // ✅，需要解包
        // OR
        // super.init() // ❌
    }

    // 必须实现（同时也重写了），NSCoding协议要求
    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
}

//let bbb1 = BBBViewController() // ✅
//let bbb2 = BBBViewController(coder: xxx) // ✅
//let bbb3 = BBBViewController(nibName: nil, bundle: nil) // ❌，没有构造器了
</code></pre></li>
</ul></li>
</ul></li>
</ul>

<h4 id="toc_16">九、错误处理方式</h4>

<ul>
<li><p><strong>1、使用throw抛出错误</strong></p>

<ul>
<li>为了明确一个函数、方法可以抛出错误，要在它的声明当中的形式参数后边写上<code>throws</code>关键字，使用<code>throws</code>标记的函数叫做<code>抛出函数</code>；</li>
<li><p><strong>只有抛出函数可以传递错误，任何在非抛出函数中抛出的错误都必须在该函数内部处理；</strong></p>

<pre><code class="language-swift">enum VendingMachineError: Error {
    case invalidSelection
    case outOfStock
    case insufficientFunds(coinsNeeded: Int)
}

struct Item {
    var price: Int
    var count: Int
}
</code></pre>

<pre><code class="language-swift">class VendingMachine {
    var inventory = [
        &quot;Candy Bar&quot;: Item(price: 12, count: 7),
        &quot;Chips&quot;: Item(price: 10, count: 4),
    ]
    var coinsDeposited = 0

    func vend(itemNamed name: String) throws {
        guard let item = inventory[name] else {
            throw VendingMachineError.invalidSelection
        }

        guard item.count &gt; 0 else {
            throw VendingMachineError.outOfStock
        }

        guard item.price &lt;= coinsDeposited else {
            throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)
        }

        coinsDeposited -= item.price

        var newItem = item
        newItem.count -= 1
        inventory[name] = newItem

        print(&quot;Dispensing \(name)&quot;)
    }
}
</code></pre>

<ul>
<li><p><strong>由于vend(itemNamed:)方法传递它抛出的任何错误，所以在调用它的代码，要么直接处理错误（使用do-try-catch、try?、try!），要么继续传递它们（只使用try）；</strong></p>

<pre><code>let favoriteSnacks = [
    &quot;Alice&quot;: &quot;Chips&quot;,
    &quot;Bob&quot;: &quot;Licorice&quot;,
    &quot;Eve&quot;: &quot;Pretzels&quot;,
]

func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
    let snackName = favoriteSnacks[person] ?? &quot;Candy Bar&quot;
    try vendingMachine.vend(itemNamed: snackName)
}
</code></pre></li>
</ul></li>
</ul></li>
<li><p><strong>2、使用do-try-catch捕获错误</strong></p>

<ul>
<li><strong>在非抛出函数中，do-try-catch必须处理所有错误；</strong></li>
<li><p><strong>在抛出函数中，do-try-catch可以有没有处理的错误；</strong></p>

<pre><code class="language-swift">var vendingMachine = VendingMachine()
vendingMachine.coinsDeposited = 8

do {
    try buyFavoriteSnack(&quot;Alice&quot;, vendingMachine: vendingMachine)
} catch VendingMachineError.invalidSelection {
    print(&quot;Invalid Selection.&quot;)
} catch VendingMachineError.outOfStock {
    print(&quot;Out of Stock.&quot;)
} catch VendingMachineError.insufficientFunds(let coinsNeeded) {
    print(&quot;Insufficient funds. Please insert an additional \(coinsNeeded) coins.&quot;)
}
</code></pre></li>
</ul></li>
<li><p><strong>3、使用try?转换错误为可选项</strong></p>

<ul>
<li><p>使用try?可将错误转换为可选项来处理一个错误，若一个错误 try?表达式中抛出，则表达式的值为nil；</p>

<pre><code class="language-swift">func someThrowingFunction() throws -&gt; Int {
    // ...
}

let x = try? someThrowingFunction()
</code></pre>

<pre><code class="language-swift">// 等价于上面的try?
let y: Int?
do {
    y = try someThrowingFunction()
} catch {
    y = nil
}
</code></pre></li>
</ul></li>
<li><p><strong>4、使用try!排除错误</strong></p>

<ul>
<li><p>有时知道一个抛出错误的函数、方法不会在运行时抛出错误，可以在表达式前写try!来取消错误传递；如错误真的抛出了则得到一个运行时错误；</p>

<pre><code class="language-swift">let photo = try! loadImage(&quot;./Resources/John Appleseed.jpg&quot;)
</code></pre></li>
</ul></li>
<li><p><strong>使用defer清理操作</strong></p>

<ul>
<li><strong>defer允许在以任何方式（无论是抛出了错误，还是return、break）离开当前代码块前，执行必须要的清理工作；</strong></li>
<li><p>如，可以使用defer语句来保证文件描述符都关闭并且手动指定的内存到被释放；</p>

<pre><code class="language-swift">func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)

        defer {
            close(file)
        }

        while let line = try file.readline() {
            // Work with the file.
        }
        // close(file) is called here, at the end of the scope.
    }
}
</code></pre></li>
</ul></li>
</ul>

<h4 id="toc_17">十、扩展、协议</h4>

<ul>
<li><p><strong>扩展可以对结构体、枚举、类、协议进行扩展，并且可以添加相关限制；</strong></p></li>
<li><p><strong>1、协议扩展</strong></p>

<ul>
<li><strong>a. 对协议进行扩展，称为协议扩展；</strong></li>
<li><strong>b. 作用是给协议的相关要求提供一个默认实现；</strong></li>
<li><p><strong>c. 被扩展的只能是协议；</strong></p>

<pre><code class="language-swift">protocol ABC {
    func test() -&gt; bool
}

extension ABC {
    func test() -&gt; bool {
        return true
    }
}
</code></pre></li>
</ul></li>
<li><p><strong>2、限定扩展</strong></p>

<ul>
<li><strong>a. <code>extesion ... where ...</code>，必须满足某些条件才进行扩展；</strong></li>
<li><strong>b. 被扩展的只能是<code>带泛型的结构体</code>、<code>带泛型的类</code>、<code>带关联的协议、不带关联的协议</code>；</strong></li>
<li><strong>c. 某些条件为<code>带泛型的（带关联的），限定泛型参数的类型</code>、<code>不带关联的，限定Self的类型</code>；</strong></li>
<li><p>d. <code>https://stackoverflow.com/questions/36173544/trailing-where-clause-for-extension-of-non-generic-type</code></p>

<pre><code>// ❌
extension UINavigationController where Self: UINavigationControllerDelegate
// ✅
extension UINavigationControllerDelegate where Self: UINavigationController
</code></pre></li>
<li><p><strong>e. Swift 3.0开始，支持通过协议进行限制；</strong></p>

<pre><code class="language-swift">// 对结构体进行限制
extension Array where Element: Comparable {
    func lessThanFirst() -&gt; [Element] {
        guard let first = self.first else { return [] }
        return self.filter { $0 &lt; first }
    }
}

// 对协议进行限制
extension Collection where Element: Comparable {
    func lessThanFirst() -&gt; [Element] {
        guard let first = self.first else { return [] }
        return self.filter { $0 &lt; first }
    }
}
</code></pre></li>
<li><p><strong>f. Swift 3.1开始，还支持通过类型进行限制；</strong></p>

<pre><code class="language-swift">// 对结构体进行限制
extension Array where Element == Int {
    func lessThanFirst() -&gt; [Int] {
        guard let first = self.first else { return [] }
        return self.filter { $0 &lt; first }
    }
}

// 对协议进行限制
extension Collection where Element == Int {
    func lessThanFirst() -&gt; [Int] {
        guard let first = self.first else { return [] }
        return self.filter { $0 &lt; first }
    }
}
</code></pre></li>
</ul></li>
<li><p><strong>3、以扩展方式进行遵循实现协议</strong></p>

<ul>
<li><strong>a. 遵循实现协议时可以<code>在结构体、枚举、类定义处直接声明</code>，也可以<code>在扩展定义处声明</code>；</strong></li>
<li><strong>b. 其本质还是扩展，只不过扩展的内容是协议要求的；</strong></li>
<li><strong>c. 这种添加的<code>协议遵循者(Protocol Conformance）</code>的方式，称为<code>在扩展中添加协议遵循者</code>，特别适用于不能修改代码的时候；</strong></li>
<li><p><strong>d. 被扩展只能是结构体、枚举、类，不能是协议（因为要遵循实现协议）；</strong></p>

<pre><code class="language-swift">protocol TextRepresentable {
    func asText() -&gt; String
}
</code></pre>

<pre><code class="language-swift">// Dice类型的实例可以被当作TextRepresentable类型
extension Dice: TextRepresentable { 
    func asText() -&gt; String {
        return &quot;A \(sides)-sided dice&quot;
    }
}

let d12 = Dice(sides: 12,generator: LinearCongruentialGenerator())
println(d12.asText()) // A 12-sided dice
</code></pre></li>
</ul></li>
<li><p><strong>4、以扩展方式补充协议声明</strong></p>

<ul>
<li><strong>a. 当类型已经遵循实现了协议中的所有要求，但没有声明时，类型不会自动转变，需要以扩展方式来<code>明显补充协议声明</code>；</strong></li>
<li><p>b. 被扩展可以是结构体、枚举、类，不能是协议；</p>

<pre><code class="language-swift">struct Hamster {
    var name: String
    func asText() -&gt; String {
        return &quot;A hamster named \(name)&quot;
    }
}

extension Hamster: TextRepresentable {}
</code></pre></li>
</ul></li>
<li><p><strong>5、限定实现</strong></p>

<ul>
<li><strong>a. Swift 4.1开始，支持必须满足某些条件才能遵循实现，也就是<code>Conditional Conformance（一定条件下的实现）</code>语法；</strong></li>
<li><strong>b. 其本质还是扩展，只不过扩展的内容是满足某些条件下的，协议要求的；<code>限定扩展的内容是随意的，限定实现的内容是指定的；</code></strong></li>
<li><strong>c. Conditional Conformance还支持运行时检查Conformance；</strong></li>
<li><strong>d. 被扩展只能是<code>带泛型的结构体</code>、<code>带泛型的类</code>；</strong></li>
<li><p><strong>e. 某些条件为<code>限定泛型参数的类型</code>；</strong></p>

<pre><code class="language-swift">protocol EatProtocol {
    func eat()
}
protocol StudyProtocol {
    func study()
}
protocol PlayProtocol {
    func play()
}
</code></pre>

<pre><code class="language-swift">struct Teather: EatProtocol {
    func eat() {
        print(&quot;Teather eat&quot;)
    }
}

struct Student: EatProtocol, StudyProtocol {
    func eat() {
        print(&quot;Student eat&quot;)
    }

    func study() {
        print(&quot;Student study&quot;)
    }
}

struct PersonList&lt;E&gt; {
    let persons: [E]
}
</code></pre>

<pre><code class="language-swift">// 只有学习的人，才可以玩
extension PersonList: PlayProtocol where E: StudyProtocol {
    func play() {
        print(&quot;Play ...&quot;)
    }
}
</code></pre></li>
<li><p><strong>f. Swift 4.1开始，标准库中的泛型，增加了泛型参数的类型为<code>Equatable</code>、<code>Encodable</code>、<code>Decodable</code>的Conditional Conformance；</strong></p>

<pre><code class="language-swift">extension Array: Equatable where Element: Equatable { /* ... */ }
extension Array: Encodable where Element: Encodable { /* ... */ }
extension Array: Decodable where Element: Decodable { /* ... */ }
extension Dictionary: Equatable where Value: Equatable { /* ... */ }
...
</code></pre>

<pre><code class="language-swift">// 比如Array的泛型参数的类型为Element；
// 若让Array实现Equatable协议，必须有个条件就是Element类型实现Equatable协议；
// 因为若Element不支持相等比较，也没有办法写出Array支持相等比较的扩展；
extension Array: Equatable where Element: Equatable {
    static func == (lhs: Array&lt;Element&gt;,  rhs: Array&lt;Element&gt;) -&gt; Bool {
        return true
    }
}
</code></pre></li>
<li><p><strong>g. Swift 4.2开始，标准库中的泛型，增加了泛型参数的类型为<code>Hashable</code>的Conditional Conformance；</strong></p>

<pre><code class="language-swift">extension Array: Hashable where Element: Hashable { /* ... */ }
...
</code></pre></li>
<li><p><strong>h. Conditional Conformance语法的作用意义：</strong></p>

<ul>
<li><p><strong>a）Swift标准库中的泛型类添加了支持，重构了标准库中的相关代码；</strong></p>

<ul>
<li><p><strong>泛型的参数类型为<code>Equatable</code>、<code>Encodable</code>、<code>Decodable</code>、<code>Hashable</code>的泛型，其也是<code>Equatable</code>、<code>Encodable</code>、<code>Decodable</code>、<code>Hashable</code>的；</strong></p>

<pre><code class="language-swift">let arr = [1, 2, 3]

print(arr.hashValue)
// Swift 4.0 ❌，error: value of type &#39;[Int]&#39; has no member &#39;hashValue&#39;
// Swift 4.1 ❌，error: value of type &#39;[Int]&#39; has no member &#39;hashValue&#39;
// Swift 4.2 ✅，由于增加了泛型参数的类型为`Hashable`的Conditional Conformance，该[Int]才是Hashable的
</code></pre></li>
<li><p>如Array的 == 操作符实现，在Swift 4.0中定义为全局函数，在Swift 4.1中定义在扩展中；</p>

<pre><code class="language-swift">// Swift 4.0
@inlineable public func == &lt;Element : Equatable&gt;(lhs: Array&lt;Element&gt;, rhs: Array&lt;Element&gt;) -&gt; Bool
</code></pre>

<pre><code class="language-swift">// Swift 4.1
extension Array : Equatable where Element : Equatable {
    @inlinable public static func == (lhs: [Element], rhs: [Element]) -&gt; Bool
}
</code></pre></li>
</ul></li>
<li><p>b）更利于编译器合成；</p>

<pre><code class="language-swift">// 由于声明了Equatable且存储属性类型String、Int都是Equatable的；
// 根据“编译器合成规则”，则自动合成代码func ==(: Self, : Self) -&gt; Bool
struct BStudent: Equatable {
    var name: String
    var age: Int
}

// 若Swift标准库没有添加“对泛型参数的类型为`Equatable`的Conditional Conformance&quot;，
// 则[BStudent]不是Equatable的；
// 根据“编译器合成规则”，则无法自动合成代码func ==(: Self, : Self) -&gt; Bool
struct BClass: Equatable {
    var name: String
    var students: [BStudent]
}
</code></pre></li>
</ul></li>
</ul></li>
<li><p><strong>6、补充：泛型的类型约束（只能添加到泛型参量上）</strong></p>

<ul>
<li><p>语法形式有：</p>

<ul>
<li><p><strong>a. 继承类语法</strong></p>

<ul>
<li>继承类语法是约束语法的简化形式，直接把约束添加到类型参量的声明中；</li>
<li>适用于继承、遵循形式；</li>
</ul>

<pre><code class="language-swift">public struct Tuple&lt;A: Equatable, B: Equatable&gt;
</code></pre></li>
<li><p><strong>b. where语句语法</strong></p>

<ul>
<li>约束从主声明中剥离，增加了可读性；</li>
<li>也可以添加非继承、遵循形式的约束、复杂的约束；</li>
</ul>

<pre><code class="language-swift">public extension Thenable where T: Sequence, T.Iterator.Element: Comparable
public extension Request where Response == Void
associatedtype Iterator: IteratorProtocol where Iterator.Element == Item
</code></pre></li>
</ul></li>
</ul></li>
</ul>

<h4 id="toc_18">十一、编译器合成 (synthesize)</h4>

<ul>
<li><p><strong>编译器合成就是编译器自动合成相关代码；</strong></p>

<ul>
<li><strong>Swift 4.0开始，编译器支持自动合成Codable的相关函数；</strong></li>
<li><strong>Swift 4.1开始，编译器支持自动合成Equatable、Hashable的相关函数；</strong></li>
</ul></li>
<li><p><strong>对于Codable、Equatable、Hashable的自动合成，两个必要非充分条件（并不一定都能自动合成，自动合成失败需要手动实现）：所需要合成的类型<code>声明遵循上述协议</code>且<code>其所有存储属性遵循上述协议</code>；</strong></p>

<pre><code class="language-swift">// Swift 4.0编译✅（自动合成成功）
struct AStudent: Codable {
    var name: String
    var age: Int
}

// Swift 4.0编译✅（自动合成成功）
// 内置类型（如数组、字典、可选）包含Codable类型时，其也是Codable，故[AStudent]是Codable的；
// 注意：Swift 4.0中，[AStudent]是Codable的判断规则，不是Conditional Conformance，在Swift 4.1中才是；
struct AClass: Codable {
    var name: String
    var students: [AStudent]
}
</code></pre>

<pre><code class="language-swift">// Swift 4.1编译✅（自动合成成功）
struct BStudent: Equatable {
    var name: String
    var age: Int
}

// Swift 4.1编译✅（自动合成成功）
// Swift 4.1的Conditional Conformance支持Equatable，故[BStudent]是Equatable的；
struct BClass: Equatable {
    var name: String
    var students: [BStudent]
}
</code></pre>

<pre><code class="language-swift">// Swift 4.1编译✅（自动合成成功）
struct CStudent: Hashable {
    var name: String
    var age: Int
}

// Swift 4.1编译❌（自动合成失败），Swift 4.2编译✅（自动合成成功）
// Swift 4.2的Conditional Conformance才支持Hashable，故此时[CStudent]才是Hashable的；
struct CClass: Hashable {
    var name: String
    var students: [CStudent]
}
</code></pre></li>
<li><p><strong>不含有关联值枚举值的枚举类型，默认就是Equatable、Hashable，且无需声明类型；含有关联值枚举值的枚举类型，从Swift 4.1开始才支持自动合成，之前需要手动实现；</strong></p>

<pre><code class="language-swift">// 且无需声明类型，Equatable
enum BBB {
    case b1
    case b2
}
BBB.b1 == BBB.b1
</code></pre>

<pre><code class="language-swift">// Swift 4.0编译❌（自动合成失败），Swift 4.1编译✅（自动合成成功）
// 还需要声明类型
enum CCC: Equatable {
    case c1(String)
    case c2
}
CCC.c1(&quot;haha&quot;) == CCC.c1(&quot;haha&quot;)
CCC.c2 == CCC.c2
</code></pre></li>
<li><p><strong>必须手动声明是该类型（在扩展中声明也可以），类型才是该类型，否则不是；</strong></p>

<pre><code class="language-swift">struct AA {
    var name: String
    var age: Int
}
print(AA(name: &quot;tom&quot;, age: 1) is Codable) // false

struct BB: Codable {
    var name: String
    var age: Int
}
print(BB(name: &quot;tom&quot;, age: 1) is Codable) // true

struct CC {
    var name: String
    var age: Int
}
extension CC: Codable { }

print(CC(name: &quot;tom&quot;, age: 1) is Codable) // true
</code></pre></li>
</ul>

<h4 id="toc_19">十二、代理</h4>

<ul>
<li><p><strong>使用Delegate Protocol，分为4步：</strong></p>

<ul>
<li>1) 定义一个Delegate Protocol（只用于约束Delegate）；</li>
<li>2) 声明一个delegate Property；</li>
<li>3) 遵守并实现Delegate Protocol；</li>
<li>4) 调用delegate；</li>
</ul></li>
<li><p>为避免循环引用，在声明delegate Property时，需要使用weak修饰（可以让delegate Property不存在值时，自动设置为nil）；</p></li>
<li><p><strong>Swift的Protocol是可以被class、struct、enum使用的，但struct、enum并不通过ARC来管理内存，故导致无法使用weak修饰delegate Property；解决办法：<code>将Delegate Protocol限制为只能被class使用</code>；有以下方式：</strong></p>

<ul>
<li><p><strong>a. 通过class关键字（将Delegate Protocol限制为只能被class使用；建议使用）；</strong></p>

<pre><code class="language-swift">import UIKit

protocol DeleteAlertViewDelegate: class {
    func deleterAlertViewClickDeleteBtn(_ deleteAlertView: DeleteAlertView)
}

class DeleteAlertView: UIView {

    let deleteBtn: UIButton
    weak var delegate: DeleteAlertViewDelegate?

    override init(frame: CGRect) {
        deleteBtn = UIButton()
        super.init(frame: frame)

        self.backgroundColor = .gray

        self.addSubview(deleteBtn)
        deleteBtn.setTitle(&quot;DELETE&quot;, for: .normal)
        deleteBtn.backgroundColor = .orange
        deleteBtn.addTarget(self, action: #selector(clickDeleteBtn), for: .touchUpInside)
        deleteBtn.translatesAutoresizingMaskIntoConstraints = false
        deleteBtn.widthAnchor.constraint(equalToConstant: 100).isActive = true
        deleteBtn.heightAnchor.constraint(equalToConstant: 60).isActive = true
        deleteBtn.centerXAnchor.constraint(equalTo: self.centerXAnchor).isActive = true
        deleteBtn.centerYAnchor.constraint(equalTo: self.centerYAnchor).isActive = true
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }

    @objc func clickDeleteBtn() {
        print(#function)

        // 使用optional chaining，当delegate不为nil时，才调用方法
        delegate?.deleterAlertViewClickDeleteBtn(self)
    }
}
</code></pre>

<pre><code class="language-swift">import UIKit

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()

        let deleteAlertView = DeleteAlertView()
        self.view.addSubview(deleteAlertView)
        deleteAlertView.translatesAutoresizingMaskIntoConstraints = false
        deleteAlertView.widthAnchor.constraint(equalToConstant: 300).isActive = true
        deleteAlertView.heightAnchor.constraint(equalToConstant: 300).isActive = true
        deleteAlertView.centerXAnchor.constraint(equalTo: self.view.centerXAnchor).isActive = true
        deleteAlertView.centerYAnchor.constraint(equalTo: self.view.centerYAnchor).isActive = true

        deleteAlertView.delegate = self
    }
}

extension ViewController: DeleteAlertViewDelegate {
    func deleterAlertViewClickDeleteBtn(_ deleteAlertView: DeleteAlertView) {
        print(#function, deleteAlertView)
    }
}
</code></pre></li>
<li><p><strong>b. 通过@objc关键字；</strong></p>

<pre><code class="language-swift">@objc protocol DeleteAlertViewDelegate {
    func deleterAlertViewClickDeleteBtn(_ deleteAlertView: DeleteAlertView)
}
</code></pre></li>
<li><p><strong>c. 通过@NSObjectProtocol关键字；</strong></p>

<pre><code class="language-swift">protocol DeleteAlertViewDelegate: NSObjectProtocol {
    func deleterAlertViewClickDeleteBtn(_ deleteAlertView: DeleteAlertView)
}
</code></pre></li>
</ul></li>
<li><p><strong>Objective-C中可以有可选的协议方法；而Swift中的所有协议方法都是必须被实现，否则编译器会报错，但是可以通过间接方式来实现<code>可选协议方法</code>，有以下方式：</strong></p>

<ul>
<li><p><strong>a. 通过协议扩展（利用协议扩展，实现可选协议方法的默认实现，class、struct、enum均可使用）；</strong></p>

<pre><code class="language-swift">// 这里是Delegate Protocol，所以使用class修饰了一下
protocol DeleteAlertViewDelegate: class {
    func deleterAlertViewClickDeleteBtn(_ deleteAlertView: DeleteAlertView)
    func optionalMethod()
}

extension DeleteAlertViewDelegate {
    func optionalMethod() {
        print(#function)
    }
}
</code></pre>

<pre><code class="language-swift">// 调用可选的协议方法（方法后面不需要有?，因为实际上已经被实现了）
delegate?.optionalMethod()
</code></pre></li>
<li><p><strong>b. 通过@objc和optional关键字（协议前加@objc，可选方法或属性前加@objc和optional）；</strong></p>

<pre><code class="language-swift">@objc protocol DeleteAlertViewDelegate {
    func deleterAlertViewClickDeleteBtn(_ deleteAlertView: DeleteAlertView)
    @objc optional func optionalMethod()
}
</code></pre>

<pre><code class="language-swift">// 调用可选的协议方法（注意方法后面的?）
delegate?.optionalMethod?()
</code></pre></li>
<li><p><strong>c. 通过NSObjectProtocol和optional关键字（Cocoa框架的实现方式；该方式外界不可用）；</strong></p>

<pre><code class="language-swift">public protocol UIScrollViewDelegate : NSObjectProtocol {
    optional func scrollViewDidScroll(_ scrollView: UIScrollView)
    // ...
}
</code></pre></li>
</ul></li>
</ul>

<h4 id="toc_20">十三、KVO、KVC</h4>

<ul>
<li><p><strong>1、KVO</strong></p>

<ul>
<li>KVO基于ObjC的动态派发、KVC，这些都是依赖于ObjC的运行时（runtime）；</li>
<li><p>在Swift中，默认是禁用了动态派发，Swift若需要实现KVO，就需要一些额外的操作；</p>

<ul>
<li><strong>1) class类型需要继承NSObject；</strong></li>
<li><strong>2) 属性前加上@objc dynamic（Swift 3中只需要加上dynamic即可）；</strong></li>
</ul>

<pre><code class="language-swift">class Person: NSObject {
    @objc dynamic var age = 0
}
</code></pre>

<pre><code class="language-swift">class ViewController: UIViewController {

    var person: Person!

    override func viewDidLoad() {
        super.viewDidLoad()

        person = Person()
        person.addObserver(self, forKeyPath: &quot;age&quot;, options: [.new, .old], context: nil)
    }

    deinit {
        person.removeObserver(self, forKeyPath: &quot;age&quot;)
    }

    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if keyPath == &quot;age&quot; {
            print(&quot;age changed: \(change as Any)&quot;)
        }
    }

    override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {
        person.age = 10
    }
}
</code></pre></li>
<li><p><strong>Swift 4.0新增一个便捷添加observer的方法，之后不需要再手动移除observer，但需要手动持有化，添加observer之后返回的NSKeyValueObservation实例；</strong></p>

<pre><code>var person2: Person!
var observer: NSKeyValueObservation!

override func viewDidLoad() {
    super.viewDidLoad()

    person2 = Person()
    observer = person2.observe(\.age) { (object, changed) in
        print(&quot;changed: \(changed), \(object.age)&quot;)
    }
}
</code></pre></li>
</ul></li>
<li><p><strong>2、KVC</strong></p></li>
</ul>

<h4 id="toc_21">十四、常见错误</h4>

<ul>
<li><p>1、&quot;Cannot use instance member &#39;XXX&#39; within property initializer; property initializers run before &#39;self&#39;s available&quot;</p>

<pre><code class="language-swift">class LoginViewController: UIViewController {
    var customerKey = &quot;xxx&quot;
    var server = &quot;https://api.test.io/&quot;
    var api = API.init(hostUrl: server, customerKey: customerKey)

    override func viewDidLoad() {
        super.viewDidLoad()

    }
}
</code></pre>

<ul>
<li><p>You cannot use an instance of your view controller and properties until the initialization, so you just need to <code>move your API initialization to viewDidLoad</code>:</p>

<pre><code class="language-swift">var api: API!
override func viewDidLoad() {
    super.viewDidLoad()
    api = API(hostUrl: server, customerId: customerId, customerKey: customerKey)
}
</code></pre></li>
<li><p>Another option is using <code>all hardcoded values</code>：</p>

<pre><code class="language-swift">API.init(hostUrl: &quot;https://api.test.io/&quot;,  customerKey: &quot;xxx&quot;)
</code></pre></li>
<li><p>Or using <code>a computed property</code>, or <code>a lazy variable</code>;</p></li>
<li><p>参考：</p>

<ul>
<li><code>https://stackoverflow.com/questions/44648388/cannot-use-instance-member-server-within-property-initializer</code></li>
<li><code>https://stackoverflow.com/questions/43768348/property-initializers-run-before-self-is-available-error-swift</code></li>
</ul></li>
</ul></li>
</ul>

      </div>

      <div class="row">
        <div class="large-6 columns">
          <p class="text-left" style="padding:15px 0px;">
            
            <a href="15285683833705.html" title="Previous Post: 错误、异常的处理（Java、ObjC、Swift）">&laquo; 错误、异常的处理（Java、ObjC、Swift）</a>
            
          </p>
        </div>
        <div class="large-6 columns">
          <p class="text-right" style="padding:15px 0px;">
            
            <a href="15247648225940.html" title="Next Post: Android编程权威指南 笔记(25~31)">Android编程权威指南 笔记(25~31) &raquo;</a>
            
          </p>
        </div>
      </div>

      <div class="comments-wrap">
        <div class="share-comments">
            
        </div>
      </div>

    </div>
  </div> <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">

      <div id="site-info" class="site-info">
        
        <h1>TIME TO GO</h1>
        <div class="site-des">It is just a matter of time.</div>
        <div class="social">
                    
          <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
        </div>
      </div>

      

      <div id="site-categories" class="side-item ">
        <div class="side-header">
          <h2>Categories</h2>
        </div>
        <div class="side-content">
          <p class="cat-list">
            
          </p>
        </div>
      </div>

      <div id="site-categories" class="side-item">
        <div class="side-header">
          <h2>Recent Posts</h2>
        </div>
        <div class="side-content">
          <ul class="posts-list">
              <li class="post">
              <a href="15626010144789.html">iOS状态栏</a>
              </li>
                 <li class="post">
              <a href="15622540495294.html">iOS屏幕旋转</a>
              </li>
                 <li class="post">
              <a href="15590636648081.html">OpenCV配置使用</a>
              </li>
                 <li class="post">
              <a href="15590617242967.html">Sublime配置使用</a>
              </li>
                 <li class="post">
              <a href="15580276420967.html">iOS照片框架</a>
              </li>
                                             
          </ul>
        </div>
      </div>

    </div>
  </div>
</div>

</div> <div class="page-bottom clearfix">
  <div class="row">
    <p class="copyright">Copyright &copy; 2015 Powered by
      <a target="_blank" href="">ME</a>
    </p>
  </div>
</div>
</section>

</div>
</div>

 
<script src="asset/js/foundation.min.js"></script>
<script>
  $(document).foundation();
  function fixSidebarHeight() {
    var w1 = $('.markdown-body').height();
    var w2 = $('#sidebar').height();
    if (w1 > w2) { $('#sidebar').height(w1); };
  }
  $(function () {
    fixSidebarHeight();
  })
  $(window).load(function () {
    fixSidebarHeight();
  });
</script>   
</body>

</html>