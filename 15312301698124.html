<!doctype html>
<html class="no-js" lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>
     Swift知识点总结 - TIME TO GO 
  </title>
   
  <link href="atom.xml" rel="alternate" title="TIME TO GO" type="application/atom+xml">
  <link rel="stylesheet" href="asset/css/foundation.min.css" />
  <link rel="stylesheet" href="asset/css/docs.css" />
  <script src="asset/js/vendor/modernizr.js"></script>
  <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
  <script type="text/javascript">
    function before_search() {
      var searchVal = 'site: ' + document.getElementById('search_input').value;
      document.getElementById('search_q').value = searchVal;
      return true;
    }
  </script>
</head>

<body class="antialiased hide-extras">
  <div class="marketing off-canvas-wrap" data-offcanvas>
    <div class="inner-wrap">


      <nav class="top-bar docs-bar hide-for-small" data-topbar>
        <section class="top-bar-section">
          <div class="row">
            <div style="position: relative;width:100%;">
              <div style="position: absolute; width:100%;">
                <ul id="main-menu" class="left">
                  
                  <li id="">
                    <a target="self" href="index.html">Home</a>
                  </li>
                  
                  <li id="">
                    <a target="_self" href="archives.html">Archives</a>
                  </li>
                  
                </ul>
                <ul class="right" id="search-wrap">
                  <li>
                    <form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
                      <input type="hidden" id="search_q" name="q" value="" />
                      <input tabindex="1" type="search" id="search_input" placeholder="Search" />
                    </form>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </section>
      </nav>

      <nav class="tab-bar show-for-small">
        <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
          <span> &nbsp; TIME TO GO</span>
        </a>
      </nav>

      <aside class="left-off-canvas-menu">
        <ul class="off-canvas-list">
          <li>
            <a href="index.html">HOME</a>
          </li>
          <li>
            <a href="archives.html">Archives</a>
          </li>
          <li>
            <a href="about.html">ABOUT</a>
          </li>
          <li>
            <label>Categories</label>
          </li>
          
        </ul>
      </aside>
      <a class="exit-off-canvas" href="#"></a>
      <section id="main-content" role="main" class="scroll-container"> <script type="text/javascript">
  $(function () {
    $('#menu_item_index').addClass('is_active');
    $('#sidebar').parent().parent().hide();
  });
</script>

<div class="row">
  <div class="large-12 medium-12 columns">
    <div class="markdown-body article-wrap">

      <div class="article">
        
        <h1>Swift知识点总结</h1>
        <div class="read-more clearfix">
          <span class="date">2018/5/10</span>
           
          <span class="comments">
             
          </span>
        </div>
      </div>

      <div class="article-content">
        <ul>
<li>
<a href="#toc_0">一、@objc</a>
</li>
<li>
<a href="#toc_1">二、#selector</a>
<ul>
<li>
<a href="#toc_2">（一）定义的格式</a>
</li>
<li>
<a href="#toc_3">（二）方法定义的规定</a>
</li>
<li>
<a href="#toc_4">（三）self问题</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">三、懒加载</a>
<ul>
<li>
<a href="#toc_6">（一）懒加载情景</a>
</li>
<li>
<a href="#toc_7">（二）延迟属性与闭包</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">四、dispatch_once</a>
</li>
<li>
<a href="#toc_9">五、单例模式</a>
</li>
<li>
<a href="#toc_10">六、Equatable、Hashable协议</a>
<ul>
<li>
<a href="#toc_11">（一）Objective-C的=== 、==、isEqual:、isEqualToString:、hash</a>
</li>
<li>
<a href="#toc_12">（二）swift的=== 、==、Equatable、Hashable</a>
</li>
</ul>
</li>
<li>
<a href="#toc_13">七、NSString、String编码</a>
<ul>
<li>
<a href="#toc_14">（一）NSString</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">八、Swift构造器</a>
</li>
</ul>


<h4 id="toc_0">一、@objc</h4>

<ul>
<li><p>作用：将用Swift写的API暴露给ObjC使用，需要增加@objc关键字；</p></li>
<li><p><strong>1、Swift 3.0</strong></p>

<ul>
<li><p>a. 编译器默认给继承于NSObject的类的所有方法都隐式添加@objc；缺点是大量@objc导致二进制文件增大；</p>

<pre><code class="language-swift">class MyClass: NSObject {
    func print() { } // 包含隐式的 @objc
}
</code></pre></li>
</ul>

<span id="more"></span><!-- more --></li>
<li><p><strong>2、Swift 4.0</strong></p>

<ul>
<li><strong>a. 隐式添加@objc只存在以下场景：覆盖父类的ObjC方法、符合一个ObjC的协议；</strong></li>
<li><p>b. 显式给方法添加@objc；</p>

<pre><code>class MyClass: NSObject {
    @objc func print() { } // 显示加上 @objc
}
</code></pre></li>
<li><p>c. 若类名前加@objcMembers，则其及其扩展、子类的所有方法都隐式添加@objc；</p>

<pre><code class="language-swift">@objcMembers class MyClass: NSObject {
    func print() { } // 包含隐式的 @objc
}

extension MyClass {
    func a() { } // 包含隐式的 @objc
}
</code></pre></li>
<li><p>d. 若扩展名前加@objc，则该扩展的所有方法都隐式添加@objc；</p>

<pre><code class="language-swift">class MyClass { }

@objc extension MyClass {
    func a() { } // 包含隐式的 @objc
}
</code></pre></li>
<li><p>e. 若扩展名前加@noobjc，则该扩展的所有方法都不会隐式添加@objc（排除类名前加@objcMembers的影响）；</p>

<pre><code class="language-swift">@objcMembers class MyClass : NSObject {
    func print() { } // 包含隐式的 @objc
}

@nonobjc extension MyClass {
    func a() { } // 不会包含隐式的 @objc
}
</code></pre></li>
<li><p><strong>设置Xcode的<code>Build Settings</code>中的<code>Swift 3 @objc Inference</code>，决定是否继续采用Swift 3.0隐式添加@objc的模式；</strong></p></li>
</ul></li>
</ul>

<h4 id="toc_1">二、#selector</h4>

<h5 id="toc_2">（一）定义的格式</h5>

<ul>
<li><p><strong>1、Swift 2.2前</strong></p>

<pre><code class="language-swift">// 无参数
Selector(&quot;btnDidClick&quot;)
// 有参数
Selector(&quot;btnDidClick:&quot;)
</code></pre></li>
<li><p><strong>2、Swift 2.2</strong></p>

<pre><code class="language-swift">// 无参数
#selector(btnDidClick)
// 有参数，参数名称使用下划线；具体方法的参数名称可任意设置
#selector(btnDidClick(_:))
</code></pre></li>
<li><p><strong>3、Swift 3.0</strong></p>

<pre><code class="language-swift">// 无参数
#selector(btnDidClick)
// 有参数，参数名称必须具体给出；具体方法的参数名称必须一致
#selector(btnDidClick(btn:))
</code></pre></li>
</ul>

<h5 id="toc_3">（二）方法定义的规定</h5>

<ul>
<li><p><strong>#selector使用到了ObjC运行时，所以方法必须要能被ObjC访问才行（加@objc修饰符）；</strong></p></li>
<li><p><strong>1、Swift 3.0</strong></p>

<ul>
<li><strong>只有当方法的权限为<code>private</code>，才需要加@objc修饰符，否则不需要添加；</strong></li>
</ul></li>
<li><p><strong>2、Swift 4.0</strong></p>

<ul>
<li>所有的方法都要加@objc修饰符，不论其权限是否为private；</li>
</ul></li>
</ul>

<h5 id="toc_4">（三）self问题</h5>

<ul>
<li><p><strong><code>btn.addTarget(self, action: #selector()...</code>中的self是动态的；比如在A中初始化了B，B中的btn初始化时进行了<code>addTarget(self...</code>，则此时self为A而不是B；</strong></p></li>
<li><p><strong>解决上述问题的方式有两种：一种是不在A中初始化B，一种是写成<code>btn.addTarget(B.self, action: #selector()...</code></strong>；</p></li>
</ul>

<h4 id="toc_5">三、懒加载</h4>

<h5 id="toc_6">（一）懒加载情景</h5>

<ul>
<li><strong>全局的常/变量都是懒加载的，不需要标记lazy；</strong></li>
<li><strong>标记为<code>static</code>的常/变量存储属性（类属性）也都是懒加载的，不需要标记lazy；（补充：class只能修饰计算属性，而计算属性只能使用var修饰）</strong></li>
<li><strong>延迟属性，必须使用<code>lazy var</code>标记；（延迟属性只能使用var修饰，不能使用let修饰）</strong></li>
</ul>

<h5 id="toc_7">（二）延迟属性与闭包</h5>

<ul>
<li><p><strong>延迟属性使用<code>lazy var</code>标记声明，其初始值可以是直接创建，也可以使用闭包创建；</strong></p>

<pre><code class="language-swift">// 直接创建
lazy var person1: Person = Person()

// 闭包创建
lazy var person2: Person = {
    let person = Person()
    p.name = &quot;Tom&quot;
    print(&quot;Tom...&quot;)
    return person
}()
</code></pre></li>
<li><p><strong>使用闭包不仅仅可以给延迟属性（lazy var）设置初始值，也可以给全局的常/变量、类的属性、对象的属性进行初始值，计算属性本质通过闭包实现的；</strong></p>

<pre><code class="language-swift">let i = {
    return 0
}()

class Person {
    static let a = {
        return 1
    }()
    var b = {
        return 2
    }()
}
</code></pre></li>
<li><p>在布局UI控件的时候也可以使用闭包来完成初始化赋值，这样更便于复用、更简洁；</p>

<pre><code class="language-swift">let leftButton: UIButton = {
    let button = UIButton(frame: buttonSize)
    button.backgroundColor = .black
    button.titleLabel?.text = &quot;left&quot;
    return button
}()

let rightButton: UIButton = {
    let button = UIButton(frame: buttonSize)
    button.backgroundColor = .black
    button.titleLabel?.text = &quot;right&quot;
    return button
}()
</code></pre></li>
<li><p><strong>延迟属性使用闭包创建，在闭包中使用self不会产生循环引用；全局的常/变量、类的属性、对象的属性使用闭包创建，无在闭包中使用self；</strong></p></li>
</ul>

<h4 id="toc_8">四、dispatch_once</h4>

<ul>
<li><p>Swift 3.0废弃了dispatch_once，但是<strong>全局的常/变量</strong>和<strong>标记为<code>static</code>的常/变量存储属性</strong>底层实现都是使用dispatch_once机制且线程安全的，它们都是只会执行一次；延迟属性是对象属性，会被执行多次；</p></li>
<li><p>也可以通过手动给DispatchQueue扩展一个方法实现dispatch_once的功能；<code>objc_sync_enter、objc_sync_exit</code>等价于OC中的<code>@synchronized(TOKEN) { }</code>；</p>

<pre><code class="language-swift">public extension DispatchQueue {
    private static var _onceTracker = [String]()

    public static func once(token: String, block: ()-&gt;Void) {
        objc_sync_enter(self)
        defer {
            objc_sync_exit(self)
        }

        if _onceTracker.contains(token) {
            return
        }
        _onceTracker.append(token)
        block()
    }

    public static func once(block: ()-&gt;Void) {
        let token = #file + &quot;:&quot; + #function + &quot;:&quot; + String(#line)
        self.once(token: token, block: block)
    }
}
</code></pre>

<pre><code class="language-swift">// usage1
private let _onceToken = UUID().uuidString

print(_onceToken)
DispatchQueue.once(token: _onceToken) {
    // TODO
}

// usage2
DispatchQueue.once {
    // TODO
}
</code></pre></li>
</ul>

<h4 id="toc_9">五、单例模式</h4>

<ul>
<li><p><strong>1、 Swift 1.2之前</strong></p>

<ul>
<li><p><strong>类不支持存储型类型属性（let、var），结构体支持；</strong></p>

<pre><code class="language-swift">// OC移植版
class MyManager {
    // 类型计算属性，相当于类方法（可访问类型属性、或全局量）
    class var sharedManager : MyManager {
        // 嵌套定义结构体：借助该结构体存储该单例对象
        struct Static {
            static var onceToken : dispatch_once_t = 0
            static var staticInstance : MyManager? = nil
        }

        dispatch_once(&amp;Static.onceToken) {
            Static.staticInstance = MyManager()
        }

        return Static.staticInstance!
    }
}
</code></pre>

<pre><code class="language-swift">// 简化版：不使用dispatch_once
class MyManager {
    class var sharedManager : MyManager {
        // 嵌套定义结构体：借助该结构体存储该单例对象
        struct Static {
            static let sharedInstance : MyManager = MyManager()
        }

        return Static.sharedInstance
    }
}
</code></pre>

<pre><code>// 优化版：使用 私有的全局量 存储单例对象
private let sharedInstance = MyManager()

class MyManager  {
    class var sharedManager : MyManager {
        return sharedInstance
    }
}
</code></pre></li>
</ul></li>
<li><p><strong>2、Swift 1.2开始</strong></p>

<ul>
<li><p><strong>类开始支持存储型类型属性（let、var）；</strong></p>

<pre><code>class MyManager {
    private static let sharedInstance : MyManager = MyManager()
    class var sharedManager : MyManager {
        return sharedInstance
    }
    private init() {}
}
</code></pre>

<pre><code>// 最终版
class MyManager  {
    static let sharedInstance = MyManager()
    private init() {}
}
</code></pre></li>
</ul></li>
<li><p><strong>3、补充（ObjC单例）</strong></p>

<pre><code class="language-ObjC">@interface MyManager : NSObject

+ (instancetype)sharedManager;

@end
</code></pre>

<pre><code class="language-ObjC">/**
 *  饿汉式，类被加载时就创建唯一实例
 */
@implementation MyManager

// 标示唯一的实例，该static全局变量的作用域仅限于当前文件内部
static id _instance;

// 当类被加载到OC运行时环境（内存）时调用（一个类只会被加载1次）
+ (void)load {
    NSLog(@&quot;load...&quot;);
    // 创建该类的唯一实例（因为在load这里就使用了类，故initialize也被调用）
    _instance = [[self alloc] init]; 
}

// 当第一次使用该类的时候调用
+ (void)initialize {
    NSLog(@&quot;initialize...&quot;);
}

// alloc方法的内部会调用该方法
+ (id)allocWithZone:(struct _NSZone *)zone {
    if (_instance == nil) { // 防止多次创建
        _instance = [super allocWithZone:zone];
    }
    return _instance;
}

// copy方法的内部会调用该方法（由于是对象方法，对象已存在，不需要判断直接返回对象）
- (id)copyWithZone:(NSZone *)zone {
    return _instance;
}

+ (instancetype)sharedManager {
    return _instance; // 直接返回已创建的实例
}

@end
</code></pre>

<pre><code class="language-ObjC">/**
 *  懒汉式，使用时再创建唯一实例
 */
@implementation MyManager

static id _instance;

+ (id)allocWithZone:(struct _NSZone *)zone {
    if (_instance == nil) { // 防止频繁加锁
        @synchronized(self) {
            if (_instance == nil) { // 防止多次创建
                _instance = [super allocWithZone:zone];
            }
        }
    }
    // GCD
    // static dispatch_once_t onceToken;
    // dispatch_once(&amp;onceToken, ^{
    //     _instace = [super allocWithZone:zone];
    // });
    return _instance;
}

- (id)copyWithZone:(NSZone *)zone {
    return _instance;
}

+ (instancetype)sharedManager {
    if (_instance == nil) { // 防止频繁加锁
        @synchronized(self) {
            if (_instance == nil) { // 防止多次创建
                _instance = [[self alloc] init];
            }
        }
    }
    // GCD
    // static dispatch_once_t onceToken;
    // dispatch_once(&amp;onceToken, ^{
    //     _instace = [super allocWithZone:zone];
    // });
    return _instance;
}

@end
</code></pre>

<pre><code class="language-ObjC">// MRC情况下还需要实现以下方法
- (oneway void)release {}
- (id)autorelease { return self; }
- (id)retain { return self; }
- (NSUInteger)retainCount { return 1; }
</code></pre></li>
</ul>

<h4 id="toc_10">六、Equatable、Hashable协议</h4>

<h5 id="toc_11">（一）Objective-C的=== 、==、isEqual:、isEqualToString:、hash</h5>

<ul>
<li><p>1、==操作符</p>

<ul>
<li>对于对象类型，判断连个两个对象的内存地址是否相同，相同返回true，否则返回false；</li>
</ul></li>
<li><p>2、isEqual:方法</p>

<ul>
<li><strong>默认情况下，比较两个对象的内存地址是否相同；</strong></li>
<li>系统自带的某些类型（如Foundation中的NSString、NSArray等）会重写该方法，改变默认的判断规则（不比较地址，而是比较两个对象的内容）；</li>
<li><strong>对于我们自定义类型的对象，若有判等需求，需要重写该方法；</strong></li>
<li>重写的建议规则：

<ul>
<li>a. 判断传入的对象是否是nil，若是直接返回NO；</li>
<li>b. ==运算符判断是否是同一对象，若相同直接返回YES；</li>
<li>c. 判断是否是同一类型，若不同直接返回NO；</li>
<li>d. 根据场景使用相应的属性进行判等操作，返回最终的操作结果；</li>
</ul></li>
</ul></li>
<li><p>3、isEqualToString:方法</p>

<ul>
<li>NSString的特有方法，只比较字符串本身的内容是否一致，不比较内存地址；</li>
<li>类似的还有isEqualToArray、isEqualToDictionary等；</li>
</ul></li>
<li><p><strong>4、hash方法</strong></p>

<ul>
<li><strong>返回当前对象的hash值，默认值为当前对象的内存地址（<code>p (NSUInteger)self</code>）；</strong></li>
<li><strong>作用：为了加快数据的查找速度；</strong>

<ul>
<li><strong>a. 原始的遍历查询的速度为O(n)，使用基于hash值的Hash Table数据结构的查询速度为O(1)；</strong></li>
<li><strong>b. 一般情况下，不同对象的hash值是不一样；但是某些情况下却是一样的，这时候就出现“hash碰撞”了；故hash值是对象判等的必要非充分条件；</strong></li>
</ul></li>
<li><strong>在对象被添加到NSSet、设置为NSDictionary的key等涉及到Hash Table数据结构时，hash方法会被调用；</strong></li>
<li><strong>重写的建议规则：对相关属性的hash值作XOR运算，如<code>return [_name hash] ^ [_age hash];</code></strong></li>
</ul></li>
<li><p><strong>5、hash方法 与 isEqual:方法的关系</strong></p>

<ul>
<li><strong>由于hash的可以加快查找速度，但可能出现“hash碰撞”，故在应用时，先调用hash方法根据hash值快速排除不相等的数据，之后若hash值相同再调用isEqual:方法，作最终的判等操作；这样既加快了速度又不失准确性；</strong><br/></li>
</ul></li>
<li><p><strong>6、自定义类型的对象重写isEqual:方法、hash方法</strong></p>

<ul>
<li><strong>若不涉及到Hash Table数据结构的判等操作，只重写isEqual:方法即可；</strong></li>
<li><strong>若涉及到Hash Table数据结构的判等操作，重写hash方法后，也大概率必须重写isEqual:方法；</strong>

<ul>
<li><strong>原因：重写hash方法大概率是因为两个对象的内存地址不同，就是本质上为不同的对象；若只重写了hash方法，两个对象的hash值相等后，还要调用isEqual:方法进行判等，而isEqual:方法的默认行为就是比较内存地址是否相同；</strong></li>
<li><strong>hash方法是加快判等速度，并不能决定判等结果；</strong></li>
</ul></li>
</ul></li>
</ul>

<h5 id="toc_12">（二）swift的=== 、==、Equatable、Hashable</h5>

<ul>
<li><p>1、===操作符</p>

<ul>
<li>swift中的=== 操作符等价于OC中的==操作符，比较的是对象的内存地址；</li>
</ul></li>
<li><p>2、==操作符</p>

<ul>
<li>swift中没有isEqual:方法；</li>
</ul></li>
</ul>

<h4 id="toc_13">七、NSString、String编码</h4>

<h5 id="toc_14">（一）NSString</h5>

<ul>
<li><strong>NSString是建立在Unicode之上的，但是NSString在开发的时候（1994年），Unicode还是16位的，之后Unicode才扩展到21位；</strong></li>
<li><strong>所以，NSString对象代表的是用UTF-16编码的码元组成的数组；相应地，length方法的返回值也是字符串包含的码元个数（而不是字符个数）</strong>；</li>
<li><code>[NSString length]</code>返回返回值与实际（可见）字符数不符，有以下场景：

<ul>
<li><strong>a. 基本多文种平面外的字符</strong>：BMP里所有的字符在UTF-16里都可以用一个码元表示，其余的字符都需要两个码元（一个代理对），如emoji字符；</li>
<li><strong>b. 组合字符序列</strong>：字母é是以分解形式（e + ´）编码（默认），算作两个码元；某些字母，也可以调用precomposedStringWithCanonicalMapping方法，以合成形式编码；</li>
<li><strong>c. 变体序列</strong>：它们和分解形式的组合字符序列的工作方式一样，因此变体选择符也算作单独的字符；</li>
</ul></li>
<li>参考：<code>https://objccn.io/issue-9-1/</code></li>
</ul>

<h4 id="toc_15">八、Swift构造器</h4>

<ul>
<li><p><strong>1、默认构造器</strong></p>

<ul>
<li><strong>a. Swift将为<code>已提供了所有的存储型属性有默认值的</code>且<code>自身没有定义任何构造器</code>的<code>结构体</code>或<code>基类</code>，提供一个默认构造器</strong>；</li>
<li><strong>b. 可选类型属性若没有显式设置默认值，则有隐式默认值nil；</strong></li>
<li>c. 该默认构造器无任何参数的，调用其可以创建一个所有属性值都设置为默认值的实例；</li>
</ul></li>
<li><p><strong>2、结构体的逐一成员构造器</strong></p>

<ul>
<li>a. Swift还将为<code>已提供了所有的存储型属性有默认值的</code>且<code>自身没有定义任何构造器</code>的<code>结构体</code>，提供一个逐一成员构造器；</li>
<li>b. 可选类型属性若没有显式设置默认值，则有隐式默认值nil；</li>
<li>c. 该逐一成员构造器的参数名称与成员属性名相同，调用其可以进行传值来完成对成员属性的初始赋值；</li>
</ul></li>
<li><p><strong>3、自定义构造器</strong></p>

<ul>
<li>a. 若自定义任何构造器，则Swift不会提供<code>默认构造器</code>、<code>逐一成员构造器</code>；</li>
<li><strong>b. 在自定义任何构造器中，必须初始化<code>所有没有默认值的存储型属性</code>；</strong></li>
<li><strong>c. 技巧：给自定义构造器的参数添加<code>默认参数值</code>，这样也可以在调用时不传递构造参数，相对于又提供了<code>一个隐式的默认构造器</code>；</strong></li>
</ul></li>
<li><p><strong>4、指定构造器、便利构造器</strong></p>

<ul>
<li>Swift的类类型的构造器有两种类型：指定构造器(Designated Initializer)、便利构造器(Convenience Initializer)；</li>
</ul></li>
<li><p><strong>5、构造器的继承</strong></p>

<ul>
<li><strong>子类默认不会继承父类的构造器；但是若满足某些条件，父类的构造器还是可以继承给子类，这意味着不必复写父类的构造器；</strong></li>
<li><strong>首先必须<code>子类新增的存储属性</code>都提供了<code>默认值</code>，那么则</strong>：

<ul>
<li><strong>a. 若子类中没有新增任何自定义的指定构造器（新增便利构造器可有可无），那么子类会自动继承父类的所有指定构造器；</strong></li>
<li><strong>b. 若子类提供了所有父类的指定构造器的实现（无论是通过继承来的，还是自定义实现的），（新增便利构造器可有可无），那么子类自动继承所有父类的便利构造器；</strong>

<ul>
<li><strong>注：子类自定义实现的父类的指定构造器时，可以重写，也可以将其实现为便利构造器；</strong></li>
</ul></li>
</ul></li>
</ul></li>
<li><p><strong>6、构造器的重写、覆盖</strong></p>

<ul>
<li><strong>a. 父类的指定构造器可以被<code>子类重写</code>成指定构造器（必须添加override）、便利构造器（不必添加override）；</strong></li>
<li><strong>b. 父类的便利构造器可以被<code>子类覆盖</code>为指定构造器、便利构造器，不必添加override；</strong></li>
</ul></li>
</ul>

      </div>

      <div class="row">
        <div class="large-6 columns">
          <p class="text-left" style="padding:15px 0px;">
            
            <a href="15285683833705.html" title="Previous Post: 错误、异常的处理（Java、ObjC、Swift）">&laquo; 错误、异常的处理（Java、ObjC、Swift）</a>
            
          </p>
        </div>
        <div class="large-6 columns">
          <p class="text-right" style="padding:15px 0px;">
            
            <a href="15247648225940.html" title="Next Post: Android编程权威指南 笔记(25~31)">Android编程权威指南 笔记(25~31) &raquo;</a>
            
          </p>
        </div>
      </div>

      <div class="comments-wrap">
        <div class="share-comments">
            
        </div>
      </div>

    </div>
  </div> <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">

      <div id="site-info" class="site-info">
        
        <h1>TIME TO GO</h1>
        <div class="site-des">It is just a matter of time.</div>
        <div class="social">
                    
          <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
        </div>
      </div>

      

      <div id="site-categories" class="side-item ">
        <div class="side-header">
          <h2>Categories</h2>
        </div>
        <div class="side-content">
          <p class="cat-list">
            
          </p>
        </div>
      </div>

      <div id="site-categories" class="side-item">
        <div class="side-header">
          <h2>Recent Posts</h2>
        </div>
        <div class="side-content">
          <ul class="posts-list">
              <li class="post">
              <a href="15503038236595.html">NCE2 Unit 03（Lesson65 ~ 72）</a>
              </li>
                 <li class="post">
              <a href="15450672099321.html">NCE2 Unit 03（Lesson57 ~ 64）</a>
              </li>
                 <li class="post">
              <a href="15428122799005.html">NCE2 Unit 03（Lesson49 ~ 56）</a>
              </li>
                 <li class="post">
              <a href="15416904024187.html">NCE2 Unit 02（Lesson41 ~ 48）</a>
              </li>
                 <li class="post">
              <a href="15410846265758.html">NCE2 Unit 02（Lesson33 ~ 40）</a>
              </li>
                                             
          </ul>
        </div>
      </div>

    </div>
  </div>
</div>

</div> <div class="page-bottom clearfix">
  <div class="row">
    <p class="copyright">Copyright &copy; 2015 Powered by
      <a target="_blank" href="">ME</a>
    </p>
  </div>
</div>
</section>

</div>
</div>

 
<script src="asset/js/foundation.min.js"></script>
<script>
  $(document).foundation();
  function fixSidebarHeight() {
    var w1 = $('.markdown-body').height();
    var w2 = $('#sidebar').height();
    if (w1 > w2) { $('#sidebar').height(w1); };
  }
  $(function () {
    fixSidebarHeight();
  })
  $(window).load(function () {
    fixSidebarHeight();
  });
</script>   
</body>

</html>