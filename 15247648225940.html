<!doctype html>
<html class="no-js" lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>
     Android编程权威指南 笔记(25~31) - TIME TO GO 
  </title>
   
  <link href="atom.xml" rel="alternate" title="TIME TO GO" type="application/atom+xml">
  <link rel="stylesheet" href="asset/css/foundation.min.css" />
  <link rel="stylesheet" href="asset/css/docs.css" />
  <script src="asset/js/vendor/modernizr.js"></script>
  <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
  <script type="text/javascript">
    function before_search() {
      var searchVal = 'site: ' + document.getElementById('search_input').value;
      document.getElementById('search_q').value = searchVal;
      return true;
    }
  </script>
</head>

<body class="antialiased hide-extras">
  <div class="marketing off-canvas-wrap" data-offcanvas>
    <div class="inner-wrap">


      <nav class="top-bar docs-bar hide-for-small" data-topbar>
        <section class="top-bar-section">
          <div class="row">
            <div style="position: relative;width:100%;">
              <div style="position: absolute; width:100%;">
                <ul id="main-menu" class="left">
                  
                  <li id="">
                    <a target="self" href="index.html">Home</a>
                  </li>
                  
                  <li id="">
                    <a target="_self" href="archives.html">Archives</a>
                  </li>
                  
                </ul>
                <ul class="right" id="search-wrap">
                  <li>
                    <form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
                      <input type="hidden" id="search_q" name="q" value="" />
                      <input tabindex="1" type="search" id="search_input" placeholder="Search" />
                    </form>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </section>
      </nav>

      <nav class="tab-bar show-for-small">
        <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
          <span> &nbsp; TIME TO GO</span>
        </a>
      </nav>

      <aside class="left-off-canvas-menu">
        <ul class="off-canvas-list">
          <li>
            <a href="index.html">HOME</a>
          </li>
          <li>
            <a href="archives.html">Archives</a>
          </li>
          <li>
            <a href="about.html">ABOUT</a>
          </li>
          <li>
            <label>Categories</label>
          </li>
          
        </ul>
      </aside>
      <a class="exit-off-canvas" href="#"></a>
      <section id="main-content" role="main" class="scroll-container"> <script type="text/javascript">
  $(function () {
    $('#menu_item_index').addClass('is_active');
    $('#sidebar').parent().parent().hide();
  });
</script>

<div class="row">
  <div class="large-12 medium-12 columns">
    <div class="markdown-body article-wrap">

      <div class="article">
        
        <h1>Android编程权威指南 笔记(25~31)</h1>
        <div class="read-more clearfix">
          <span class="date">2018/4/27</span>
           
          <span class="comments">
             
          </span>
        </div>
      </div>

      <div class="article-content">
        <ul>
<li>
<a href="#toc_0">第25章 HTTP与后台任务</a>
<ul>
<li>
<a href="#toc_1">25.2 网络连接基本</a>
</li>
<li>
<a href="#toc_2">25.3 使用AsyncTask在后台线程上运行代码</a>
</li>
<li>
<a href="#toc_3">25.4 线程与主线程</a>
</li>
<li>
<a href="#toc_4">25.5 从Flicker获取JSON数据</a>
</li>
<li>
<a href="#toc_5">25.6 从AsyncTask回到主线程</a>
</li>
<li>
<a href="#toc_6">25.7 清理AsyncTask</a>
</li>
<li>
<a href="#toc_7">25.8 深入学习：AsyncTask再探</a>
</li>
<li>
<a href="#toc_8">25.9 深入学习：AsyncTask的替代方案</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">第26章 Looper、Handler和HandlerThread</a>
<ul>
<li>
<a href="#toc_10">26.1 配置RecyclerView以显示图片</a>
</li>
<li>
<a href="#toc_11">26.2 批量下载缩略图</a>
</li>
<li>
<a href="#toc_12">26.3 与主线程通讯</a>
</li>
<li>
<a href="#toc_13">26.5 Message与message handler</a>
</li>
<li>
<a href="#toc_14">26.6 深入学习：AsyncTask与线程</a>
</li>
<li>
<a href="#toc_15">26.8 深入学习：StrictMode</a>
</li>
</ul>
</li>
<li>
<a href="#toc_16">第27章 搜索</a>
<ul>
<li>
<a href="#toc_17">27.2 使用SearchView</a>
</li>
<li>
<a href="#toc_18">27.3 使用shared preferences实现轻量级数据存储</a>
</li>
</ul>
</li>
<li>
<a href="#toc_19">第28章 后台任务</a>
<ul>
<li>
<a href="#toc_20">28.0 概述</a>
</li>
<li>
<a href="#toc_21">28.1 创建IntentService</a>
</li>
<li>
<a href="#toc_22">28.2 服务的作用</a>
</li>
<li>
<a href="#toc_23">28.4 使用AlarmManager延迟运行服务</a>
</li>
<li>
<a href="#toc_24">28.6 通知信息</a>
</li>
<li>
<a href="#toc_25">28.8 深入学习：服务之细节</a>
</li>
<li>
<a href="#toc_26">28.9 深入学习：JobScheduler和JobService</a>
</li>
<li>
<a href="#toc_27">28.11 深入学习：sync adapter</a>
</li>
</ul>
</li>
<li>
<a href="#toc_28">第29章 broadcast intent</a>
<ul>
<li>
<a href="#toc_29">29.1 普通intent和broadcast intent</a>
</li>
<li>
<a href="#toc_30">29.2 接收系统broadcast：重启后唤醒</a>
</li>
<li>
<a href="#toc_31">29.3 过滤前台通知消息</a>
</li>
<li>
<a href="#toc_32">29.4 receiver与长时运行任务</a>
</li>
<li>
<a href="#toc_33">29.5 深入学习：本地事件</a>
</li>
<li>
<a href="#toc_34">29.6 深入学习：探测fragment的状态</a>
</li>
</ul>
</li>
<li>
<a href="#toc_35">第30章 网页浏览</a>
<ul>
<li>
<a href="#toc_36">30.3 较难方式：使用WebView</a>
</li>
<li>
<a href="#toc_37">30.4 处理WebView的设备旋转问题</a>
</li>
<li>
<a href="#toc_38">30.7 挑战练习：使用后退键浏览历史网页</a>
</li>
<li>
<a href="#toc_39">30.8 挑战练习：非HTTP链接支持</a>
</li>
</ul>
</li>
<li>
<a href="#toc_40">第31章 定制视图与触摸事件</a>
<ul>
<li>
<a href="#toc_41">31.2 创建定制视图</a>
</li>
</ul>
</li>
</ul>


<span id="more"></span><!-- more -->

<h3 id="toc_0">第25章 HTTP与后台任务</h3>

<h4 id="toc_1">25.2 网络连接基本</h4>

<ul>
<li><p><strong><code>url.openConnection()</code>方法默认返回的是URLConnection对象；但要连接的是http URL，因此需将其强制类型转换为HttpURLConnection对象，这样就可以调用getInputStream()、getResponseCode()等方法；</strong></p>

<pre><code class="language-java">URL url = new URL(urlSpec);
HttpURLConnection connection = (HttpURLConnection)url.openConnection();
</code></pre>

<pre><code class="language-java">try {
    InputStream in = connection.getInputStream();
    if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
        throw new IOException(connection.getResponseMessage() +
                &quot;: with&quot; + urlSpec);
    }
    int byteRead = 0;
    byte[] buffer = new byte[1024];
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    while ((byteRead = in.read(buffer)) &gt; 0) {
        out.write(buffer, 0, byteRead);
    }
    out.close();
    return out.toByteArray();
} finally {
    connection.disconnect(); // 关闭网络
}
</code></pre></li>
<li><p><strong>HttpURLConnection对象只有在调用getInputStream()方法（若为POST请求则调用getOutputStream()方法）时，才会真正连接到指定的URL地址；</strong></p></li>
<li><p>创建了URL并打开网络连接之后，就可以循环调用read()方法读取网络数据直到取完为止；只要还有数据，InputStream类就会不断地输出字节流数据；</p></li>
<li><p>连接网络需要先获取使用网络的权限，需要在AndroidManifest.xml文件中添加权限声明：</p>

<pre><code class="language-text">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
</code></pre></li>
<li><p>Android M中权限管理得到了加强，有些只要在AndroidManifest.xml中进行声明，有些危险性权限（如获取设备地理位置信息权限），既需要进行声明又需要<code>运行时动态申请</code>；</p></li>
</ul>

<h4 id="toc_2">25.3 使用AsyncTask在后台线程上运行代码</h4>

<ul>
<li><p><strong>不应该在主线程中运行网络连接代码，正确的做法是，创建一个后台线程，然后在该线程中运行网络连接代码；</strong></p></li>
<li><p><strong>使用后台线程最简便的方式是使用AsyncTask；</strong>AsyncTaks创建后台线程后，可以调用<code>execute()</code>方法启动asyncTask，进而触发后台线程调用<code>doInBackground()方法</code>（需要重写该方法，存放需要执行的后台代码）；</p></li>
</ul>

<h4 id="toc_3">25.4 线程与主线程</h4>

<ul>
<li><p>网络连接需要时间，Android禁止任何<code>主线程网络连接行为</code>，否则会抛出<code>NetworkOnMainThreadException</code>异常；</p></li>
<li><p>线程是一个单一执行序列；单线程中的代码会逐步执行；</p></li>
<li><p>主线程和线程不一样，其处于一个无限循环的运行状态，等者用户或系统触发事件；一旦有事件触发，主线程便执行代码做出响应；</p>

<ul>
<li>所有Android应用的运行都是从主线程开始的；</li>
<li>由于响应的事件基本都与用户界面相关，主线程有时也叫作UI线程；</li>
<li>等待响应期间，用户界面毫无反应，这可能会导致应用无响应（<code>Application Not Responding，ANR</code>）现象发生；解决此问题需要创建一个后台线程，在该线程中执行耗时的等待响应（比如网络请求）；</li>
</ul></li>
</ul>

<h4 id="toc_4">25.5 从Flicker获取JSON数据</h4>

<ul>
<li><p>使用<code>Uri.Builder</code>可以创建正确转义的参数化URL，其<code>appendQueryParameter(String, String)</code>方法可自动转义查询字符串；</p>

<pre><code class="language-java">String url = Uri.parse(&quot;https://api.flickr.com/services/rest/&quot;) # 创建一个Uri
            .buildUpon() # 创建一个Uri.Builder
            .appendQueryParameter(&quot;method&quot;, &quot;flickr.photos.getRecent&quot;) # 添加参数
            .appendQueryParameter(&quot;api_key&quot;, API_KEY)
            .build() # 创建一个Uri
            .toString(); 
</code></pre></li>
<li><p>json.org API提供了对应JSON数据的Java对象，如JSONObject（JSON对象）和JSONArray（JSON数组），可以通过<code>getJSONObject(String name)</code>、<code>getJSONArray(String name)</code>这两个便利方法获取；</p></li>
</ul>

<h4 id="toc_5">25.6 从AsyncTask回到主线程</h4>

<ul>
<li><p><strong>在配置adapter前，需要调用<code>fragment的isAdd()</code>方法判断该fragment是否与目标activity相关联，进而保证getActivity()方法返回结果不为空；</strong></p>

<ul>
<li>fragment可以脱离activity而独立存在；</li>
<li>之前，所有的方法调用都是由系统框架的回调方法驱动的，所以不会出现问题；</li>
<li>现在，由于使用AsyncTask从后台进程触发回调指令，不能确定fragment是否关联着activity，若没有关联则依赖activity的操作（比如调用getContext()方法）就会失败；</li>
</ul></li>
<li><p>在AsyncTask的doInBackground()方法中获取到数据后，不可直接在该方法中进行回调返回数据（不可以从后台线程更新UI）；</p></li>
<li><p>AsyncTask还提供<code>onPostExecute()</code>方法会在doInBackground()方法执行完毕后被调用，该方法在主线程上运行；可以在重写该方法，执行回调返回数据；</p></li>
</ul>

<h4 id="toc_6">25.7 清理AsyncTask</h4>

<ul>
<li><p>当在fragment中进行网络请求，为了让在设备旋转的时候不会重新创建AsyncTask，可以调用setRetainInstance(true)方法保留fragment；</p></li>
<li><p>但是某些情况下需要销毁或重新运行AsyncTask，可以调用<code>asyncTask.cancel(boolean)</code>方法撤销运行中的task；撤销有两种方式：粗暴的（cancel方法参数为true）、温和的（cancel方法参数为fasle），应避免使用粗暴的方式；</p></li>
<li><p><strong>在fragment销毁或者视图看不到的时候，应该撤销AsyncTask，否则可能会引发潜在的内存泄露，也可能会出现UI更新问题（UI已失效）；若不管用户怎么操作，要确保重要工作能完成，那最好考虑其他解决方案，比如使用Service；</strong></p></li>
</ul>

<h4 id="toc_7">25.8 深入学习：AsyncTask再探</h4>

<ul>
<li><p>AsyncTask有三个泛型参数的类型：</p>

<ul>
<li>第一个参数：task.execute()方法的输入参数的类型（参数可以接受一个或多个），该参数会将数据传递给doInBackground()方法；</li>
</ul>

<pre><code class="language-java">AsyncTask&lt;String, Void, Void&gt; task = new AsyncTask&lt;String, Void, Void&gt;() {
    public Void doInBackground(String... params) {
        for (String parameter : params) {
            Log.i(TAG, &quot;Received parameter: &quot; + parameter);
        }
        return null;
    }
};
task.execute(&quot;First parameter&quot;, &quot;Second parameter&quot;, &quot;Etc.&quot;);
</code></pre>

<ul>
<li><p>第二个参数：指定发送进度更新所需要的类型；</p>

<ul>
<li>进度更新通常发生在执行的后台进程中，但是该进程无法更新UI；AsyncTask提供了<code>publishProgress()</code>、<code>onProgressUpdate()</code>方法；</li>
<li>在后台线程中，从doInBackground()方法中调用publishProgress()方法，触发onProgressUpdate()方法收到进度更新后被在主线程中调用，在该方法中进行UI更新操作；</li>
</ul>

<pre><code class="language-java">final ProgressBar gestationProgressBar;
AsyncTask&lt;Void, Integer, Void&gt; haveABaby = new AsyncTask&lt;Void, Integer, Void&gt;() {
    public Void doInBackground(Void... params) {
         while (!babyIsBorn()) {
            Integer weeksPassed = getNumberOfWeeksPassed();
            publishProgress(weeksPassed);
            patientlyWaitForBaby();
        } 
    }

    public void onProgressUpdate(Integer... params) {
        int progress = params[0];
        gestationProgressBar.setProgress(progress);
    } 
};
haveABaby.execute();
</code></pre></li>
<li><p>第三个参数：返回结果的数据类型；也就是<code>doInBackground()</code>方法返回结果的数据类型，以及<code>onPostExecute()</code>方法输入参数的数据类型；</p></li>
</ul></li>
</ul>

<h4 id="toc_8">25.9 深入学习：AsyncTask的替代方案</h4>

<ul>
<li><p>当在fragment中使用AsyncTask加载数据时，若遇到设备配置改变可通过setRetainInstance(true)保存数据；但是若用户在AsyncTask运行时按后退键、或者fragment因内存紧张而被销毁时，AsyncTask无法很好地保存数据，使用Loader是一种可行的解决方法；</p></li>
<li><p>Loader可以从某些数据源（磁盘、数据库、ContentProvider、网络、另一个进程等）中加载数据（对象）；</p></li>
<li><p><strong>AsyncTaskLoader是个抽象的Loader，其可以使用AsyncTask将数据加载工作转移到其他线程上，可以在不阻塞主线程的前提下获取到数据，并把结果发送给目标对象；我们创建的loader类几乎都是AsyncTaskLoader的子类；</strong></p></li>
<li><p>相对于AsyncTask，使用Loader可以通过LoaderManager帮助我们管理loader及其加载的数据、管理loader的生命周期；设备配置变化后，若初始化一个已经加载完数据的loader，其可立即提交数据，而不是再次尝试获取数据，无论fragment是否存在；</p></li>
</ul>

<h3 id="toc_9">第26章 Looper、Handler和HandlerThread</h3>

<h4 id="toc_10">26.1 配置RecyclerView以显示图片</h4>

<ul>
<li><p>获取res/drawable目录中的图片：</p>

<pre><code class="language-text">Drawable placeholder = getResources().getDrawable(R.drawable.bill_up_close);
</code></pre></li>
</ul>

<h4 id="toc_11">26.2 批量下载缩略图</h4>

<ul>
<li><p>不可以将所有的图片都下载完成才进行显示（耗时、耗内存），应该在需要显示图片时才去下载，比如在RecyclerView的Adpter的<code>onBindViewHolder()</code>中进行下载图片；</p></li>
<li><p>AsyncTask是执行后台线程的最简单方式，但其不适合重复且长时间运行的任务；</p></li>
</ul>

<h4 id="toc_12">26.3 与主线程通讯</h4>

<ul>
<li><p><strong>Android系统中，消息循环（message loop）由looper与线程构成，looper管理着线程所使用的的消息队列（message queue）；</strong></p>

<ul>
<li><strong>looper不断从消息队列中抓取消息，然后完成消息指定的任务；</strong></li>
<li><strong>只有线程使用了消息队列（message queue），<code>可以称该线程是个消息循环(message loop)</code>；</strong></li>
<li><strong>主线程也是个消息循环，自然也就有looper；主线程的所有工作都是由其looper完成的；</strong></li>
</ul></li>
<li><p><strong>可以创建一个消息循环作为后台线程使用，只需要继承于HandlerThread类即可，比如ThumbnailDownloader；</strong></p></li>
<li><p><strong>在fragment的onCreate方法中创建并启动，在onDestroy方法中结束线程（否则其会一直运行下去）；注意，调用start方法后再调用getLooper方法获取looper；</strong></p>

<pre><code class="language-java">public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mThumbnailDownloader = new ThumbnailDownloader&lt;&gt;();
    mThumbnailDownloader.start();
    mThumbnailDownloader.getLooper();
}

public void onDestroy() {
    super.onDestroy();
    mThumbnailDownloader.quit();
}
</code></pre></li>
</ul>

<h4 id="toc_13">26.5 Message与message handler</h4>

<ul>
<li><p><strong>消息队列中存放着消息（message）；消息是一个Message类的实例，其有一些成员变量，比如what（用于描述消息的代码）、obj（附加在消息中的数据）、target（处理该消息的对象，handler）；</strong></p></li>
<li><p><strong>message的目标就是handler（Handler类的实例）；创建message时，其会自动与一个handler相关联；</strong></p></li>
<li><p><strong>handler不仅仅是处理message的target，也是创建和发布message的接口；</strong></p></li>
<li><p><strong>looper拥有消息队列，所以message必须在looper上发布或处理；因此，handler为了与looper协同工作，handler总是引用着looper；</strong></p></li>
<li><p><strong>一个looper拥有一个消息队列，一个消息队列中有多个message，每个message都仅有一个handler（多个message的handler可以相同，也可以不同），一个handler与一个looper关联；</strong></p>

<ul>
<li><strong>多个handler关联的looper若相同，则说明handler的message在同一消息队列队列中；</strong></li>
<li><strong>多个handler关联的looper若不同，则说明handler的message在不同的消息队列队列中；</strong></li>
</ul>

<p><figure><img src="media/15237039848080/messages_handler.png" alt="messages_handle" style="width:227px;"/><figcaption>messages_handle</figcaption></figure> <figure><img src="media/15237039848080/messages_handlers.png" alt="messages_handlers" style="width:223px;"/><figcaption>messages_handlers</figcaption></figure></p></li>
<li><p><strong>一般来讲，不应手动手动设置message的handler；</strong></p>

<ul>
<li><strong>创建message时，最好使用<code>handler.obtainMessage()</code>方法，该方法会自动给该message设置handler为方法调用者自身；</strong></li>
<li><strong>而且obtainMessage()方法更加高效，其会先从公共循环池中获取，获取不到才创建新的message；</strong></li>
</ul></li>
<li><p><strong>一旦获取到message，可以调用<code>sendToTarget()</code>方法将其发给handler，然后handler将给message放置到looper的消息队列的尾部；</strong></p></li>
<li><p><strong>looper取出消息队列中的message后，会将其发送给对应的handler进行处理；message一般在handler的<code>handlerMessage()</code>方法中进行处理；</strong></p></li>
<li><p><strong>发送message：</strong></p>

<ul>
<li>ConcurrentHashMap是一个线程安全的HashMap；</li>
<li><p>由于recycleView的viewHolder总是不断在回收重用，因此使用viewHolder为key，图片的url为value，这样就能保证使用匹配viewHolder的最新的url进行下载图片；</p>

<pre><code class="language-java">public void queueThumbnail(T tagert, String url) {
    Log.i(TAG, &quot;Got a URL: &quot; + url);

    if (url == null) {
        mRequestMap.remove(tagert);
    } else {
        mRequestMap.put(tagert, url); // 新增或更新viewHolder对应的url
        mRequestHandler.obtainMessage(MESSAGE_DOWNLOAD, tagert)
                .sendToTarget(); // 将下载消息放到后台线程的消息队列中
    }
}
</code></pre></li>
</ul></li>
<li><p><strong>处理message：</strong></p>

<ul>
<li><strong>在HandlerThread的<code>onLooperPrepared()</code>方法中，初始化Handler子类并实现处理消息的handleMessage()方法；</strong></li>
<li>onLooperPrepared()方法是创建Handler子类的最好地方，其会在looper首次检查消息队列之前调用；</li>
<li>在handleMessage()方法中，需要先检查消息类型再获取obj值，之后完成相关的操作；</li>
<li><p><strong>由于handler是在后台线程中创建的，所以handler处理message的相关操作是在后台线程完成的；</strong></p>

<pre><code class="language-java">@Override
protected void onLooperPrepared() {
    mRequestHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            if (msg.what == MESSAGE_DOWNLOAD) {
                T target = (T) msg.obj;
                Log.i(TAG, &quot;Got a request for url: &quot; + mRequestMap.get(target));
            }
        }
    };
}
</code></pre></li>
</ul></li>
<li><p>使用ThumbnailDownloader的mRequestHandler，已可以从主线程安排后台线程任务（下载图片）了；反过来，也可以从后台线程使用与主线程关联的Handler，安排主线程任务（显示图片）；</p></li>
<li><p><strong>主线程也是一个消息循环；在主线程上创建的Handler会自动与它的Looper相关联；</strong></p></li>
<li><p><strong>主线程上创建的Handler也可以传递给另一线程，传递出去的Handler与创建它的线程Looper始终保持着联系；因此，已传出Handler负责处理的所有消息都将在主线程的消息队列中处理；</strong></p></li>
<li><p><strong>若message设置了回调方法，不需要再调用sendToTarget()方法，该message也不会被发给handler，而是直接执行回调方法中的Runnable的run()方法；</strong></p>

<pre><code class="language-java">Runnable myRunnable = new Runnable() {
    @Override
    public void run() {

    }
}；
Message m = mHandler.obtainMessage();
m.callback = myRunnable;
</code></pre></li>
<li><p><strong><code>mHandler.post(Runnable)</code>则上面方法的更便利方式（对上面方式进行了封装），不用再显式创建message了，直接运行Runnable的run()方法；</strong></p>

<pre><code class="language-java">mHandler.post(new Runnable() {
    public void run() {
        // .....
    }
});
</code></pre></li>
<li><p>当设备配置改变时，setRetainInstance(true)只是保留fragment对象及其内部的成员变量，fragment对应的视图还是依然被销毁；</p></li>
<li><p>图片视图失效可能会导致下载线程被挂起，若点击这些图片视图就会发生异常，此时应该清理下载序列（消息队列中的消息）；</p>

<pre><code class="language-java">public void clearQueue() {
    mRequestHandler.removeMessages(MESSAGE_DOWNLOAD);
}
</code></pre></li>
</ul>

<h4 id="toc_14">26.6 深入学习：AsyncTask与线程</h4>

<ul>
<li><p>AsyncTask适用于短暂且较少重复的任务，HandlerThread则适合于长久、重复的任务；</p></li>
<li><p>从Android 3.2开始，AsyncTask不再为每一个AsyncTask实例单独创建线程，而是使用一个Executor在单一的后台线程上运行所有AsyncTask后台任务，所有的AsyncTask需要排队运行，长时间运行的AsyncTask会阻塞其他AsyncTask；</p></li>
</ul>

<h4 id="toc_15">26.8 深入学习：StrictMode</h4>

<ul>
<li><p><strong>Android引入的<code>StrictMode</code>可以帮助开发者探测代码问题，其能探测在主线程上发起网络请求、编码漏洞以及安全漏洞等这样的问题；无需配置，其就会阻止在主线程上发起网络请求这样的代码问题；</strong></p></li>
<li><p>若需要启用StrictMode默认防御策略，调用<code>StrictMode.enableDefaults()</code>方法即可；之后，若代码有相关问题，在Logcat中就能看到相关提醒：在主线程上发起网络请求、在主线程上进行磁盘读写、Activity未及时销毁（activity泄露）、SQLite数据库游标未关闭、网络通信使用了明文（未使用SSL/TLS加密）；</p></li>
<li><p>若想定制应用违反了防御策略的应对行为，可使用<code>ThreadPolicy.Builder、VmPolicy.Builder</code>类进行定制；定制的应对行为有：控制是否抛出异常，弹出对话框或是日志记录违反策略警示信息；</p></li>
</ul>

<h3 id="toc_16">第27章 搜索</h3>

<h4 id="toc_17">27.2 使用SearchView</h4>

<ul>
<li><p><strong>可以使用SearchView来实现搜索功能，SearhView是个<code>操作视图</code>（Action View）；所谓<code>操作视图</code>就是可以内置在工具栏中的视图，SearchVew可以让整个搜索界面完全内置在应用的工具栏中；</strong></p></li>
<li><p>在应用顶部的工具栏的自定义菜单xml文件添加SearchView；</p>

<pre><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
      xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;
    &lt;item android:id=&quot;@+id/menu_item_search&quot;
        android:title=&quot;@string/search&quot;
        app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;
        app:showAsAction=&quot;ifRoom&quot;/&gt;

    &lt;item android:id=&quot;@+id/menu_item_clear&quot;
        android:title=&quot;@string/clear_search&quot;
        app:showAsAction=&quot;never&quot;/&gt;
&lt;/menu&gt;
</code></pre>

<ul>
<li><strong>app:actionViewClass：指定值为ndroid.support.v7.widget.SearchView表示工具栏要显示SearchView；建议使用支持库版本的SearchView；</strong></li>
<li>注意：actionViewClass、showAsAction的命名空间都是app；</li>
</ul></li>
<li><p><strong>在fragment的<code>onCreateOptionsMenu()</code>方法进行设置SearchView的相关监听操作（不是在onOptionsItemSelected(MenuItem item)方法响应点击事件）；<code>SearchView.OnQueryTextListener</code>接口提供了接收回调的方式，可以响应查询指令，其有两个必须实现的方法：</strong></p>

<ul>
<li>onQueryTextSubmit
(String)：用户提交查询时调用，受理搜索请求则返回true；</li>
<li>onQueryTextChange(String)：搜索框的文字发生变化时调用；</li>
</ul>

<pre><code class="language-java">MenuItem searchItem = menu.findItem(R.id.menu_item_search);
SearchView searchView = (SearchView) searchItem.getActionView();
searchView.setOnQueryTextListener(...)
</code></pre></li>
</ul>

<h4 id="toc_18">27.3 使用shared preferences实现轻量级数据存储</h4>

<ul>
<li><p>shared preferences是一个保存在应用沙盒中的xml文件，通常用于存储配置信息、一些不敏感的数据；可使用<code>SharedPreferences</code>去读写它，其屏蔽了读写文件的实现细节，使用起来类似于Bundle的键值对操作，键为字符串，值为原子数据类型；</p></li>
<li><p>一般情况下，使用<code>PreferenceManager.getDefaultSharedPreferences(Context)</code>方法获取的SharedPreferences实例，该方法会返回具有私有权限和默认名称的实例（仅在当前应用内可用）；若需获取SharedPreferences定制实例可使用Context.getSharedPreferences(String, int)方法；</p></li>
<li><p><strong>SharedPreferences也有事务批量操作的概念，<code>SharedPreferences.Editor</code>的<code>apply()</code>方法先在内存中执行数据变更，然后在后台线程上真正把数据写入文件；</strong></p>

<pre><code class="language-java">// 读
PreferenceManager.getDefaultSharedPreferences(context)
                    .getString(PREF_SEARCH_QUERY, null);
</code></pre>

<pre><code class="language-java">// 写
PreferenceManager.getDefaultSharedPreferences(context)
                    .edit()
                    .putString(PREF_SEARCH_QUERY, query)
                    .apply();
</code></pre></li>
</ul>

<h3 id="toc_19">第28章 后台任务</h3>

<h4 id="toc_20">28.0 概述</h4>

<ul>
<li><p><strong>Service是Android中实现程序后台运行的解决方案，适用于去执行那些不需要和用户交互而且还要求长期运行的任务；Service默认运行在UI线程中，不过可以在Service中创建子线程来完成耗时操作；</strong></p></li>
<li><p><strong>不同的服务启动方式，创建的服务的可交互性不同；</strong></p>

<ul>
<li><p><strong>a. 不可交互的服务：</strong></p>

<ul>
<li>调用<code>startService()</code>方法开启服务，调用<code>stopService()</code>、<code>stopSelf()</code>方法停止服务；</li>
<li>生命周期有onCreate、onStartCommand、onDestroy；</li>
<li>首次调用startService()时，创建Service、回调onCreate、onStartCommand，再次调用startService()时，只执行onStartCommand；</li>
<li>创建方式：继承Service，重写onBind()方法返回nil；</li>
</ul></li>
<li><p><strong>b. 可交互的服务：</strong></p>

<ul>
<li>调用<code>bindService()</code>方法开启服务，返回后台服务的代理对象，通过代理对象调用后台服务中定义的方法，也就实现了后台服务和前台的交互；调用<code>unbindService()</code>停止服务；</li>
<li>生命周期有onCreate、onBind、onUnBind、onDestroy；</li>
<li>首次调用bindService()时，创建Service、回调onCreate、onBind，再次调用bindService()时，只执行onBind；</li>
<li>创建方式：继承Service，重写onBind()方法返回一个自定义IBinder对象；</li>
</ul></li>
<li><p><strong>c. 混合性交互的服务：</strong></p>

<ul>
<li>startService、bindService没有本质区别；</li>
<li>同时使用startService、bindService启动服务，当服务创建后就不再创建回调onCreate方法了，关闭时需要使用两种方式关闭，否则服务无法关闭；</li>
</ul></li>
</ul></li>
<li><p><strong>默认情况下，不论是使用startService，还是使用bindService创建的服务，都称为<code>本地服务（Local）</code>，该服务附在启动它的程序的主进程上；</strong></p>

<ul>
<li><strong>a. 没有独立的线程在一定程度上节约了资源，在同一进程因此不需要IPC，也不需要AIDL；</strong></li>
<li><strong>b. 该服务只为本程序工作；</strong></li>
<li><strong>c. 服务的最大生命周期：</strong>

<ul>
<li><strong>使用startService创建的：当调用startService方法的组件（如activity）被销毁时，该服务也会被销毁；</strong></li>
<li><strong>使用bindService创建的：只有该应用进程被销毁时，该服务才会被销毁；</strong></li>
</ul></li>
</ul></li>
<li><p><strong>远程服务（Remote）</strong></p>

<ul>
<li><strong>该服务为独立的进程；在应用进程被Kill的时候，该服务依然在运行，不受其他进程影响，为多个进程提供服务具有较高的灵活性；</strong></li>
<li><strong>远程服务在AndroidManifest.xml中声明Service时，需要指定<code>android:process</code>属性；创建、关闭远程服务和创建本地服务没有区别，都是使用startService、bindService方法等；</strong></li>
<li><strong>独立进程的名称为所在包名加上android:process属性值；</strong></li>
<li><strong>一般情况下很少使用，多进程间数据通信比较复杂；但是一些应用为了实现<code>杀不死的后台</code>，会同时创建多个远程服务用于<code>互相唤醒</code>；</strong></li>
</ul></li>
<li><p><strong>前台服务</strong></p>

<ul>
<li><strong>一般情况下服务都是运行在后台，所以称为<code>后台服务</code>；后台服务（本地服务）的优先级相对比较低，当系统内存不足时，其可能会被回收掉；</strong></li>
<li>使用<code>前台服务</code>可以解决上面的问题，其可以一直保持运行状态而不被系统回收，比如状态栏中的天气预报；</li>
<li>创建前台服务很简单，就是在service的基础上创建一个Notification，然后使用service的<code>startForeground()</code>方法即可启动为前台服务；</li>
</ul></li>
<li><p><strong>IntentService</strong></p>

<ul>
<li><strong>IntentService是为了简便Service的使用；其会自动创建子线程运行需要执行的代码，并且在代码运行完毕后自动关闭service；</strong></li>
<li>使用IntentService只要继承IntentService并覆写onHandlerIntent()方法，在该方法中执行耗时操作就可以了；</li>
</ul></li>
</ul>

<h4 id="toc_21">28.1 创建IntentService</h4>

<ul>
<li><p>若不给应用提供用户界面，只想任务在后台运行，就需要使用<code>服务</code>；</p></li>
<li><p>IntentService是Android提供的最常用的一种类型服务，其也是一个context（Service是Context的子类），并能够响应intent；</p></li>
<li><p><strong>服务的intent也被称为<code>命令（command）</code>，命令就是要服务完成某项具体的任务；服务的种类不同，其执行命令的方式也不尽相同；</strong></p></li>
<li><p><strong>IntentService的工作流程：</strong></p>

<ul>
<li><strong>1). 接收到首个命令后，IntentService启动并触发一个后台线程，然后将命令放入队列，之后新进命令放在队列尾部；</strong></li>
<li><strong>2). 随后，IntentService按照顺序执行队列中的每一条命令（在后台线程上调用onHandleIntent(Intent)方法）；</strong></li>
<li><strong>3). 最后，执行完队列中的全部命令后，服务也随即停止并销毁；</strong></li>
</ul></li>
</ul>

<h4 id="toc_22">28.2 服务的作用</h4>

<ul>
<li><p>Activity是Android应用的前台，Service就是Android应用的后台；即使前台关闭，activity消失很久，也可以让后台服务依然持续不断地工作；</p></li>
<li><p>Android为用户提供了关闭后台应用进行网络连接的功能，所以在后台连接网络时，需要使用<code>ConnectivityManager</code>确认网络连接是否可用；</p>

<ul>
<li>使用后台数据设置选项关闭后台数据下载后，则后台服务也就无法联网了（即使网络是畅通的），<code>connectivityManager.getActiveNetworkInfo()</code>返回null；</li>
<li>使用<code>connectivityManager.getActiveNetworkInfo().isConnected()</code>可检查当前网络是否已连接；</li>
<li>注意，获取网络状态需要在manifest中配置<code>ACCESS_NETWORK_STATE</code>权限；</li>
</ul></li>
</ul>

<h4 id="toc_23">28.4 使用AlarmManager延迟运行服务</h4>

<ul>
<li><p><strong>在没有activity运行的情况下，为在后台运行服务，需要一个办法启动它；比如说，可以设置一个5分钟间隔的定时器；</strong></p>

<ul>
<li>1). 一种方式是调用Handler的sendMessageDelayed()、postDelayed()方法；但当用户离开当前应用，进程就会停止Handler消息也会随之消亡，该方式不可靠；</li>
<li>2). <strong>另一种方式是使用<code>AlarmManager</code>；AlarmManager是一个可以<code>发送Intent</code>的系统服务，其发送<code>使用PendingIntent包装的intent</code>；</strong></li>
</ul></li>
<li><p><strong>调用<code>PendingIntent.getService()</code>方法创建一个用来启动XXService的PendingIntent，参数依次为：</strong></p>

<ul>
<li><strong>a. 用于发送intent的context；</strong></li>
<li><strong>b. 区分pendingIntent来源的请求代码；</strong></li>
<li><strong>c. 待发送的intent对象；</strong></li>
<li><strong>d. 决定如何创建pendingIntent的标志位；</strong></li>
</ul>

<pre><code class="language-java">Intent intent = PollService.newIntent(context);
    PendingIntent pi = PendingIntent.getService(context, 0, intent, 0);
</code></pre></li>
<li><p><strong>设置定时器可以调用<code>alarmManager.setRepeating()</code>方法</strong>，参数依次为：时间基准常量、启动的时间、循环的时间间隔、要发送的pendingIntent；从Android5.1开始最小时间间隔为60秒；</p>

<ul>
<li>时间基准常量AlarmManager.ELAPSED_REALTIME表示经过一段时间就启动定时器；时间基准常量AlarmManager.RTC表示到某个固定时间就启动定时器；</li>
</ul>

<pre><code class="language-java">// 通过LogCat可看到PollService服务以60秒为间隔运行（这正是AlarmManager擅长的事情），
// 即使进程停止了，AlarmManager依然会不断发送intent，反复启动PollService服务；
AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
alarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME, 
    SystemClock.elapsedRealtime(), POLL_INTERVAL_MS, pi);
</code></pre></li>
<li><p>取消定时器可调用<code>AlarmManager.cancel(pendingIntent)</code>方法，通常也需同步取消pendingIntent；</p>

<pre><code class="language-java">alarmManager.cancel(pendingIntent);
pendingIntent.cancel();
</code></pre></li>
<li><p>合理控制服务启动的频度</p>

<ul>
<li>后台服务重复性的工作是个开销极大的操作，若该服务没有精确时间间隔要求的，可以将我们的应用和其他应用的定时器放在一起管理，让系统可以批量处理定时器；</li>
<li><strong>alarmManager.setRepeating()就是以不精确的时间间隔设置定时器（定时器可重复）；</strong></li>
<li>alarmManager.setWindow()、alarmManager.setExact()则是以精确的时间间隔设置定时器（定时器只能执行一次，若需要重复需要手动处理）；</li>
</ul></li>
<li><p>时间基准值：</p>

<ul>
<li>1). AlarmManager.ELAPSED_REALTIME：最近一次开机后运行的时间；</li>
<li>2). AlarmManager.RTC：使用UTC时间；需要考虑本地时间因素；</li>
<li><strong>3). AlarmManager.ELAPSED_REALTIME_WAKEUP、AlarmManager.RTC_WAKEUP：若设置处于睡眠状态即屏幕关掉状态，上面的时间基准是不会触发的；使用这两个值可以让定时器强制唤醒设备；</strong></li>
</ul></li>
<li><p><strong>调用<code>PendingIntent.getService()</code>方法传入<code>PendingIntent.FLAG_NO_CREATE</code>标志，表示若pendingIntent不存在，则直接返回null而不是创建；</strong></p>

<ul>
<li><strong>一个pendingIntent只能登记一个定时器，因此在这里，pendingIntent为空值表示还未设置定时器；</strong></li>
<li><strong>pendingIntent是一个token对象，其代表当前应用发送token对象；若使用同一个intent多次请求pendingIntent，得到的是同一个pendingIntent；</strong></li>
</ul>

<pre><code class="language-java">PendingIntent pi = PendingIntent
                .getService(context, 0, intent, PendingIntent.FLAG_NO_CREATE);
boolean isOn = (pi != null);
</code></pre></li>
</ul>

<h4 id="toc_24">28.6 通知信息</h4>

<ul>
<li><p><code>通知消息（notification）</code>是指显示在通知抽屉上的消息条码，用户可向下滑动屏幕读取；若要发送通知消息，需要要创建<code>Notification</code>对象，之后调用<code>NotificationManager</code>系统服务的<code>notify()</code>方法发送；</p></li>
<li><p>完整的Notification至少包括：</p>

<ul>
<li>a. ticker text：Lollipop之前的设备，首次显示通知时显示在状态栏上的文字；Lollipop之后的设备，不显示但仍与可访问性服务相关；</li>
<li>b. 图标：显示在状态栏上；Lollipop之前的设备，在ticker text消失后出现；</li>
<li>c. 通知信息本身：在通知抽屉中显示的视图；</li>
<li>d. 待触发的PendingIntent：用户点击抽屉中的通知信息时触发；</li>
</ul>

<pre><code class="language-java">Resources resources = getResources();
Intent intent = PhotoGalleryActivity.newIntent(this);
PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);

Notification notification = new NotificationCompat.Builder(this)
        .setTicker(resources.getString(R.string.new_pictures_title))
        .setSmallIcon(android.R.drawable.ic_menu_report_image)
        .setContentTitle(resources.getString(R.string.new_pictures_title))
        .setContentText(resources.getString(R.string.new_pictures_text))
        .setContentIntent(pi)
        .setAutoCancel(true)
        .build();

NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
notificationManager.notify(0, notification);
</code></pre>

<ul>
<li>以android.R.drawable.DRAWABLE_NAME包名形式引用的图标资源已内置于Android.framework中；</li>
<li>setAutoCancel(true)表示点击消息后，该消息从消息抽屉中删除；</li>
<li>发送消息方法notificationManager.notify(0, notification)的第一个参数为通知消息的标识符，整个应用中该值应该是唯一的；若使用同一ID发送两条消息，则第二条消息会替换掉第一条消息，在实际开发中，这也是进度条或其他动态视觉效果的实现方式；</li>
</ul></li>
</ul>

<h4 id="toc_25">28.8 深入学习：服务之细节</h4>

<ul>
<li><p>对于大多数服务任务，推荐使用IntentService；但IntentService模式不适合所有架构，若不适合需要直接继承Service；</p></li>
<li><p>与Activity一样，Service也是一个有生命周期回调方法的应用组件，这些回调方法同样也是在UI线程上运行，不能在后台线程上运行；</p></li>
<li><p>为了简化代码，IntentService内部提供了一套Service标准代码，而且其也提供了一套标准的在后台线程上运行的支持方案；推荐直接使用IntentService；</p></li>
<li><p>服务的生命周期：</p>

<ul>
<li>onCreate()：服务创建时被调用；</li>
<li>onStartCommand(Intent, int, int)：每次通过startService(Intent)方式启动服务时调用；两个int参数分别为：标识符集（表示该intent是重新发送，还是一次之前没有成功的发送）、启动ID（每次都不同，可以用于区分不同的命令）；</li>
<li>onDestroy()：服务停止时被调用；</li>
</ul></li>
<li><p>服务停止的方式取决于服务的类型；服务的类型由onStartCommand()方法的返回值确定，有Service.START_NOT_STICKY、START_REDELIVER_INTENT、START_STICKY；</p>

<ul>
<li><p><strong>non-sticky服务：</strong></p>

<ul>
<li><strong>该类型的服务会在自己认为服务已完成时停止；为得到该类型的服务，onStartCommand方法返回Service.START_NOT_STICKY（服务消亡后就永久消亡）、START_REDELIVER_INTENT（服务消亡后，在资源不紧张时会再次重启）；</strong></li>
<li>调用stopSelf()（无条件地停止服务）、stopSelf(int)（需要传入启动ID才停止服务）方法告诉Android任务已完成；</li>
<li>IntentService是一种non-sticky服务，且onStartCommand方法默认返回START_NOT_STICKY；若需返回START_REDELIVER_INTENT，可调用intentService.setIntentRedelivery(true)方法；</li>
</ul></li>
<li><p><strong>sticky服务：</strong></p>

<ul>
<li>该类型的服务会持续运行，直到外部部件调用Context.stopService(Intent)方法让其停止；为得到该类型的服务，onStartCommand方法返回Service.STICKY；</li>
<li>可以传入一个null intent给onStartCommand方法，以实现该类型服务的重启；</li>
<li>该类型的服务适用于长时间运行的服务，比如音乐播放器；</li>
<li>该类型的服务管理很不方便，很难判断服务是否已启动；</li>
</ul></li>
</ul></li>
<li><p><strong>可以使用<code>bindService(Intent, ServiceConnection, int)</code>方法绑定一个服务，以此获取直接调用被绑定服务中的方法的能力；<code>ServiceConnection</code>是代表服务绑定的一 个对象，负责接收全部绑定回调方法</strong></p>

<pre><code class="language-java">@override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Intent i = new Intent(getActivity(), MyService.class);
    getActivity().bindService(i, mServiceConnection, 0);
}

@override
public void onDestroy() {
    super.onDestroy();
    getActivity().unbindService(mServiceConnection);
}
</code></pre></li>
<li><p>服务还有两个与绑定有关的生命周期回调方法：</p>

<ul>
<li>onBind(Intent)：每次绑定服务时被调用，返回值为ServiceConnection.onServiceConnected(ComponentName, IBinder)方法返回的IBinder对象；</li>
<li>onUnbind(Intent)：服务绑定终止时调用；</li>
</ul></li>
<li><p>绑定服务分为本地服务绑定、远程服务绑定（它们赋予了其他进程中应用调用服务方法的能力）；</p></li>
</ul>

<h4 id="toc_26">28.9 深入学习：JobScheduler和JobService</h4>

<ul>
<li><p>通过AlarmManager、IntentService和PendingIntent相互配合，已经创建了周期性的后台服务；</p></li>
<li><p><strong>从Lollipop（API21）开始，为了更好地实现后台服务，Android引入了一个叫做JobScheduler的全新API；除了实现常规后台服务之外，JobScheduler还支持按场景、按条件运行后台服务；虽然上述某些场景使用AlarmManager、IntentService也可能实现，但是比较麻烦；</strong></p></li>
<li><p>使用JobScheduler需要新建一个处理任务的服务，使用JobService子类，重写onStartJob(JobParameters)、onStopJob(JobParameters)方法；</p>

<ul>
<li>onStartJob：服务启动后在主线程上回调，返回值为布尔值，true表示任务还未完成、false表示任务已完成；</li>
<li>onStopJob：服务结束前在主线程上回调，返回值为布尔值，true表示任务计划下次继续、false表示任务永久结束；</li>
</ul></li>
<li><p><strong>与IntentService不同，JobService需要单独开后台线程执行任务（比如在onStartJob方法中创建AsyncTask）；</strong></p></li>
<li><p>任务结束，可以调用<code>jobFinished(JobParameters, boolean)</code>方法通知结果；第二个参数若为true，表示任务其实还没有做完，下次继续；</p></li>
<li><p>在manifest中配置文件中登记服务时，必须将其导出并添加权限；导出就是将服务暴露出来，添加的权限控制只有JobScheduler才能运行；</p>

<pre><code class="language-text">&lt;service android:name=&quot;.PollService&quot;
    android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot;
    android:exported=&quot;true&quot;/&gt;
</code></pre></li>
<li><p>创建一个JobInfo就是创建JobService；setPersisted(true)方法保证服务在设备重启后也能按计划运行；</p>

<pre><code class="language-java">final int JOB_ID = 1;

JobScheduler scheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
JobInfo jobInfo = new JobInfo.Builder(JOB_ID, new ComponentName(context, PollService.class))
        .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED)
        .setPeriodic(1000 * 60 * 15)
        .setPersisted(true)
        .build();
scheduler.schedule(jobInfo);
</code></pre></li>
<li><p>一旦创建了JobService，启动它就非常迅速，可以使用JobScheduler检查是否已计划好了任务；</p>

<pre><code class="language-java">final int JOB_ID = 1;
JobScheduler scheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);

boolean hasBeenScheduled = false;
for (JobInfo jobInfo : scheduler.getAllPendingJobs()) {
    if (jobInfo.getId() == JOB_ID) {
        hasBeenScheduled = true;
    } 
}
</code></pre></li>
<li><p>JobScheduler和未来的后台服务</p>

<ul>
<li>只有Lollipop及其之后的系统才支持JobScheduler，并且其也没有支持库版实现；</li>
<li>AlarmManager实现的定时服务是唯一支持各个Android系统版本的可行标准库解决方案；</li>
<li>但是AlarmManager并不是处理后台定时器服务的最好方式，一旦JobScheduler普及，Android就会立即抛弃AlarmManager；</li>
<li>也可以使用android-job是第三方兼容库Evernote；</li>
</ul></li>
</ul>

<h4 id="toc_27">28.11 深入学习：sync adapter</h4>

<ul>
<li><p><strong>也可以使用<code>sync adapter</code>创建常规的polling网络服务，和JobScheduler一样可以代替AlermManager；</strong></p></li>
<li><p>sync adapter主要用于从某个数据源同步数据（上传、下载、既上传又下载）；设备重启后也自动完成相关同步，而且还能和操作系统完美整合；</p></li>
</ul>

<h3 id="toc_28">第29章 broadcast intent</h3>

<h4 id="toc_29">29.1 普通intent和broadcast intent</h4>

<ul>
<li><p><code>broadcast intent</code>的工作原理类似于之前的intent，唯一不同的是broadcast intent可同时被多个叫做broadcast receiver的组件接收；</p></li>
<li><p>若使用公共API，activity和Service都可以响应隐式intent；若使用私有API，显式intent就足够了；<strong>如此还需要<code>broadcast intent</code>的理由只有一个，其可以发送给多个接收者；</strong></p></li>
<li><p>虽然broadcast receiver也可以响应显式intent，但是几乎不这样使用（显式intent只允许有一个接收者）；</p></li>
</ul>

<h4 id="toc_30">29.2 接收系统broadcast：重启后唤醒</h4>

<ul>
<li><p>通过监听带有<code>BOOT_COMPLETED</code>操作的broadcast intent可以获知设备是否已完成启动；</p></li>
<li><p><strong>若要监听则需要创建并登记一个broadcast receiver；</strong></p>

<ul>
<li><strong>创建一个继承于android.content.BroadcastReceiver的子类，重写onReceive()方法；一旦收到intent，broadcast receiver的<code>onReceive(Context, Intent)</code>方法被调用，执行完毕后receiver被销毁；</strong></li>
<li><strong>并且在manifest文件中配置该receiver标签，其中包含相应的intent-filter以匹配相应的broadcast intent；</strong></li>
<li><strong>最后需添加相应的use-permission标签；</strong></li>
</ul>

<pre><code class="language-text">&lt;receiver android:name=&quot;.StartupReceiver&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre>

<pre><code class="language-text">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;
</code></pre></li>
<li><p>Android Device Monitor在KitKat之前被称为DDMS（Dalvik Debug Monitor Server）；</p>

<ul>
<li>在KitKat之前，Dalvik是Android上的运行时系统，自KitKat开始，Google又引入了ART（Android Runtime），到Lollipop时就只剩下ART可用；</li>
</ul></li>
<li><p><strong>broadcast receiver生命周期非常短暂，一旦onReceive(Context, Intent)方法在主线程上执行完，receiver就不存在了；其不适合做一些费时任务，但是可以做一些便利任务，比如启动activity或service（不需要等待返回结果的）、系统重启后重置定时运行的定时器；</strong></p></li>
</ul>

<h4 id="toc_31">29.3 过滤前台通知消息</h4>

<ul>
<li><p><strong>发送broadcast intent：</strong></p>

<ul>
<li><strong>发送自己定制的broadcast intent（比如发送broadcast通知目标部件有新的搜索结果消息了），只需要创建一个intent（intent构造使用自定义操作常量字符串），之后传入<code>sendBroadcast(Intent)</code>方法即可；</strong></li>
</ul></li>
<li><p><strong>接收处理broadcast intent：</strong></p>

<ul>
<li><p><strong>接收自定义的broadcast intent和接收系统的broadcast intent一样，都可以新建BroadcastReceiver子类，之后在manifest中进行登记；</strong></p>

<ul>
<li><p><strong>但是在manifest配置文件中声明的receiver会不分状态地接收intent（即不断地接收，无法根据相关对象是否存在而接收），动态broadcast receiver可以解决此问题；</strong></p></li>
<li><p><strong>动态broadcast receiver是在代码中，而不是在配置文件中进行登记声明；调用<code>registerReceiver(BroadcastReceiver, IntentFilter)</code>方法进行登记声明，调用<code>unregisterReceiver(BroadcastReceiver)</code>方法取消登记声明；</strong></p></li>
<li><p><strong>在registerReceiver()和unregisterReceiver()方法中的receiver要使用同一个实例变量；通常Receiver类型被声明成一个内部类实例；</strong></p></li>
</ul></li>
<li><p>任何使用XML定义的IntentFilter都可以以代码的方式定义，可以直接调用addCategory(String)、addAction(String)、addDataPath (String)等方法；</p>

<pre><code class="language-java">IntentFilter filter = new IntentFilter(PollService.ACTION_SHOW_NOTIFICATION);
getActivity().registerReceiver(mOnShowNotification, filter);
</code></pre></li>
<li><p><strong>动态登记的broadcast receiver要事后清理；通常在相对应的生命周期方法中进行登记、清理，比如onStart和onStop；</strong></p>

<pre><code class="language-java">getActivity().unregisterReceiver(mOnShowNotification);
</code></pre></li>
<li><p><strong>若在onCreate、onDestroy进行登记、清理，若此时使用保留fragment，设备旋转后，onCreate、onDestroy中的getActivity()的返回值不同，需要使用getActivity().getApplicationContext()方法；</strong></p></li>
</ul></li>
<li><p>使用私有权限限制broadcast</p>

<ul>
<li><strong>使用自定义broadcast intent默认存在一个问题，即系统中的任何应用均可<code>监听broadcast intent</code>、<code>触发broadcast receiver</code>；</strong></li>
<li><p>有多种方式可以阻止未授权应用：</p>

<ul>
<li><strong>a. 在manifest配置文件中给receiver标签添加一个<code>android:exported=&quot;false&quot;</code>属性，声明其仅供应用内部使用，这样系统中的其他应用就再也无法接触到该receiver；</strong></li>
<li><p><strong>b. 创建自己的使用权限（在manifest文件中使用<code>permission</code>标签创建），之后声明获取相应的使用权限（使用<code>uses-permission</code>标签）；即使是自定义的权限，也必须在使用这个权限前获取它；</strong></p>

<pre><code class="language-text">&lt;permission 
    android:name=&quot;com.bignerdranch.android.photogallery.PRIVATE&quot;
    android:protectionLevel=&quot;signature&quot; /&gt;
</code></pre>

<pre><code class="language-text">&lt;uses-permission android:name=&quot;com.bignerdranch.android.photogallery.PRIVATE&quot; /&gt;
</code></pre>

<ul>
<li><strong>之后，在sendBroadcast()时需要添该权限字符串参数，所有的应用都必须有该权限才能接收你发送的intent；</strong></li>
<li><p><strong>注意上面只解决了让其他应用不可以随意接收的问题，还有一个问题就是，其他应用可通过创建自己的broadcast intent来触发你的broadcast receiver；这个问题可以通过在registerReceiver()方法中传入自定义权限解决；</strong></p>

<pre><code class="language-java">getActivity().registerReceiver(
mOnShowNotification, filter, PollService.PERM_PRIVATE, null);
</code></pre></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>自定义权限必须指定<code>android:protectionLevel</code>属性值，Android根据该值确定自定义权限的使用方式；属性值有</p>

<ul>
<li>normal：用于阻止执行危险操作，如访问个人隐私数据等；不需要用户明确授权；</li>
<li>dangerous：用于执行危险操作；需要用户明确授权；</li>
<li>signature：使用和声明应用一致的证书则进行同意授权；授权由系统完成；</li>
<li>signatureOrSystem：类似于signature，一般用不到；</li>
</ul></li>
<li><p><strong><code>普通broadcast intent</code>可以同时被多个receiver接收，各个receiver执行顺序不确定；可以使用<code>有序broadcast intent</code>让多个broadcast receiver按照优先级依次处理broadcast intent；</strong></p></li>
<li><p><strong>调用context的<code>sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)</code>方法发送有序广播；</strong></p>

<ul>
<li>参数依次为intent、权限、result receiver、支持result receiver的handler、结果代码初始值、结果数据、结果附加内容；</li>
<li><strong>result receiver：在所有有序broadcast intent接收者结束运行后才开始执行；</strong></li>
</ul></li>
<li><p><strong>当broadcast receiver接收到广播后</strong></p>

<ul>
<li><strong>a. 可以使用<code>setResult()</code>将结果数据传给下一个broadcast receiver接收，然后通过<code>getResult()</code>取得上个broadcast receiver返回的结果数据；</strong></li>
<li><strong>b. 也可以用<code>abortBroadcast()</code>来让系统拦截该广播并将其丢弃，使该广播不再传送给别的broadcast receiver；</strong></li>
</ul></li>
<li><p><strong>设置结果数据，可以调用setResultCode(int)、setResultData(String)、setResultExtras(Bundle)、setResult(int, String, Bundle)等方法；</strong></p></li>
<li><p>broadcast receiver设置优先级，数值越大越先接收到broadcast intent；用户可以定义的最低优先级为-999，-1000及以下值为系统保留值；</p>

<pre><code class="language-text">&lt;receiver android:name=&quot;.NotificationReceiver&quot; android:exported=&quot;false&quot;&gt;
    &lt;intent-filter android:priority=&quot;-999&quot;&gt;
        &lt;action android:name=&quot;com.example.scott.photogallery.SHOW_NOTIFICATION&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre></li>
<li><p><strong>若广播中被优先级高的broadcast receiver接收到后被拦截，则之后的优先级低的broadcast receiver就不能接收到；若还需要一个不管有没有被拦截都能接收的broadcast receiver，则在调用sendOrderedBroadcast()方法时设置result receiver；</strong></p></li>
</ul>

<h4 id="toc_32">29.4 receiver与长时运行任务</h4>

<ul>
<li>若不想受限于主线程的时间限制，让broadcast intent触发一个长时间运行任务，有两种方法可以选择：

<ul>
<li>a. 将任务交给服务去处理，通过broadcast receiver启动服务（推荐方式）；服务可以运行很久，直到完成需要处理的任务；</li>
<li>b. 使用BroadcastReceiver.goAsync()方法；

<ul>
<li>该方法返回一个BroadcastReceiver.PendingResult对象，随后可使用该对象提供结果；</li>
<li>因此可以将PendingResult交给AsyncTask去执行长时间运行的任务，然后调用PendingResult的方法响应broadcast；</li>
<li>该方式不灵活，仍需要快速响应broadcast（10秒内）；优势是可以调用方法设置有序broadcast的结果；</li>
</ul></li>
</ul></li>
</ul>

<h4 id="toc_33">29.5 深入学习：本地事件</h4>

<ul>
<li><p><strong>broadcast intent可以实现系统内全局的消息传递，若仅需要应用内的消息事件广播，可以使用事件总线（event bus）</strong>；</p>

<ul>
<li><p>事件总线的设计思路就是提供一个应用内的部件可以订阅的共享总线或数据流；事件一旦发布到总线上，各订阅部件就会被激活并执行相应的回调代码；</p></li>
<li><p>EventBus就是一个第三方事件总线库，类似的还有Otto；也可以使用RxJava Subject和Observable来模拟事件总线；</p></li>
<li><p>为了实现在应用内发送broadcast intent，Android本身也提供了<code>LocalBroadcastManager</code>的广播管理类，但使用上第三方库更方便；</p></li>
</ul></li>
</ul>

<h4 id="toc_34">29.6 深入学习：探测fragment的状态</h4>

<ul>
<li><p>我们使用了全局性的broadcast机制实现PhotoGallery应用的broadcast通知功能；broadcast虽然是全局的，但利用定制权限实现限定broadcast intent只能在应用内接收；</p></li>
<li><p>不用本地broadcast机制，就是因为LocalBroadcastManager无法处理PhotoGallery应用中的这种broadcast通知；<strong>LocalBroadcastManager不支持有序broadcast，且不支持在独立线程上发送和接收broadcast；</strong></p></li>
</ul>

<h3 id="toc_35">第30章 网页浏览</h3>

<h4 id="toc_36">30.3 较难方式：使用WebView</h4>

<ul>
<li><p>打开网页有两种方式，一种是打开独立的浏览器（使用隐式intent），一种是使用WebView；</p>

<pre><code class="language-java">Intent intent = new Intent(Intent.ACTION_VIEW, url);
startActivity(intent);
</code></pre></li>
<li><p>WebView显示网页需要做三件事：</p>

<ul>
<li>1). 告诉WebView要打开的URL；</li>
<li>2). 启动JavaScript；默认是禁用的，不是必须启用；启用后，Android Lint会提示警告担心有跨域攻击，可使用@SuppressLint(&quot;SetJavaScriptEnabled&quot;)注解关闭警告；</li>
<li>3). 设置WebViewClient；（老版本系统，需要重写其shouldOverrideUrlLoading(WebView, String)方法并返回false）</li>
</ul>

<pre><code class="language-java">mWebView.getSettings().setJavaScriptEnabled(true);
mWebView.setWebViewClient(new WebViewClient());
mWebView.loadUrl(mUri.toString());
</code></pre>

<ul>
<li><p><strong>加载URL必须等webView配置完成后进行；</strong>可以调用<code>getSettings()</code>方法获取WebSetting实例，webSetting是修改WebView配置的三种途径之一；</p></li>
<li><p><strong>WebViewClient是一个事件接口，实现该接口可以响应各种渲染事件；比如可检测渲染器何时开始从指定URL加载图片等；</strong>该接口有多个方法可被实现，其中<code>shouldOverrideUrlLoading(WebView, String)</code>方法（已废弃）决定当有新的URL加载到WebView时（如点击某个链接）是否需要自己处理，true为自己处理，false为系统默认处理（会发送附有URL数据的隐式intent）；</p></li>
<li><p><strong>WebChromeClient也是一个事件接口，用来响应那些改变浏览器中装饰元素的事件；</strong>比如JavaScript警告信息、网页图标、状态条加载，以及当前网页标题的刷新；进度条、标题栏更新都有各自的回调方法，即<code>onProgressChanged(WebView, int)（从0到100的数值）</code>、 <code>onReceivedTitle(WebView, String)</code>方法；</p></li>
</ul></li>
</ul>

<h4 id="toc_37">30.4 处理WebView的设备旋转问题</h4>

<ul>
<li><p><strong>旋转设备屏幕，WebView重新加载了网页数据</strong>，这是因为WebView包含太多的数据，无法在onSaveInstanceState()方法内全部保存；也无法使用保留Fragment，WebView是视图层级的；</p></li>
<li><p><strong>对于一些类似的类（如VideoView），Android推荐让activity自身处理设备配置变更；也就是，无需销毁重建activity，就能直接调整自己的视图以适应新的屏幕尺寸；需要在AndroidManifest.xml配置文件中做如下配置：</strong></p>

<pre><code class="language-java">&lt;activity 
    android:name=&quot;.PhotoPageActivity&quot;
    android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot; /&gt;
</code></pre>

<ul>
<li><strong>上面的<code>android:configChanges</code>属性值，表示若因键盘开或关、屏幕方向改变、屏幕大小改变而发生设备配置更改，则activity自身处理配置更改；</strong></li>
</ul></li>
<li><p>activity自身处理配置变更也是有风险的，资源修饰符无法自动工作，需要手工重载视图；</p></li>
<li><p><strong>即使activity自身处理设备配置更改，onSavedInstanceState()方法存储UI状态依然是必需的，要考虑低内存情况；</strong></p></li>
</ul>

<h4 id="toc_38">30.7 挑战练习：使用后退键浏览历史网页</h4>

<ul>
<li>首先覆盖后退键方法<code>Activity.onBackPressed()</code>；在该方法内，再使用WebView的历史记录浏览方法<code>WebView.canGoBack()</code>、<code>WebView.goBack()</code>实现想要的浏览逻辑；</li>
</ul>

<h4 id="toc_39">30.8 挑战练习：非HTTP链接支持</h4>

<ul>
<li>WebViewClient总是让WebView尝试自己加载URI，即使是其不支持的URI scheme；</li>
</ul>

<h3 id="toc_40">第31章 定制视图与触摸事件</h3>

<h4 id="toc_41">31.2 创建定制视图</h4>

<ul>
<li><p>定制视图分为两大类别：</p>

<ul>
<li>简单视图：不包括子视图，几乎总是用来处理定制绘制；其内部也可以很复杂；</li>
<li>聚合视图：由其他视图对象组成，通常用来管理子视图，但不负责处理定制绘制，图形绘制任务都委托给了各个子视图；</li>
</ul></li>
<li><p>创建定制视图步骤：</p>

<ul>
<li>1). 选择超类；简单定制视图，使用View空白画布作为超类最常见；聚合定制视图，选择合适的超类布局，比如FrameLayout；</li>
<li>2). 继承选定的超类，覆盖超类的构造方法；</li>
<li>3). 覆盖其他关键方法，以定制视图行为；</li>
</ul></li>
</ul>

      </div>

      <div class="row">
        <div class="large-6 columns">
          <p class="text-left" style="padding:15px 0px;">
            
            <a href="15312301698124.html" title="Previous Post: Swift知识点总结">&laquo; Swift知识点总结</a>
            
          </p>
        </div>
        <div class="large-6 columns">
          <p class="text-right" style="padding:15px 0px;">
            
            <a href="15237039848080.html" title="Next Post: Android编程权威指南 笔记(19~24)">Android编程权威指南 笔记(19~24) &raquo;</a>
            
          </p>
        </div>
      </div>

      <div class="comments-wrap">
        <div class="share-comments">
            
        </div>
      </div>

    </div>
  </div> <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">

      <div id="site-info" class="site-info">
        
        <h1>TIME TO GO</h1>
        <div class="site-des">It is just a matter of time.</div>
        <div class="social">
                    
          <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
        </div>
      </div>

      

      <div id="site-categories" class="side-item ">
        <div class="side-header">
          <h2>Categories</h2>
        </div>
        <div class="side-content">
          <p class="cat-list">
            
          </p>
        </div>
      </div>

      <div id="site-categories" class="side-item">
        <div class="side-header">
          <h2>Recent Posts</h2>
        </div>
        <div class="side-content">
          <ul class="posts-list">
              <li class="post">
              <a href="15859991604863.html">多线程与GCD</a>
              </li>
                 <li class="post">
              <a href="15703760378326.html">NIB、XIB、StoryBoard与UIViewController、UIView</a>
              </li>
                 <li class="post">
              <a href="15626010144789.html">iOS状态栏</a>
              </li>
                 <li class="post">
              <a href="15622540495294.html">iOS屏幕方向</a>
              </li>
                 <li class="post">
              <a href="15590636648081.html">OpenCV配置使用</a>
              </li>
                                             
          </ul>
        </div>
      </div>

    </div>
  </div>
</div>

</div> <div class="page-bottom clearfix">
  <div class="row">
    <p class="copyright">Copyright &copy; 2015 Powered by
      <a target="_blank" href="">ME</a>
    </p>
  </div>
</div>
</section>

</div>
</div>

 
<script src="asset/js/foundation.min.js"></script>
<script>
  $(document).foundation();
  function fixSidebarHeight() {
    var w1 = $('.markdown-body').height();
    var w2 = $('#sidebar').height();
    if (w1 > w2) { $('#sidebar').height(w1); };
  }
  $(function () {
    fixSidebarHeight();
  })
  $(window).load(function () {
    fixSidebarHeight();
  });
</script>   
</body>

</html>