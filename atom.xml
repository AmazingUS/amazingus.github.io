<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[TIME TO GO]]></title>
  <link href="http://www.justisit.com/atom.xml" rel="self"/>
  <link href="http://www.justisit.com/"/>
  <updated>2018-04-10T23:58:51+08:00</updated>
  <id>http://www.justisit.com/</id>
  <author>
    <name><![CDATA[]]></name>
  </author>
  <generator uri="">ME</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Studio快捷键]]></title>
    <link href="http://www.justisit.com/15230908846113.html"/>
    <updated>2018-04-07T16:48:04+08:00</updated>
    <id>http://www.justisit.com/15230908846113.html</id>
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>KeyMap名称</th>
<th>功能描述</th>
<th>快捷键</th>
</tr>
</thead>

<tbody>
<tr>
<td>Navigate/Class</td>
<td>打开类</td>
<td>CMD(⌘,) + O</td>
</tr>
<tr>
<td>Navigate/File</td>
<td>打开文件</td>
<td>CMD + SHIFT(⇧) + O</td>
</tr>
<tr>
<td>Navigate/File</td>
<td>快捷最近打开</td>
<td>CMD + E</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Recent Files</td>
<td>提示错误解决方案<br>(自动导包、自动生成Override方法)</td>
<td>Option(alt,⌥) + Enter</td>
</tr>
<tr>
<td>Parameter Info</td>
<td>提示参数类型</td>
<td>CMD + P</td>
</tr>
<tr>
<td>Insert Live Template</td>
<td>按照模板生成代码（如TAG）</td>
<td>CMD + J</td>
</tr>
<tr>
<td>Reformat Code</td>
<td>格式化代码</td>
<td>CMD + ⌥ + L</td>
</tr>
<tr>
<td>Optimize Imports</td>
<td>去除无效包引用</td>
<td>Control(⌃) + ⌥ + O</td>
</tr>
<tr>
<td>Code Generate</td>
<td>快速生成代码</td>
<td>CMD + N</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Declaration</td>
<td>查看声明</td>
<td>CMD + B</td>
</tr>
<tr>
<td>Super method</td>
<td>跳转到父类</td>
<td>CMD + U</td>
</tr>
<tr>
<td>Type Hierarchy</td>
<td>显示继承体系</td>
<td>⌃ + H</td>
</tr>
<tr>
<td>Call hierarchy</td>
<td>查找调用位置</td>
<td>⌃ + ⌥ + H</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Edit/Find/Find</td>
<td>文件内查找</td>
<td>CMD + F</td>
</tr>
<tr>
<td>Move To Next Occurrence</td>
<td>代码高亮向下查找</td>
<td>CMD + G</td>
</tr>
<tr>
<td>Move To Previous Occurrence</td>
<td>代码高亮向上查找</td>
<td>CMD + ⇧ + G</td>
</tr>
<tr>
<td>Find in Path</td>
<td>全局查找</td>
<td>CMD + ⇧ + F</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Preferences</td>
<td>AS配置界面</td>
<td>CMD + ,</td>
</tr>
<tr>
<td>Project Structure</td>
<td>工程项目配置界面</td>
<td>CMD + ;</td>
</tr>
</tbody>
</table>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitBook使用教程]]></title>
    <link href="http://www.justisit.com/15219669294797.html"/>
    <updated>2018-03-25T16:35:29+08:00</updated>
    <id>http://www.justisit.com/15219669294797.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">一、简介</a>
</li>
<li>
<a href="#toc_1">二、安装使用</a>
</li>
<li>
<a href="#toc_2">三、补充</a>
</li>
</ul>


<h4 id="toc_0">一、简介</h4>

<ul>
<li>GitBook是一个可以将Markdown文本一键生成为HTML、PDF、EPUB格式图书（需要安装安装calibre）的工具，其也内置使用Git对Markdown文件做版本控制；</li>
<li>可以在本地离线生成各种格式的图书，也可以在GitBook官网在线生成，便于共享；并且其也提供了一键导入GitHub仓库生成图书的便捷功能（一本图书就是一个Git仓库）；</li>
</ul>

<span id="more"></span><!-- more -->

<h4 id="toc_1">二、安装使用</h4>

<ul>
<li><p>1、安装Node.js、Git（可选；若需要版本控制、上传到GitBook则要安装）；</p></li>
<li><p>2、安装GitBook；</p>

<pre><code>npm install -g gitbook-cli

gitbook -V # 查看当前GitBook版本（注意是大写的V）
</code></pre></li>
<li><p>3、创建一本图书（本地）；</p>

<pre><code>gitbook init BOOK_NAME
</code></pre>

<ul>
<li>目录中自动生成README.md、SUMMARY.md两个文件；这两个文件是必须存在的，README.md为对图书的介绍，SUMMARY.md是对书籍目录的描述，之后就是根据该文件生成图书目录结构的；</li>
<li><p>SUMMARY.md格式如如下：</p>

<pre><code># Summary

* [简介](README.md)
* [第一章 基础](chapter1/chapter1_0.md)
    * [第一小节 基础概述](chapter1/chapter1_1.md)
    * [第二小节 基础介绍](chapter1/chapter1_2.md)
* [第二章 进阶](chapter2/chapter2_0.md)
    * [第一小节 进阶概述](chapter2/chapter2_1.md)
    * [第二小节 进阶介绍](chapter2/chapter2_2.md)
</code></pre></li>
<li><p>手动修改SUMMARY.md后，再执行 <code>gitbook init</code> 命令，会自动生成相应的文件及目录；</p></li>
</ul></li>
<li><p>4、书写相关Markdown文本；</p></li>
<li><p>5、编译、预览图书；</p>

<pre><code>gitbook serve # 在图片文件夹目录中执行
</code></pre>

<ul>
<li><code>gitbook serve</code> 会先调用 <code>gitbook build</code> 命令编译图书，之后会打开一个本地WEB服务器，打开网页即可预览图书HTML；</li>
</ul></li>
<li><p>6、安装calibre工具，生成PDF、EPUB格式图书；</p>

<ul>
<li>a. 下载安装Calibre（<code>https://calibre-ebook.com/download</code>）；</li>
<li><p>b. 配置ebook-convert的路径；</p>

<pre><code>// macOS
sudo ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin  
</code></pre></li>
<li><p>c. 执行<code>gitbook pdf</code>、<code>gitbook epub</code>分别生成PDF、EPUB格式图书；</p></li>
</ul></li>
</ul>

<h4 id="toc_2">三、补充</h4>

<ul>
<li>第3、4步操作可以通过 <code>Gitbook Editor</code> 桌面编辑器更便捷地进行文本书写（其会自动更新修改SUMMARY.md文件）；但是生成图书还是需要在终端下通过GitBook完成；</li>
<li>可以使用 <code>book.json</code> 文件定义GitBook在编译图书时的配置信息（如定义图书名称、显示效果等）；</li>
<li>执行 <code>gitbook install</code> 命令可以安装一些第三方的插件，如disqus等；</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS的静态库、动态库]]></title>
    <link href="http://www.justisit.com/15210408337160.html"/>
    <updated>2018-03-14T23:20:33+08:00</updated>
    <id>http://www.justisit.com/15210408337160.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">一、类库分类</a>
</li>
<li>
<a href="#toc_1">二、类库类型支持</a>
</li>
<li>
<a href="#toc_2">三、设备CPU架构</a>
</li>
<li>
<a href="#toc_3">四、资源文件处理</a>
</li>
<li>
<a href="#toc_4">五、补充知识</a>
</li>
</ul>


<h4 id="toc_0">一、类库分类</h4>

<ul>
<li>静态库：

<ul>
<li>.a二进制库：使用时还需要将.h头文件及资源文件（比如图片等）拖入到工程项目中，配置一些header、lib路径之类的；使用起来比较麻烦；</li>
<li>.framework库：Apple平台独有的，其本质是将.a库文件、.h头文件及资源文件打包在一起的包文件；使用时直接将其拖到工程项目中即可（或在 <code>Link Binary With Libraries</code> 中添加即可使用）；</li>
</ul></li>
<li>动态库：

<ul>
<li>.tdb库：Xcode 7（iOS9）开始使用，之前名称为.dylib；在 <code>Link Binary With Libraries</code> 中添加即可使用；</li>
<li>.framework库文件：在 <code>Link Binary With Libraries</code> 中添加即可使用；</li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->

<h4 id="toc_1">二、类库类型支持</h4>

<ul>
<li><p>Xcode 6（iOS8）之前：</p>

<ul>
<li><p>出于安全考虑，Xcode只支持创建.a静态库（注意需要将相关的.h头文件public出来）；不支持创建.framework静态库，但是可以通过第三方工具创建（如iOS-Universal-Framework），这种被称为伪（Fake）Framework；</p></li>
<li><p>一般情况下都使用第三方工具创建.framework静态库，因为这样之后使用起来比.a形式更方便；</p></li>
<li><p>Xcode也不支持创建任何形式的动态库；</p></li>
<li><p>.tdb/.dylib动态库、.framework动态库都是系统内置的（如libz.dylib、UIKit.framework），故开发者只能使用系统内置的动态库；</p>

<p><img src="media/15210408337160/xcode_5.png" alt="xcode_5" style="width:311px;"/></p></li>
</ul></li>
<li><p>Xcode 6（iOS8）开始：</p>

<ul>
<li>Xcode支持创建.a静态库、.framework静态库（修改Mach-O Type，默认为动态库）；</li>
<li><p><strong>Xcode也支持创建.framework动态库了，但这是一种特殊的动态库（使用时需要被添加到 <code>Embedded Binaries</code> 中，并且默认自动添加到Link Binary With Libraries中）；其只支持主程序和扩展程序共用该动态库，其他应用还是无法进行公共，这和系统的（如UIKit.framework）还是有着很大区别的；</strong></p>

<p><img src="media/15210408337160/xcode_6.png" alt="xcode_6" style="width:300px;"/></p></li>
</ul></li>
<li><p><strong>Xcode 6（iOS8）发布了Swift 1.0，但是Swift不支持静态库（.a、.framework），只支持动态库（.tdb/.dylib、.framework）；从Xcode 9开始，Swift 4.0支持静态库；</strong></p></li>
<li><p>CocoaPods在纯ObjC项目中，默认将第三方库源码编译成.a静态库集成到项目中；若含有Swift的类库则必须添加 <code>use_frameworks!</code> 标识（纯ObjC项目中也可以使用的），进而生成.framework动态库；</p></li>
<li><p>Carthage只支持生成.framework动态库（原因：Carthage是通过Swift语言编写而成的），故其支持的项目最低版本为8.0；</p></li>
</ul>

<h4 id="toc_2">三、设备CPU架构</h4>

<ul>
<li><p>CPU架构</p>

<ul>
<li>a. 模拟器：iPhone 4s~5c为i386，iPhone 5s~...为x86_64；</li>
<li>b. 真机：iPhone 3gs~4s为armv7，iPhone 5~5c为armv7s，iPhone 5s~...为arm64；静态库只要支持armv7，就可以运行在armv7s架构上；</li>
</ul></li>
<li><p>生成库类型</p>

<ul>
<li>a. 通过修改Xcode编译的目标设备，可以分别生成模拟器、真机的库；</li>
<li>b. 通过修改Xcode编译的Scheme的config，可以分别生成Debug、Release的库；</li>
<li>c. Xcode在Debug、模拟器情况下，默认只会生成Active平台的CPU架构，比如生成的模拟器的库只有x86_64架构（通过 <code>lipo -info</code> 命令查看）；修改Build Settings的 <code>Build Active Architecture Only</code> 为No，则生成所有的CPU架构；真机情况下为armv7、arm64两种架构(armv7s被Apple舍弃了)；</li>
<li>d. 可以使用 <code>lipo -create</code> 命令合并相关的库文件；</li>
</ul></li>
<li><p>通用（合成）库类型</p>

<ul>
<li><strong>使用Xcode编译一次只会生成一种类型的库，可以使用 <code>Aggregate Target</code> 生成多种类型的合成库；</strong></li>
<li><p>新建 <code>Aggregate Target</code> ，添加 <code>Run Script</code> ，填入以下类似内容（参考<code>http://blog.csdn.net/qq_16706275/article/details/45913269</code>）：</p>

<pre><code># Sets the target folders and the final framework product.
# 如果工程名称和Framework的Target名称不一样的话，要自定义FMKNAME
# 例如: FMK_NAME = &quot;MyFramework&quot;
FMK_NAME=${PROJECT_NAME}

# Install dir will be the final output to the framework.
# The following line create it in the root folder of the current project.
INSTALL_DIR=${SRCROOT}/Products/${FMK_NAME}.framework

# Working dir will be deleted after the framework creation.
WRK_DIR=build
DEVICE_DIR=${WRK_DIR}/Release-iphoneos/${FMK_NAME}.framework
SIMULATOR_DIR=${WRK_DIR}/Release-iphonesimulator/${FMK_NAME}.framework

# -configuration ${CONFIGURATION}
# Clean and Building both architectures.
xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphoneos clean build
xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphonesimulator clean build

# Cleaning the oldest.
if [ -d &quot;${INSTALL_DIR}&quot; ]
then
rm -rf &quot;${INSTALL_DIR}&quot;
fi

mkdir -p &quot;${INSTALL_DIR}&quot;
cp -R &quot;${DEVICE_DIR}/&quot; &quot;${INSTALL_DIR}/&quot;

# Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.
lipo -create &quot;${DEVICE_DIR}/${FMK_NAME}&quot; &quot;${SIMULATOR_DIR}/${FMK_NAME}&quot; -output &quot;${INSTALL_DIR}/${FMK_NAME}&quot;

rm -r &quot;${WRK_DIR}&quot;
open &quot;${INSTALL_DIR}&quot;
</code></pre></li>
</ul></li>
</ul>

<h4 id="toc_3">四、资源文件处理</h4>

<ul>
<li><p>对于.a静态库</p>

<ul>
<li><p>a. 因为无法在.a文件中存放资源文件，需要将资源文件打包放在一个后缀为.bundle的文件夹中；</p></li>
<li><p>b. 使用时需要手动添加.bundle到主项目中，之后通过以下方式使用：</p>

<pre><code class="language-objc">[UIImage iamgeNamed:&quot;A.bundle/test.png&quot;];
</code></pre></li>
</ul></li>
<li><p>对于.framework静、动态库</p>

<ul>
<li><p>a. .framework文件本质上也是一个bundle文件；</p></li>
<li><p>b. 可以将资源文件直接（或打包成bundle后）放在.framework文件中，也可以将资源文件打包成bundle后与.framework文件独立开来；</p></li>
<li><p>c. <strong>需要注意的是：Xcode在添加.framework到项目中的时候，不会添加.framework中的资源文件到项目中（添加bundle会自动添加的），故无法其中的资源无法使用；必须在 <code>Copy Bundle Resources</code> 中添加对应的.framework</strong>，之后通过以下方式使用：</p>

<pre><code class="language-objc">// .framework中直接包含图片
[UIImage iamgeNamed:&quot;A.framework/test.png&quot;]
// .framework中还有bundle，bundle中包含图片
[UIImage iamgeNamed:&quot;A.framework/A.bundle/test.png&quot;]

// 路径
[[NSBundle mainBundle] pathForResource:@&quot;a.framework/a.bundle/test.png&quot; ofType:nil];
</code></pre></li>
<li><p>d. 一般情况下，建议将资源文件和framework分开使用；（参考<code>http://www.cocoachina.com/bbs/read.php?tid-1676834-page-2.html</code> 、<code>http://www.cnblogs.com/mylizh/p/3971428.html</code>）</p></li>
</ul></li>
<li><p>注意： </p>

<ul>
<li><p><strong>a. 对于无xib的资源可以直接新建文件夹后，修改后缀名为.bundle即可手动创建bundle文件；Bundle是静态的，故手动创建bundle文件的内部资源文件无法被编译；</strong></p></li>
<li><p>b. 对于有xib的资源，需要新建Bundle Target（选择macOS的Bundle Target，之后修改Build Setting -&gt; Base SDK为iOS；iOS没有该类型的Target），将xib添加到该Target后，编译运行将xib文本文件编译成nib二进制文件，最终创建bundle文件；</p></li>
<li><p>c. nib与xib的区别：nib是二进制文件，xib是xml文本文件，xib是用来替代nib的；当程序编译时将xib编译序列化（调用encodeWithCoder方法）为nib，使用时将nib反序列化（调用initWithCoder方法）为xib；</p></li>
</ul></li>
</ul>

<h4 id="toc_4">五、补充知识</h4>

<ul>
<li><p><strong>若需要边开发边调试类库：在现有工程中添加一个库Lib Target，设置一些相关配置（默认情况下自动添加，比如主Target的Build Phases的Target Dependencies添加lib Target、Embedded Binaries添加Lib、Link Binary With Libraries添加Lib、Public头文件、Copy Bundle Resources等），之后就可以进行调试；</strong></p></li>
<li><p>若静态库中使用了分类，则在使用时需要在 <code>other linker flags</code> 中增加 <code>-ObjC</code> 配置，否则报<code>selector not recognized</code>运行时错误；</p></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift和ObjC混合编程]]></title>
    <link href="http://www.justisit.com/15206830265209.html"/>
    <updated>2018-03-10T19:57:06+08:00</updated>
    <id>http://www.justisit.com/15206830265209.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">一、Swift调用ObjC</a>
</li>
<li>
<a href="#toc_1">二、ObjC调用Swift</a>
</li>
<li>
<a href="#toc_2">三、Swift项目使用ObjC Pods</a>
</li>
<li>
<a href="#toc_3">四、ObjC项目使用Swift Pods</a>
</li>
<li>
<a href="#toc_4">五、Swift调用C、C++</a>
</li>
</ul>


<h5 id="toc_0">一、Swift调用ObjC</h5>

<ul>
<li>实现步骤：

<ul>
<li>1、新建Swift项目；</li>
<li>2、新建ObjC文件，比如ObjCUtil.h/m；

<ul>
<li>a. 此时Xcode会提示是否自动创建Bridge头文件（文件名称为<code>#ProjectName#-Bridging-Header.h</code>），选择自动创建；</li>
<li>b. 也可以手动创建Bridge头文件，只需修改&quot;Build Setting&quot;中的&quot;Objective-C Briding Header&quot;即可；</li>
</ul></li>
<li>3、在Bridge头文件中，进行<code>#import &quot;ObjC文件.h&quot;</code>，之后即可在Swift调用ObjC了；</li>
<li>4、新建一个Swift文件（不必继承NSObject）用于测试，比如SwiftTest.swift；</li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->       

<ul>
<li><p>示例代码</p>

<pre><code>// ObjCUtil.h
#import &lt;Foundation/Foundation.h&gt;

@interface ObjCUtil : NSObject

+ (void)sayClassMethod;
- (void)sayObjectMethod;

@end

// ObjCUtil.m
#import &quot;ObjCUtil.h&quot;

@implementation ObjCUtil

+ (void)sayClassMethod {
    NSLog(@&quot;%s&quot;, __func__);
}

- (void)sayObjectMethod {
    NSLog(@&quot;%s&quot;, __func__);
}

@end
</code></pre>

<pre><code class="language-Obj-C">// SwiftUseObjC-Bridging-Header.h
#import &quot;ObjCUtil.h&quot;
</code></pre>

<pre><code class="language-swift">// SwiftTest.swift
import Foundation

class SwiftTest { // 不必继承NSObject

    static func test() -&gt; Void {
        ObjCUtil.sayClassMethod()

        let objCUitl = ObjCUtil()
        objCUitl.sayObjectMethod()
    }

}
</code></pre></li>
</ul>

<h5 id="toc_1">二、ObjC调用Swift</h5>

<ul>
<li><p>实现步骤：</p>

<ul>
<li>1、新建ObjC项目；</li>
<li><p>2、新建一个Swift文件（必须继承NSObject），比如SwiftUtil.swift；</p>

<ul>
<li><p>a. 在选择Xcode自动创建Bridge头文件的同时，Xcode还会<strong>自动隐式创建</strong><code>#ProjectName#-Swift.h</code>，用于ObjC调用Swift；该文件中的内容为Xcode动态生成的，不需要编辑；</p>

<p><img src="media/15206830265209/Xcode_config.png" alt="Xcode_config" style="width:676px;"/></p></li>
<li><p>b. 若要将Swift类暴露给ObjC使用，则Swift类必须是NSObject的子类；</p></li>
<li><p><strong>c. 从Swift4.0开始，Swift类中的方法必须显示添加@objc修饰符（Swift3.0不需要），否则ObjC无法识别；可以通过设置&quot;Build Setting&quot;中的&quot;Swift 3 @objc inference&quot;决定是否使用新特性；</strong></p>

<p><img src="media/15206830265209/@objc.png" alt="@obj" style="width:489px;"/></p></li>
</ul></li>
<li><p>3、在需要Swift类的ObjC文件中，进行<code>#ProjectName#-swift.h</code>，即可在ObjC调用Swift了；</p></li>
<li><p>4、新建ObjC文件用于测试，比如ObjCTest.h/m；</p></li>
</ul></li>
<li><p>示例代码</p>

<pre><code class="language-swift">// SwiftUtil.swift
import UIKit

class SwiftUtil: NSObject { // 必须继承NSObject

    @objc func sayObjectMethod() -&gt; Void {
        print(&quot;file: \(#file), func: \(#function), lines: \(#line)&quot;)
    }

    @objc static func sayClassMethod() -&gt; Void {
        print(&quot;file: \(#file), func: \(#function), lines: \(#line)&quot;)
    }

}
</code></pre>

<pre><code>// ObjCTest.h
#import &lt;Foundation/Foundation.h&gt;

@interface ObjCTest : NSObject

+ (void)test;

@end

// ObjCTest.m
#import &quot;ObjCTest.h&quot;
#import &quot;ObjCUseSwift-Swift.h&quot;

@implementation ObjCTest

+ (void)test {
    [SwiftUtil sayClassMethod];

    SwiftUtil *swiftUtil = [[SwiftUtil alloc] init];
    [swiftUtil sayObjectMethod];
}

@end
</code></pre></li>
</ul>

<h5 id="toc_2">三、Swift项目使用ObjC Pods</h5>

<ul>
<li><p>Swift项目中可以直接使用ObjC Pods（不需要在Bridge头文件中进行#import），在使用的地方直接<code>imprort 模块名</code>即可，比如<code>import PureLayout</code>；</p>

<pre><code class="language-ruby"># Podfile
project &#39;SwiftObjCPods.xcodeproj&#39;
platform :ios, &#39;11.0&#39;

target &#39;SwiftObjCPods&#39; do
  use_frameworks!

  # Pods for SwiftObjCPods
  pod &#39;Alamofire&#39;, &#39;~&gt; 4.7&#39;
  pod &#39;PureLayout&#39;

end
</code></pre>

<pre><code class="language-swift">import UIKit
import Alamofire
import PureLayout

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()

        let view = UIView()
        self.view.addSubview(view)
        view.backgroundColor = .red
        view.autoCenterInSuperview()
        view.autoSetDimensions(to: CGSize(width: 100, height: 100))
    }

    override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {
        Alamofire.request(&quot;https://www.baidu.com/&quot;).responseString { (response) in
            debugPrint(response)
        }
    }

}
</code></pre></li>
</ul>

<h5 id="toc_3">四、ObjC项目使用Swift Pods</h5>

<ul>
<li>一般无法直接使用Swift Pods，需要定义一个Swift中介文件；通过中介文件调用Swift Pods，ObjC项目再调用中介文件；</li>
<li><p>ObjC项目的Podfile文件若使用Swift Pods，则必须使用<code>use_frameworks!</code>（Cocoapods 1.4.0还不支持Swift静态库）；</p>

<pre><code class="language-ruby"># Podfile
project &#39;ObjCSwiftPods.xcodeproj&#39;
platform :ios, &#39;11.0&#39;

target &#39;ObjCSwiftPods&#39; do
    use_frameworks! # 必须使用

  # Pods for ObjCSwiftPods
    pod &#39;PureLayout&#39;
    pod &#39;Alamofire&#39;, &#39;~&gt; 4.7&#39;

end
</code></pre>

<pre><code class="language-swift">// Swift中介文件
import Foundation
import Alamofire

class NetworkingUitl : NSObject {

    @objc class func request() -&gt; Void {
        Alamofire.request(&quot;https://www.baidu.com/&quot;).responseString { (response) in
            debugPrint(response)
        }
    }
}
</code></pre>

<pre><code class="language-obj-c">#import &quot;ViewController.h&quot;
#import &lt;PureLayout/PureLayout.h&gt;
#import &quot;ObjCSwiftPods-Swift.h&quot;

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    UIView *view = [[UIView alloc] init];
    [self.view addSubview:view];
    view.backgroundColor = [UIColor redColor];
    [view autoCenterInSuperview];
    [view autoSetDimensionsToSize:CGSizeMake(100, 100)];
}

- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    [NetworkingUitl request];
}

@end
</code></pre></li>
</ul>

<h5 id="toc_4">五、Swift调用C、C++</h5>

<ul>
<li>Swift无法直接调用C、C++，其可以通过Swift调用ObjC，ObjC再调用C、C++，间接完成Swift调用C、C++；</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Carthage使用教程]]></title>
    <link href="http://www.justisit.com/15147939316129.html"/>
    <updated>2018-01-01T16:05:31+08:00</updated>
    <id>http://www.justisit.com/15147939316129.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">一、概述、安装</a>
</li>
<li>
<a href="#toc_1">二、使用</a>
</li>
<li>
<a href="#toc_2">三、其他说明</a>
</li>
</ul>


<h4 id="toc_0">一、概述、安装</h4>

<ul>
<li>Carthage类似于CocoaPods，用于iOS、macOS等平台的第三方框架的管理；其原理为将源代码编译成<strong>Dynamic framework（Xcode 6.0开始支持；Carthage是基于Swift的，Swift只支持Dynamic framework）</strong>，之后手动拖入到项目中；其对项目工程文件的入侵性较小，并且可以与CocoaPods无缝集成，一个项目可以同时拥有CocosPods和Carthage；</li>
<li><p>可以通过Homebrew进行安装Carthage；</p>

<pre><code># 安装carthage（安装升级carthage，注意可能出现多版本共存bug）
brew install carthage

carthage version  # 查看安装的版本
</code></pre></li>
</ul>

<span id="more"></span><!-- more -->

<h4 id="toc_1">二、使用</h4>

<ul>
<li><p>1、在项目根目录更加一个名称为Cartfile的文件，其作用和Podfile一样，描述所需要的第三方框架；</p>

<pre><code>touch Cartfile
open -a Xcode Cartfile  # 使用Xcode打开编辑

# Cartfile内容（可以像Podfile一样指定库的版本）
github &quot;Alamofire/Alamofire&quot; == 4.7.0  
github &quot;PureLayout/PureLayout&quot;
</code></pre></li>
<li><p>2、执行更新命令，生成framework文件；</p>

<pre><code>carthage update --platform iOS # 只生成iOS平台的framework
</code></pre>

<p>执行完成后，会生成以下文件目录结构：</p>

<ul>
<li><p>Carfile.resolved用于版本控制；Build目录为生成的Dynamic framework；Checkouts为从github上clone的源代码；</p>

<p><img src="media/15147939316129/carthage_files.png" alt="carthage_files" style="width:684px;"/></p></li>
</ul></li>
<li><p>3、添加Dynamic framework到项目中；</p>

<ul>
<li><p><strong>方式一：Embedded Binaries（不建议使用）</strong></p>

<p><img src="media/15147939316129/embedded_binaries.png" alt="embedded_binaries" style="width:672px;"/></p>

<ul>
<li><strong>a. 由于是生成的是Dynamic framework，可以手动直接添加framework到General或Build Phase界面的&quot;Embedded Binaries&quot;中，之后就可以直接使用；</strong></li>
<li><strong>b. 添加了&quot;Embedded Binaries&quot;后，&quot;Link Binary With Libraries&quot;中会自动添加上面手动添加的framework；</strong></li>
<li><strong>c. 若只是仅仅手动添加framework到&quot;Link Binary With Libraries&quot;，则该framework只能是Static Framework，不可以为Dynamic framework；</strong></li>
<li><strong>d. 手动拖拽framework，只会添加framework到&quot;Link Binary With Libraries&quot;中；</strong></li>
</ul></li>
<li><p><strong>方式二：Link Binary With Libraries + Run Script；</strong></p>

<ul>
<li><p><strong>a. 添加添加framework到&quot;Link Binary With Libraries&quot;后，在Build Phase界面点击左上角+按钮，添加一个Run Script，并做以下配置；</strong></p>

<p><img src="media/15147939316129/carthage_run_script.png" alt="carthage_run_script" style="width:491px;"/></p>

<ul>
<li><strong>a) 添加命令：<code>usr/local/bin/carthage copy-frameworks</code></strong></li>
<li><p><strong>b) Input Files中添加每一个framework的输入路径（注意避免空格换行符），比如：</strong></p>

<pre><code>$(SRCROOT)/Carthage/Build/iOS/Alamofire.framework
$(SRCROOT)/Carthage/Build/iOS/PureLayout.framework
</code></pre></li>
<li><p><strong>c)（可选，建议配置）Output Files中添加每一个framework的输出路径，比如：</strong></p>

<pre><code>$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/Alamofire.framework
$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/PureLayout.framework
</code></pre></li>
</ul></li>
<li><p><strong>b. <code>carthage copy-frameworks</code>命令的作用</strong></p>

<ul>
<li><strong>a) 拷贝Dynamic framework，进而不需要在手动添加到&quot;Embedded Binaries&quot;中了；</strong></li>
<li><strong>b)（最重要）裁减Dynamic framework；</strong>

<ul>
<li><strong>Carthage生成的Dynamic framework是包含模拟器和真机平台的，而App Store提交的包内不可以有没有用到的平台的代码（模拟器的），使用该脚本就是自动将无用代码去除；（<code>http://ikennd.ac/blog/2015/02/stripping-unwanted-architectures-from-dynamic-libraries-in-xcode/</code>）</strong></li>
<li><strong>为了优化编译速度，添加Output Files路径，这样只有在Input Files中的文件修改了或Output Files中的文件丢失的情况下，才会执行命令，否则每次运行都会去执行；（详情查看<code>https://github.com/Carthage/</code>）</strong></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h4 id="toc_2">三、其他说明</h4>

<ul>
<li>若更新了Cartfile文件（库的版本、增删库），则只需要重新执行 <code>carthage update</code> 命令即可；</li>
<li><strong>注意：不要直接删除Xcode Simulator的文件目录(<code>~/Library/Developer/CoreSimulator/Devices/</code>)</strong>；

<ul>
<li>若需要删除，可以通过<code>Xcode-&gt;Window-&gt;Devices and Simulators</code>进行删除；</li>
<li><strong>直接删除可能导致执行xcodebuild命令失败，报错<code>xcodebuild: error: Unable to find a destination matching the provided destination specifier: { platform:iOS Simulator, id:</code>，进而导致执行 <code>carthage update</code> 命令失败</strong>；</li>
<li>解决出现上面的问题，需要将所有模拟器手动删除后再新建一些模拟器可以；</li>
</ul></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语法概要(07~08)]]></title>
    <link href="http://www.justisit.com/15147467512006.html"/>
    <updated>2018-01-01T02:59:11+08:00</updated>
    <id>http://www.justisit.com/15147467512006.html</id>
    <content type="html"><![CDATA[<h4 id="toc_0">一、扩展(extension)、协议(protocal)</h4>

<h4 id="toc_1">二、泛型(generic)、访问控制</h4>

<span id="more"></span><!-- more -->

<p><img src="media/15147467512006/%E6%A6%82%E8%A6%81-%E4%B8%83-.svg" /></p>

<p><img src="media/15147467512006/%E6%A6%82%E8%A6%81-%E5%85%AB-.svg" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语法概要(05~06)]]></title>
    <link href="http://www.justisit.com/15147467504421.html"/>
    <updated>2018-01-01T02:59:10+08:00</updated>
    <id>http://www.justisit.com/15147467504421.html</id>
    <content type="html"><![CDATA[<h4 id="toc_0">一、继承、构造</h4>

<h4 id="toc_1">二、析构、类型检查及转换、异常</h4>

<span id="more"></span><!-- more -->

<p><img src="media/15147467504421/%E6%A6%82%E8%A6%81-%E4%BA%94-.svg" /></p>

<p><img src="media/15147467504421/%E6%A6%82%E8%A6%81-%E5%85%AD-.svg" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语法概要(03~04)]]></title>
    <link href="http://www.justisit.com/15147467488941.html"/>
    <updated>2018-01-01T02:59:08+08:00</updated>
    <id>http://www.justisit.com/15147467488941.html</id>
    <content type="html"><![CDATA[<h4 id="toc_0">一、结构体(值类型)、类(引用类型)</h4>

<h4 id="toc_1">二、枚举(值类型)、其他</h4>

<span id="more"></span><!-- more -->

<p><img src="media/15147467488941/%E6%A6%82%E8%A6%81-%E4%B8%89-.svg" /></p>

<p><img src="media/15147467488941/%E6%A6%82%E8%A6%81-%E5%9B%9B-.svg" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语法概要(01~02)]]></title>
    <link href="http://www.justisit.com/15142060028487.html"/>
    <updated>2017-12-25T20:46:42+08:00</updated>
    <id>http://www.justisit.com/15142060028487.html</id>
    <content type="html"><![CDATA[<h4 id="toc_0">一、基本概念、基础类型(值类型)、控制流</h4>

<h4 id="toc_1">二、函数、闭包(引用类型)</h4>

<span id="more"></span><!-- more -->

<p><img src="media/15142060028487/%E6%A6%82%E8%A6%81-%E4%B8%80-.svg" /></p>

<p><img src="media/15142060028487/%E6%A6%82%E8%A6%81-%E4%BA%8C-.svg" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3爬虫总结]]></title>
    <link href="http://www.justisit.com/15129255415379.html"/>
    <updated>2017-12-11T01:05:41+08:00</updated>
    <id>http://www.justisit.com/15129255415379.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">一、URI、URL</a>
</li>
<li>
<a href="#toc_1">二、urllib库</a>
</li>
<li>
<a href="#toc_2">三、URLError、HTTPError</a>
</li>
<li>
<a href="#toc_3">四、设置header、timeout</a>
</li>
<li>
<a href="#toc_4">五、Opener、Handler</a>
<ul>
<li>
<a href="#toc_5">5.1 HTTPBasicAuthHandler</a>
</li>
<li>
<a href="#toc_6">5.2 ProxyHandler</a>
</li>
<li>
<a href="#toc_7">5.3 HTTPRedirectHandler</a>
</li>
<li>
<a href="#toc_8">5.4 HTTPCoookieProcessor</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">六、实战</a>
</li>
</ul>


<h4 id="toc_0">一、URI、URL</h4>

<ul>
<li>URI（Universal Resource Identifier）：统一资源标识符，一种语义上的抽象概念；可以是绝对的，也可以是相对的</li>
<li>URL（Uniform Resource Locator）：统一资源定位符，一种具体的绝对的URI，是URI的一个子集；不仅唯一标识资源，而且还提供足够的信息定位该资源的信息</li>
</ul>

<h4 id="toc_1">二、urllib库</h4>

<ul>
<li><p>Python 2.x中有urllib、urllib2两个HTTP请求模块；urllib2是urllib的增强，但urllib中有urllib2中所没有的函数，它们一起搭配使用、不可相互替代</p>

<ul>
<li><p>a). urllib仅仅可以接受url，不可以设置请求的headers，意味着不可以进行伪装“User Agent”等操作</p></li>
<li><p>b). urllib2可以通过接受一个Request实例，来设置HTTP请求的headers</p></li>
<li><p>c). urllib提供urlencode函数用来“拼接”请求参数字符串</p></li>
<li><p>d). urllib2没有“拼接”请求参数字符串功能的函数；</p></li>
<li><p>urlencode函数是将一个dit或一个含有两个元素tuple的list变成一个url查询字符串（如name=Tom&amp;age=12)，并不是进行字符编码</p></li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->

<ul>
<li><p>Python 3.x中urllib和urilib2两个模块统一合并成了urllib模块，其中urllib2被修改为urllib.request</p>

<ul>
<li><p>a). urllib.urlencode()变成了urllib.parse.urlencode()</p></li>
<li><p>b). urllib2.urlopen()变成了urllib.request.urlopen()</p></li>
<li><p>c). urllib2.Request()变成了urllib.request.Request()</p></li>
</ul>

<pre><code class="language-python">from urllib import request, parse

# 方式1: 使用url（GET）
url = &#39;http://www.baidu.com/&#39;
with request.urlopen(url) as f:
    print(f.getheaders())

# 方式2: 使用Request对象(可添加Header)（GET）
url = &#39;http://www.baidu.com/&#39;
req = request.Request(url)
with request.urlopen(req) as f:
    print(f.getheaders())

# 方式3: 使用url、拼接查询字符串（GET）
d = {&#39;name&#39;: &#39;Tom&#39;, &#39;age&#39;: 12}
l = [(&#39;name&#39;, &#39;Tom&#39;), (&#39;age&#39;, 12)]
# urlencode将一个dit或一个含有两个元素tuple的list变成一个url查询字符串
data = parse.urlencode(d)
url = &#39;http://www.baidu.com/&#39; + &#39;?&#39; + data  
with request.urlopen(url) as f:
    print(f.getheaders())

# 方式4: 使用url、设置data参数（POST）
d = {&#39;name&#39;: &#39;Tom&#39;, &#39;age&#39;: 12}
data = parse.urlencode(d)
data = data.encode(&#39;utf-8&#39;)
url = &#39;http://www.baidu.com/&#39;
with request.urlopen(url, data=data) as f:
    print(f.getheaders())

# 方式5: 使用Request对象、设置data参数（POST）
d = {&#39;name&#39;: &#39;Tom&#39;, &#39;age&#39;: 12}
data = parse.urlencode(d)
data = data.encode(&#39;utf-8&#39;)
url = &#39;http://www.baidu.com/&#39;
req = request.Request(url, data=data)
with request.urlopen(req) as f:
    print(f.getheaders())

# mothod参数可以指定请求类型，比如GET/POST/HEAD/DELETE/PUT
req = request.Request(&#39;http://www.baidu.com/&#39;, method=&#39;PUT&#39;)
with request.urlopen(req) as f:
    print(f.getheaders())

# HTTPResponse对象的常见方法
print(f)  # &lt;http.client.HTTPResponse object at 0x101f56940&gt;
print(f.getheaders()) # 响应headers
print(f.info()) # 响应headers（字典形式）
print(f.geturl())  # 最终的url（可能会重定向）
print(f.getcode()) # 响应码 （若请求异常，则需从HTTPError对象中获取code属性）
</code></pre></li>
</ul>

<h4 id="toc_2">三、URLError、HTTPError</h4>

<ul>
<li><p>URLError是HTTPError的父类；URLError有reason属性，HTTPError既有reason属性，也有code属性</p>

<pre><code class="language-python">from urllib import request, error

# Error处理方式1:
try:
    # url = &#39;h://home.baidu.com&#39;
    url = &#39;http://home.baidu.com/x&#39;
    with request.urlopen(url) as f:  # with ... as语句简化写finally语句
        print(f.getheaders())
except error.HTTPError as e:
    print(&quot;【HTTPError】:&quot;, e)
    print(&quot;【HTTPError】, code:&quot;, e.reason)
except error.URLError as e:
    print(&quot;【URLError】:&quot;, e)
    print(&quot;【URLError】, reason:&quot;, e.reason)
else:
    print(&#39;else...&#39;)

# Error处理方式2:
try:
    # url = &#39;h://home.baidu.com&#39;
    url = &#39;http://home.baidu.com/x&#39;
    with request.urlopen(url) as f:
        print(f.getheaders())
except error.URLError as e:
    if hasattr(e, &#39;code&#39;):
        print(&quot;【HTTPError】:&quot;, e)
        print(&quot;【HTTPError】, code:&quot;, e.code)
    elif hasattr(e, &#39;reason&#39;):
        print(&quot;【URLError】:&quot;, e)
        print(&quot;【URLError】, reason:&quot;, e.reason)
else:
    print(&#39;else...&#39;)
</code></pre></li>
</ul>

<h4 id="toc_3">四、设置header、timeout</h4>

<ul>
<li>request的Content-Type（通常用于表单提交）有两种：application/x-www-form-urlencoded（没有附件上传的表单）、multipart/form-data（有附件上传的表单）</li>
<li>response的Content-Type通常是text/html、application/json、application/json</li>
<li><p>某些网站的简单“反盗链”设置，就检查request header的 <code>referer</code> 字段的值是不是该网站自身，若不是则认为“被盗链”了；应对“反盗链”只需将referer的值设置为当前请求的网站即可</p>

<pre><code class="language-python"># timeout设置方式1: 全局timeout(设置socket)
import  socket
socket.setdefaulttimeout(0.25)

# timeout设置方式2: urlopen函数设置timeout参数
from urllib import request, error

req = request.Request(&#39;http://www.google.com/&#39;)
req.add_header(&#39;User-Agent&#39;, &#39;iOS&#39;)  # 浏览器类型

try:
    with request.urlopen(req, timeout=0.25) as f:
        print(f.getheaders())
except error.HTTPError as e:
    print(&quot;【HTTPError】:&quot;, e)
    print(&quot;【HTTPError】, code:&quot;, e.code)
except error.URLError as e:
    print(&quot;【URLError】:&quot;, e)
    print(&quot;【URLError】, reason:&quot;, e.reason)
else:
    print(&#39;else...&#39;)
</code></pre></li>
</ul>

<h4 id="toc_4">五、Opener、Handler</h4>

<ul>
<li><strong>urllib.request.urlopen()本质是使用一个默认创建的Opener对象去发送网络请求，但其不支持验证、cookie、其他HTTP高级功能</strong>

<ul>
<li><strong>若要支持上述高级那些功能，必须使用build_opener()函数创建自定义的Opener对象；build_opener()函数的参数为Handlers，返回为Opener对象；若不传入Handlers参数，则Opener对象会被默认添加一些Hanlder</strong></li>
<li>Opener对象也可通过add_handler()方法手动添加Handler</li>
<li>Opener对象具有open()方法，和request的urlopen()方法的功能一样，也支持通过addHeaders()方法设置headers</li>
<li>可以将某个Opener对象装载变为全局的（调用request.install_opener(opener)方法），之后使用request.urlopen()就是使用该Opener对象去发送请求</li>
</ul></li>
<li>HTTPBasicAuthHandler是处理WWW-Authenticate的Handler，ProxyHandler是处理代理的Handler，HTTPRedirectHandler是处理重定向的Handler（需要子类），HTTPCoookieProcessor是处理Cookies的Handler，等等</li>
</ul>

<h5 id="toc_5">5.1 HTTPBasicAuthHandler</h5>

<ul>
<li>WWW-Authenticate是早期的一种简单身份认证技术，通常用在嵌入式领域（如早期的家用路由器的登录）或者一些需要简单认证的应用（如Tomcat的Application管理的登录）；该认证采用的用户名密码的加密方式为Base64（即明码传输），验证简单容易被破解</li>
<li>WWW-Authenticate认证过程：

<ul>
<li>1). 客户端浏览器向服务端发送HTTP请求（比如192.168.1.1）</li>
<li>2). 服务端收到请求，解析请求的header，判断是否有 <code>Authorization: Basic XXXX</code> 字段；若没有，则服务器的响应的header设置 <code>WWW-Authenticate: Basic realm=&quot;YYYY&quot;</code>（要求客户端发送用户名密码到服务端）</li>
<li>3). 当客户端浏览器收到响应的header中含有 <code>WWW-Authenticate: Basic realm=&quot;YYYY&quot;</code> 时，会弹出对话框要求用户输入相关信息</li>
<li>4). 用户输入相关信息后，客户端将发送含有 <code>Authorization: Basic XXXX</code> 请求给服务器进行认证</li>
</ul></li>
<li><p>验证WWW-Authenticate认证</p>

<pre><code class="language-python">
# 1. 环境准备：安装Tomcat，修改文件权限，修改tomcat-users.xml，启动服务器
    a. 修改文件权限：sudo chmod 755 xxx/bin/*.sh
    b. 修改tomcat-users.xml：增加如下内容
      &lt;role rolename=&quot;manager-gui&quot;/&gt;
      &lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui&quot;/&gt;
</code></pre>

<pre><code class="language-python"># 2. 验证
from urllib import request

# a. 不使用HTTPBasicAuthHandler，访问失败
url = &#39;http://127.0.0.1:8080/manager/html&#39;  
with request.urlopen(url) as f:
    print(f.getheaders())

# b. 使用HTTPBasicAuthHandler，访问成功
top_url = &#39;http://127.0.0.1:8080/&#39;
password_mgr = request.HTTPPasswordMgrWithDefaultRealm()
password_mgr.add_password(None, top_url, &#39;tomcat&#39;, &#39;tomcat&#39;)  # 注意要设置域
# 创建一个handler
handler = request.HTTPBasicAuthHandler(password_mgr=password_mgr) 

# 创建一个opener
# 方式1:
# opener = request.build_opener(handler)  
# 方式2:
opener = request.build_opener()
opener.add_handler(handler)

opener.addheaders = [(&#39;User-Agent&#39;, &#39;Mozilla/5.0&#39;)]  # 设置请求头

url = &#39;http://127.0.0.1:8080/manager/html&#39;
with opener.open(url) as f:
    print(f.getheaders())
</code></pre></li>
</ul>

<h5 id="toc_6">5.2 ProxyHandler</h5>

<ul>
<li><p>设置HTTP代理</p>

<pre><code class="language-python">from urllib import request

# a. 不使用代理
url = &#39;http://ip.chinaz.com/getip.aspx&#39;
with request.urlopen(url) as f:
print(f.read().decode(&#39;utf-&#39;))
# {ip:&#39;111.196.84.186&#39;,address:&#39;北京市 联通&#39;}

# b. 使用代理
handler = request.ProxyHandler({&#39;http&#39;: &#39;124.88.67.21:843&#39;})

opener = request.build_opener(handler)

url = &#39;http://ip.chinaz.com/getip.aspx&#39;
with opener.open(url) as f:
print(f.read().decode(&#39;utf-8&#39;))
# {ip:&#39;124.88.67.21&#39;,address:&#39;新疆乌鲁木齐市 联通&#39;}

# c. 使用代理，并进行认证（两个Handler）
proxy_url = &#39;124.88.67.21:843&#39;
password_mgr = request.HTTPPasswordMgrWithDefaultRealm()
password_mgr.add_password(None, proxy_url, &#39;tomcat&#39;, &#39;tomcat&#39;)
proxy_auth_handler = request.ProxyBasicAuthHandler(password_mgr)

proxy_handler = request.ProxyHandler({&#39;http&#39;: proxy_url})

opener = request.build_opener(proxy_handler, proxy_auth_handler)

url = &#39;http://ip.chinaz.com/getip.aspx&#39;
with opener.open(url) as f:
print(f.read().decode(&#39;utf-8&#39;))
</code></pre></li>
</ul>

<h5 id="toc_7">5.3 HTTPRedirectHandler</h5>

<ul>
<li>重定向类型：

<ul>
<li>301重定向（Moved Permanently）：表示本网页永久性转移到另一个地址，搜索引擎在抓取新内容时，会将旧的网址替换为重定向之后的网址，比如<a href="http://www.360buy.com/">http://www.360buy.com/</a></li>
<li>302重定向（Temporarily Moved）：表示暂时重定向，搜索引擎在抓取新内容时，会保留旧的网址，比如<a href="http://www.baidu.com/haha">http://www.baidu.com/haha</a></li>
</ul></li>
<li><p>处理重定向（需要自定义Handler继承HTTPRedirectHandler，并重写相关处理方法）</p>

<pre><code class="language-python">from urllib import request

# a. 不进行重定向处理
url = &#39;http://www.baidu.com/haha&#39;
with request.urlopen(url) as f:
    print(f.getheaders())
    final_url = f.geturl()
    if url != final_url:
        print(&#39;redirected...&#39;)

# b. 进行重定向处理
# 自定义Handler，重写父类处理302的方法（防止302跳转）
# 若还需要防止301跳转，则重写父类处理301的方法
class NoHTTPRedirectHandler(request.HTTPRedirectHandler):
    def http_error_302(self, req, fp, code, msg, headers):
        print(&#39;http_error_302...&#39;)
        pass

opener = request.build_opener(NoHTTPRedirectHandler)

url = &#39;http://www.baidu.com/haha&#39;
with opener.open(url) as f:
    print(f.getheaders())
    final_url = f.geturl()
    if url != final_url:
        print(&#39;redirected...&#39;)
</code></pre></li>
</ul>

<h5 id="toc_8">5.4 HTTPCoookieProcessor</h5>

<ul>
<li>利用http.cookiejar模块的CookieJar对象可以捕获、保存、在后续请求时加载cookie（这些操作都使用了handler来实现的），以实现模拟登录的功能；在Python 2.x中，CookieJar在cookielib模块下</li>
<li>cookie保存的方式有两大类型：

<ul>
<li>CookieJar（保存到内存中）</li>
<li>FileCookieJar（保存到文件中）：无法直接使用，需要用其子类MozillaCookieJar（保存格式为Mozilla格式）、LWPCookieJar（保存格式为LWP格式）</li>
</ul></li>
<li>一个cookie的大小是有限制的；对于同一个url可以有多个cookie，但发送给服务器时会自动将多个cookie拼接一起设置在request的header的“Cookie”字段中</li>
<li><p>使用cookie的方式：</p>

<ul>
<li>直接从response的header中获取cookie：之后访问同一个域中的其他url，request的header中是默认不会带“Cookie”字段的，需要手动设置cookie</li>
<li><strong>通过CookieJar获取cookie：之后访问同一个域中的其他url，会自动带上之前获取的cookie，不需要手动设置</strong></li>
</ul></li>
<li><p>处理cookie</p>

<pre><code class="language-python">from urllib import request
from http import cookiejar

# a. 直接从response的header中获取cookie
url = &#39;http://www.baidu.com/haha&#39;
req = request.Request(url)
with request.urlopen(req) as f:
    print(f.info())  # header有Set-Cookie字段

# b. 通过CookieJar获取cookie（保存到CookieJar中）
cj = cookiejar.CookieJar()
handler = request.HTTPCookieProcessor(cookiejar=cj)

opener = request.build_opener(handler)

url = &#39;http://www.baidu.com/&#39;
with opener.open(url) as f:
    print(f.info())
    print(&#39;............&#39;)
    for item in cj:  # item为http.cookiejar.Cookie对象
        print(item.name + &#39;, &#39; + item.value + &#39;, &#39; + item.domain + &#39;, &#39; + str(item.expires))
    # 之后，opener.open()访问同一个域中的其他url会自动带上cookie

# c. 通过CookieJar获取cookie（保存到文件中）
# filename = &#39;mozillaCookie.txt&#39;
# fileCJ = cookiejar.MozillaCookieJar(filename)
filename = &#39;lwpCookie.txt&#39;
fileCJ = cookiejar.LWPCookieJar(filename)
handler = request.HTTPCookieProcessor(cookiejar=fileCJ)

opener = request.build_opener(handler)

url = &#39;http://www.baidu.com/&#39;
with opener.open(url) as f:
    # 保存到文件
    # ignore_discard=True：表示即使cookie将被丢弃也将其保存
    # ignore_expires=True：表示即使cookies已过期也将其保存
    fileCJ.save(ignore_discard=True, ignore_expires=True)
    for item in fileCJ:
        print(item.name + &#39;, &#39; + item.value + &#39;, &#39; + item.domain + &#39;, &#39; + str(item.expires))

# d. 加载cookie，并利用cookie模拟登陆
# 登陆失败，则报错HTTP Error 401: Unauthorized
# 登陆成功，则打印header信息
# lwpCookie.txt内容如下:
# #LWP-Cookies-2.0
# Set-Cookie3: JSESSIONID=&quot;D0A8F2D81D533497AC7A7BA22E35A041&quot;; path=&quot;/manager/&quot;; domain=&quot;127.0.0.1&quot;; path_spec; discard; version=0

filename = &#39;lwpCookie.txt&#39;
fileCJ = cookiejar.LWPCookieJar()
# 从文件中加载cookie
fileCJ.load(filename, ignore_discard=True, ignore_expires=True)
handler = request.HTTPCookieProcessor(cookiejar=fileCJ)

opener = request.build_opener(handler)

url = &#39;http://127.0.0.1:8080/manager/html&#39;
with opener.open(url) as f:
    print(f.info())
</code></pre></li>
<li><p>调试：输出HTPP Debug Log</p>

<pre><code class="language-python"># 输出Log方式1：
from urllib import request
from http.client import HTTPConnection, HTTPSConnection

HTTPConnection.debuglevel = 1
HTTPSConnection.debuglevel = 1

request.urlopen(&#39;http://www.baidu.com/&#39;)
print(&#39;.....&#39;)

# 输出Log方式2：（通过Handler；未验证通过）
from urllib import request

httpHandler = request.HTTPHandler(debuglevel=1)
httpsHandler = request.HTTPSHandler(debuglevel=1)

opener = request.build_opener(httpHandler, httpsHandler)

opener.open(&#39;http://www.baidu.com/&#39;)
print(&#39;.....&#39;)
</code></pre></li>
</ul>

<h4 id="toc_9">六、实战</h4>

<ul>
<li><p>抓取糗事百科</p>

<pre><code class="language-python"># http://www.qiushibaike.com/hot/page/1/
# 匹配的文字内容格式：&lt;div class=&quot;content&quot;&gt;这个一定能过&lt;/div&gt;
from urllib import request
import re
from threading import Thread
import time

def get_contents_by_page(page):
    url = &#39;http://www.qiushibaike.com/hot/page/%d/&#39; % page
    req = request.Request(url)
    req.add_header(&#39;User-Agent&#39;, &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:45.0) Gecko/20100101 Firefox/45.0&#39;)

    with request.urlopen(req) as f:
        html = f.read().decode(&#39;utf-8&#39;, errors=&#39;ignore&#39;)
        # 方式1:
        # 使用非贪婪匹配：&lt;div class=&quot;content&quot;&gt;([.|\n]*?)&lt;/div&gt;或者&lt;div class=&quot;content&quot;&gt;([\s\S]*?)&lt;/div&gt;
        # .默认匹配除换行之外的任意字符
        # pattern = r&#39;&lt;div class=&quot;content&quot;&gt;([\s\S]*?)&lt;/div&gt;&#39;
        # contents = re.findall(pattern, html)

        # 方式2:
        pattern = r&#39;&lt;div class=&quot;content&quot;&gt;(.*?)&lt;/div&gt;&#39;
        # 设置re.S标志位，让.也可以匹配换行符
        contents = re.findall(pattern, html, re.S)

        pageContents = []
        for content in contents:
            pageContents.append(content.replace(&#39;\n&#39;, &#39;&#39;))
        return pageContents
</code></pre>

<pre><code class="language-python">totalPageContents = []

def get_pages_contents():
    page = 1
    while True:
        # totalPageContents最多只能存放两页的数据，超过就暂停抓取
        if len(totalPageContents) &lt; 2:
            page_contents = get_contents_by_page(page)
            page += 1
            totalPageContents.append(page_contents)
        else:
            time.sleep(1.0)

def print_pages_contents():
    page = 1
    while True:
        if len(totalPageContents):  # 有数据
            page_contents = totalPageContents.pop(0)
            print(&#39;------------第%d页数据------------&#39; % page)
            for content in page_contents:
                print(&quot;&gt;&gt;&quot; + content)
                page += 1
        else:
            time.sleep(1.0)
</code></pre>

<pre><code class="language-python">def start():
    print(&#39;------------开始爬虫------------&#39;)
    Thread(target=get_pages_contents).start()
    print_pages_contents()

if __name__ == &#39;__main__&#39;:
    start()
</code></pre></li>
<li><p>抓取百度贴吧连载小说</p>

<pre><code class="language-python"># http://tieba.baidu.com/p/3829840554?see_lz=1&amp;pn=1
from urllib import request
import re

allData = []

def get_pages_contents(url, page_count):
    for i in range(1, int(page_count) + 1):
        print(&#39;正在抓取第%s页的数据...&#39; % i)
        req = request.Request(&#39;%s&amp;pn=%d&#39; % (url, i))
        req.add_header(&#39;User-Agent&#39;,&#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:45.0) Gecko/20100101 Firefox/45.0&#39;)

        with request.urlopen(req) f:
          html = f.read().decode(&#39;utf-8&#39;)
          pattern = r&#39;&lt;div id=&quot;post_content_\d+?&quot; class=&quot;d_post_content j_d_post_content &quot;&gt;(.+?)&lt;/div&gt;&#39;
          contents = re.findall(pattern, html)
          print(&#39;正在处理第%s页的数据...&#39; % i)
          for co in contents:  # 处理每一楼层内容；sub方法为进行字符串替换
              co = re.sub(r&#39;^\s*&#39;, r&#39;&#39;, co)  # 处理最前面的空格
              co = re.sub(r&#39;&lt;br&gt;&#39;, r&#39;\n&#39;, co)  # 处理换行
              co = re.sub(r&#39;&lt;a .+?&gt;(.+?)&lt;/a&gt;&#39;, r&#39;\1&#39;, co)  # 处理超链接
              allData.append(co) # 注：不严谨，无法保证每页的顺序正确
</code></pre>

<pre><code class="language-python">url = &#39;http://tieba.baidu.com/p/3829840554?see_lz=1&#39;
req = request.Request(url)
req.add_header(&#39;User-Agent&#39;, &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:45.0) Gecko/20100101 Firefox/45.0&#39;)

with request.urlopen(req) as f:
    html = f.read().decode(&#39;utf-8&#39;)
    title = re.search(r&#39;&lt;h3 class=&quot;core_title_txt.*?&gt;(.+?)&lt;/h3&gt;&#39;, html).group(1)
    print(&#39;标题为: %s&#39; % title)
    page_count = re.search(r&#39;&lt;span class=&quot;red\&quot;&gt;(\d+?)&lt;/span&gt;&#39;, html).group(1)
    print(&#39;一共有%s页数据&#39; % page_count)

    get_pages_contents(url, page_count)

    with open(title + &#39;.txt&#39;, &#39;w&#39;) as ff:
        ff.writelines(allData)
        print(&#39;数据保存完毕...&#39;)
</code></pre></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(17Web开发、18异步IO)]]></title>
    <link href="http://www.justisit.com/15125773962376.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773962376.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">17. Web开发</a>
<ul>
<li>
<a href="#toc_1">17.1 HTTP协议</a>
</li>
<li>
<a href="#toc_2">17.2 HTML</a>
</li>
<li>
<a href="#toc_3">17.3 WSGI接口</a>
</li>
<li>
<a href="#toc_4">17.4 使用Web框架</a>
</li>
<li>
<a href="#toc_5">17.5 使用模板</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">18. 异步IO</a>
<ul>
<li>
<a href="#toc_7">18.1 概述</a>
</li>
<li>
<a href="#toc_8">18.2 协程（Coroutine）</a>
</li>
<li>
<a href="#toc_9">18.3 asyncio</a>
</li>
<li>
<a href="#toc_10">18.4 async/await</a>
</li>
<li>
<a href="#toc_11">18.5 aiohttp</a>
</li>
</ul>
</li>
</ul>


<h4 id="toc_0">17. Web开发</h4>

<h5 id="toc_1">17.1 HTTP协议</h5>

<ul>
<li>在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来；浏览器和服务器之间的传输协议是HTTP</li>
<li>HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信；HTML是一种用来定义网页的文本</li>
<li><p>每个HTTP请求和响应报文都遵循相同的格式，包含Header、Body（可选的）</p>

<pre><code class="language-python"># 1. HTTP GET请求格式
GET /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3
</code></pre>

<ul>
<li>a. GET为请求方法，类似的有POST、HEADER等</li>
<li>b. /path表示URL的路径（总是以/开头），/就表示首页</li>
<li>c. HTTP/1.1表示采用HTTP协议版本为1.1；HTTP/1.1允许多个HTTP请求复用同一个TCP连接，加快传输速度，HTTP/1.0不可以</li>
<li>d. 每个Header一行一个，换行符为\r\n</li>
</ul>

<pre><code class="language-python"># 2. HTTP POST请求格式
POST /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
</code></pre>

<ul>
<li>a. 当遇到连续两个\r\n，表示Header部分结束，后面的数据全部是Body</li>
</ul>

<pre><code class="language-python"># 3. HTTP 响应格式
200 OK
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
</code></pre>

<ul>
<li>a. 200表示成功响应，后面的OK为说明；类似的，“404 Not Found”表示网页不存在，“500 Internal Server Error”表示服务器内部出错，等等</li>
<li>b. Content-Type表示body的数据类型，比如，“text/html”表示HTML网页；浏览器依靠Content-Type来判断响应的内容类型，而不是依靠URL，故即使URL是<a href="http://abc.com/a.jpg%E4%B9%9F%E4%B8%8D%E4%B8%80%E5%AE%9A%E5%B0%B1%E6%98%AF%E5%9B%BE%E7%89%87">http://abc.com/a.jpg也不一定就是图片</a></li>
<li>c. 当存在Content-Encoding时，说明Body数据被压缩了，需要将Body数据先解压才能使用；最常见的压缩方式是gzip；压缩的目的在于减小Body的大小，加速网络传输</li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->   

<h5 id="toc_2">17.2 HTML</h5>

<ul>
<li>HTML定义了网页的内容，CSS控制网页的内容，JavaScript负责页面的交互逻辑</li>
<li>当我们用Python或者其他语言开发Web应用时，就是要在服务器端动态创建出HTML；这样，浏览器就会向不同的用户显示不同的Web页面</li>
</ul>

<h5 id="toc_3">17.3 WSGI接口</h5>

<ul>
<li><p>一个Web应用的本质：</p>

<ul>
<li>1). 浏览器发送一个HTTP请求</li>
<li>2). 服务器收到请求，生成一个HTML文档</li>
<li>3). 服务器把HTML文档作为HTTP响应的Body发送给浏览器</li>
<li>4). 浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示</li>
</ul></li>
<li><p>最简单的Web应用：先把HTML用文件保存好，使用一个HTTP服务器接收用户请求，从文件中直接读取HTML并返回；Apache、Nginx、Lighttpd等这些常见的静态服务器就是这样做的</p></li>
<li><p>若要显示动态的HTML，可以由专门的服务器软件实现接收HTTP请求、解析HTTP请求、发送HTTP响应等底层功能，而我们使用Python或者其他语言专注于生成HTML文档；</p></li>
<li><p>这种让我们专注于编写Web业务的代码，而不必关心TCP连接、HTTP请求响应格式等底层代码的编程接口，称为WSGI（Web Server Gateway Interface）</p></li>
<li><p>WSGI接口定义非常简单，只需要实现一个HTTP处理函数（名称无所谓）就可以响应HTTP请求</p>

<pre><code class="language-python">def app(environ, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])
    # 必须返回一个数组（元素必须为字节类型）
    return [b&#39;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#39;]
</code></pre>

<ul>
<li>上面的app()函数就是符合WSGI标准的一个HTTP处理函数，接收两个参数：

<ul>
<li>environ（包含所有HTTP请求信息的dict对象）</li>
<li>start_response（发送HTTP响应的函数；接收两个参数：HTTP响应状态字符串、HTTP Header的list，元素为tuple）</li>
</ul></li>
<li>在app()函数中，调用start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])就是发送HTTP响应的Header；Header只能发送一次，也就是只能调用一次start_response()函数</li>
<li>app()函数的返回值将作为HTTP响应的Body发送给浏览器</li>
</ul></li>
<li><p>有了WSGI，就只需要从environ中获取到HTTP请求信息，然后构造HTML，调用start_reponse()类似函数发送Header，最后返回Body</p></li>
<li><p>HTTP处理函数必须由WSGI服务器来调用，若手动调用则无法提供所需要的参数，且返回的bytes无法发送给浏览器</p></li>
<li><p>有很多符合WSGI规范的服务器可以使用，Python内置的wsgiref模块就是一个WSGI服务器的参考实现；所谓“参考实现”就是指实现完全符合WSGI标准，但不考虑运行效率，仅供开发测试使用</p>

<pre><code class="language-python"># hello.py，实现Web应用程序的WSGI处理函数
def app(environ, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])
    return [b&#39;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#39;]

# server.py，负责启动WSGI服务器
from wsgiref.simple_server import make_server
from hello import app

def start_myServer():
    # 创建一个服务器（IP为空、端口为8000、处理函数为app）
    httpd = make_server(&#39;&#39;, 8000, app)  
    print(&#39;Serving HTTP on port 8000...&#39;)
    # 开始监听HTTP请求
    httpd.serve_forever()

if __name__ == &#39;__main__&#39;:
    start_myServer()

# 浏览器输入“http://127.0.0.1:8000”进行访问
</code></pre>

<pre><code class="language-python"># 从environ中读取PATH_INFO，显示动态内容
def app(environ, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])
    # print(environ)
    body = &#39;&lt;h1&gt;Hello, %s!&lt;/h1&gt;&#39; % (environ[&#39;PATH_INFO&#39;][1:] or &#39;web&#39;)
    print(body)
    return [body.encode(&#39;utf-8&#39;), b&#39;appendTest&#39;] 

# 浏览器输入“http://127.0.0.1:8000/Tom”进行访问
</code></pre></li>
<li><p>多么复杂的Web应用程序，入口都是WSGI处理函数；但是直接在WSGI处理函数处理太底层了，需要在WSGI之上再抽象出Web框架，进一步简化Web开发</p></li>
<li><p>补充：</p>

<ul>
<li>CGI是一种为用户动态提供所需数据的设计思想，不同语言有着各种不同的实现</li>
<li>WSGI是Python对CGI进行的一种包装，核心使用Python实现</li>
<li>Django、Google webapp等则是在WSGI基础上抽象出的Web框架</li>
</ul></li>
</ul>

<h5 id="toc_4">17.4 使用Web框架</h5>

<ul>
<li>若直接在WSGI处理函数做判断分别处理多个不同的URL请求，这种处理方式比较低级，且代码无法很好维护</li>
<li><p>可以在WSGI接口之上进行抽象，专注于用一个函数处理一个URL，URL到函数自动映射</p>

<ul>
<li>Flask就是这样的Web框架，其通过Python的装饰器在内部把URL和函数给关联起来，简化Web开发</li>
<li>除了Flask，常见的Python Web框架还有Django、web. py、Bottle、Tornado（异步）</li>
</ul>

<pre><code class="language-python"># Flask使用，处理3个URL：
# a. GET /（首页，返回Home）、
# b. GET /signin（登录页，显示登录表单）、
# c. POST /signin（处理登录表单，显示登录结果）
from flask import Flask, request

app = Flask(__name__)

@app.route(&quot;/&quot;, methods=[&#39;GET&#39;, &#39;POST&#39;])
def home():
    return &#39;&lt;h1&gt;Home&lt;/h1&gt;&#39;

@app.route(&#39;/signin&#39;, methods=[&#39;GET&#39;]) # /signin的GET
def signin_form():
    return &#39;&#39;&#39;&lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;
              &lt;p&gt;&lt;input name=&quot;username&quot;&gt;&lt;/p&gt;
              &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;
              &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Sign In&lt;/button&gt;&lt;/p&gt;
              &lt;/form&gt;&#39;&#39;&#39;

@app.route(&#39;/signin&#39;, methods=[&#39;POST&#39;]) # /signin的POST
def signin():
    # 从request对象读取表单内容
    if request.form[&#39;username&#39;] == &#39;admin&#39; and request.form[&#39;password&#39;] ==&#39;password&#39;:
        return &#39;&lt;h3&gt;Hello, admin!&lt;/h3&gt;&#39;
    return &#39;&lt;h3&gt;Bad username or password.&lt;/h3&gt;&#39;

if __name__ == &#39;__main__&#39;:
    app.run()  # 默认值端口5000，app.run(debug=Ture)则以调试模式启动

# 浏览器输入“http://127.0.0.1:5000/”进行访问首页
</code></pre></li>
</ul>

<h5 id="toc_5">17.5 使用模板</h5>

<ul>
<li>使用拼接字符串来生成HTML页面不合理，所以出现了模板技术</li>
<li>使用模板，需要预先准备一个特殊的HTML文档，其嵌入一些变量和指令（比如模板HTML中的<code>{{ NAME }}</code>），然后根据我们传入的数据，替换后得到最终的HTML</li>
<li>Flask默认支持的模板是Jinja2，通过rander_template()函数来实现模板的渲染；<strong>模板HTML一定要放到正确的templates目录，templates和app.py在同级目录下</strong></li>
<li><p>在Jinja2模板中，用 <code>{{ NAME }}</code> 表示一个需要替换的变量，循环、条件判断等指令语句用 <code>{% ... %}</code> 表示</p>

<pre><code># 循环输出页码
{% if i in page_list %}
    &lt;a href=&quot;/page/{{ i }}&quot;&gt;{{ i }}&lt;/a&gt;
{% endfor %}
</code></pre></li>
<li><p>除了Jinja2，常见的Python模板还有Mako、Cheetah、Django</p>

<pre><code class="language-python">from flask import Flask, request, render_template

app = Flask(__name__)

@app.route(&quot;/&quot;, methods=[&#39;GET&#39;, &#39;POST&#39;])
def home():
    return render_template(&#39;home.html&#39;)

@app.route(&#39;/signin&#39;, methods=[&#39;GET&#39;])
def signin_form():
    return render_template(&#39;form.html&#39;);

@app.route(&#39;/signin&#39;, methods=[&#39;POST&#39;])
def signin():
    username = request.form[&#39;username&#39;];
    password = request.form[&#39;password&#39;];
    if username == &#39;admin&#39; and password ==&#39;password&#39;:
        return render_template(&#39;signin-ok.html&#39;, username = username)
    return render_template(&#39;form.html&#39;, message = &#39;Bad username or password&#39;, username = username)

if __name__ == &#39;__main__&#39;:
    app.run()   
</code></pre>

<pre><code class="language-html"># home.html
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Home&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1 style=&quot;font-style:italic&quot;&gt;Home&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<pre><code class="language-html"># form.html
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Please Sign In&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  {% if message %}
  &lt;p style=&quot;color:red&quot;&gt;{{ message }}&lt;/p&gt;
  {% endif %}
  &lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;
    &lt;legend&gt;Please sign in:&lt;/legend&gt;
    &lt;p&gt;&lt;input name=&quot;username&quot; placeholder=&quot;Username&quot; value=&quot;{{ username }}&quot;&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input name=&quot;password&quot; placeholder=&quot;Password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;
    &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Sign In&lt;/button&gt;&lt;/p&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<pre><code class="language-html"># signin-ok.html
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Welcome, {{ username }}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Welcome, {{ username }}!&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p>MVC（Model-View-Controller，模型-视图-控制器）</p>

<ul>
<li>a. Python处理URL的函数就是C（Controller），负责业务逻辑，比如检查用户名是否存在，取出用户信息等</li>
<li>b. 包含变量 <code>{{ NAME }}</code> 的模板就是V（View），负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML</li>
<li>c. Mode是用来传给View的，View在替换变量的时候，从Model中取出相应的数据</li>
<li>d. 因为Python支持关键字参数，很多Web框架允许传入关键字参数，然后在框架内部组装出一个dict作为Model</li>
</ul></li>
<li><p>在Python代码中处理M（Model）和C（Controller），而V（View）通过模板处理，这样就成功地把Python代码和HTML代码最大限度地分离</p></li>
<li><p>使用模板的另一大好处是，模板改起来很方便，而且改完保存后，刷新浏览器就能看到最新的效果</p></li>
</ul>

<h4 id="toc_6">18. 异步IO</h4>

<h5 id="toc_7">18.1 概述</h5>

<ul>
<li>CPU和IO设备的速度严重不匹配，多进程、多线程是解决这一问题的常用办法；而当进程、线程的数量过多时，效率性能也会严重下降</li>
<li><p>异步IO也是一种解决该问题的办法；当代码执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后去执行其他代码，一段时间后，当IO操作返回结果时，再通知CPU进行处理</p>

<ul>
<li><p>异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程</p>

<pre><code class="language-python">loop = get_event_loop()
while True:
    event = loop.get_event()
    process_event(event)
</code></pre></li>
<li><p>消息模型早就出现在桌面应用程序中了；所有的键盘、鼠标等消息都被发送到程序的消息队列中，主线程负责不停地读取消息并处理消息</p></li>
<li><p>在“发出IO请求”到“IO完成”的这段时间里，同步IO模型下主线程只能挂起，在异步IO模型下主线程并没有休息，而是在消息循环中继续处理其他消息</p></li>
<li><p>在异步IO模型中，一个线程可以同时处理多个IO请求却没有切换线程，大大提升多任务处理能力</p></li>
</ul></li>
</ul>

<h5 id="toc_8">18.2 协程（Coroutine）</h5>

<ul>
<li>Python中的<strong>单进程</strong>的<strong>异步编程模型</strong>称为<strong>协程（Coroutine）</strong>，又称为微线程</li>
<li>函数与协程区别：

<ul>
<li>函数（子程序）在所有语言中都是层级调用，通过栈来实现，并且调用总是一个入口一次返回，调用顺序明确；比如A调用B，B在执行过程中又调用C，C执行完毕返回，B执行完毕返回，最后A执行完毕</li>
<li>协程看上去像函数，但是其在执行过程中是可以内部中断（类似于CPU的中断）；然后转而执行别的协程（并不是函数调用），之后在适当的时候再返回来接着执行之前的协程；<strong>协程的执行有点类似多线程执行，但实际上是在一个线程上执行</strong></li>
</ul></li>
<li>协程的优点：

<ul>
<li>执行效率高（协程间的切换不是线程切换，而是由程序自身控制）</li>
<li>不需要多线程的锁机制（一个线程中不存在写变量冲突；共享资源不用加锁，只需判断状态即可）</li>
</ul></li>
<li>在多核CPU情况下，使用“多进程+协程”可以获得极高的性能</li>
<li><strong>Python通过特性generator实现对协程的支持</strong></li>
<li><strong>yield不仅可以返回一个值，还可以接收调用者发出的参数（通过send()方法发送的，即send()方法可调用协程）</strong></li>
<li><strong>仅仅只有协程是不够的，还不足以实现异步IO，还需要消息循环和状态的控制</strong></li>
<li><p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但是一不小心可能产生死锁；可以通过generator，生产者生产消息后，直接通过send跳转到消费者开始执行，待消费者执行完毕后，yield返回到生产者继续生产</p>

<pre><code class="language-python"># 生产者-消费者模型（注意：这里还不是协程，只是generator）
def consumer():
    r = &#39;&#39;
    while True:
        # 为了让n接收数据，先yield一下
        # r将消费结果返回，n记录下一次调用send()方法传递的参数
        n = yield r
        if not n:
            return
        print(&#39;Consumer consuming %s ...&#39; % n)
        r = &#39;OK %s&#39; % n

def producer(c):
    c.send(None)
    for i in range(1, 4):
        print(&#39;Producer producing %s ...&#39; % i)
        r = c.send(i)  # i从1开始
        print(&#39;Producer, Consumer return: %s&#39; % r)
    c.close()

c = consumer()
producer(c)

# 执行结果
Producer producing 1 ...
Consumer consuming 1 ...
Producer, Consumer return: OK 1
Producer producing 2 ...
Consumer consuming 2 ...
Producer, Consumer return: OK 2
Producer producing 3 ...
Consumer consuming 3 ...
Producer, Consumer return: OK 3
</code></pre></li>
</ul>

<h5 id="toc_9">18.3 asyncio</h5>

<ul>
<li>asyncio是Python 3.4引入的标准库，直接内置了对异步IO的支持</li>
<li><p>asyncio的编程模型就是一个消息循环，从asyncio中直接获取EventLoop，然后把需要执行的协程放到EventLoop中执行，就实现异步IO</p>

<pre><code class="language-python">import asyncio
import threading

# 这才是一个协程
@asyncio.coroutine
def hello():
    print(&#39;Hello World: (%s)...&#39; % threading.current_thread())
    # 执行EventLoop中其他可执行的协程
    r = yield from asyncio.sleep(3) 
    print(r)
    print(&#39;Hello Again: (%s)...&#39; % threading.current_thread())

# 获取EventLoop
loop = asyncio.get_event_loop()

# 将coroutine加入到EventLoop，并
loop.run_until_complete(asyncio.wait([hello(), hello()]))
loop.close()

# 执行结果
Hello World: (&lt;_MainThread(MainThread, started 140735154606080)&gt;)...
Hello World: (&lt;_MainThread(MainThread, started 140735154606080)&gt;)...
（暂停了3秒）
None
Hello Again: (&lt;_MainThread(MainThread, started 140735154606080)&gt;)...
None
Hello Again: (&lt;_MainThread(MainThread, started 140735154606080)&gt;)...
</code></pre></li>
<li><p><strong>@asyncio.coroutine: 把一个generator标记为coroutine（协程）类型</strong></p>

<ul>
<li><strong>协程不能直接运行，需要把协程加入到EventLoop，由其在适当的时候调用</strong></li>
</ul></li>
<li><p><strong>yield from asyncio.sleep(3)：中断当前协程并执行下一个消息循环（即去执行EventLoop中其他可执行的协程），当asyncio.sleep(3)返回后，才接着执行之后的代码</strong></p>

<ul>
<li>yield from XX: XX必须为Iterable，本质是遍历XX并分别yield</li>
<li>asyncio.sleep(3)也是一个协程（协程也是generator）</li>
<li>不能使用time模块的sleep，其会阻塞整个线程</li>
<li><strong>asyncio模块的sleep的内部实现是注册一个定时器在EventLoop中，把CPU的控制权交给其他协程</strong></li>
<li><strong>在此例中，让出时间为3秒给其他协程执行，3秒后asyncio.sleep(3)执行完，执行结果被yield给EventLoop，EventLoop再调用返回到当前协程中（这里调用参数为None，由r来接收），这里先不关心其他协程有没有执行完；可以把asyncio.sleep(3)看成一个耗时3秒的IO操作</strong></li>
</ul></li>
<li><p>asyncio.wait()：多个协程需要使用其包装一下</p></li>
<li><p>run_until_complete()：将协程加入到EventLoop（本质将协程包装成为了一个任务task），并启动EventLoop</p></li>
<li><p><strong>异步操作需要在coroutine中通过yield from完成，多个coroutine封装一起然后并发执行</strong></p>

<pre><code class="language-python"># 异步网络连接来获取sina、sohu、163的首页
import asyncio

@asyncio.coroutine
def wget(host):
    print(&#39;wget %s...&#39; % host)
    # 获取输入、输出流，连接耗时
    reader, writer = yield from asyncio.open_connection(host, 80)

    # 只请求头部信息
    header = &#39;HEAD / HTTP/1.0\r\nHost: %s\r\n\r\n&#39; % host  
    writer.write(header.encode(&#39;utf-8&#39;))
    # 完全写入耗时（drain:排水、流干）
    yield from writer.drain() 

    while True:
        # 读取耗时
        line = yield from reader.readline()
        if line == b&#39;\r\n&#39;:
            break

        # rstrip()删除str末尾的指定字符(默认为空格)
        print(&#39;%s header &gt; %s&#39; % (host, line.decode(&#39;utf-8&#39;).rstrip()))
    writer.close()  # close the socket

loop = asyncio.get_event_loop()
wgetList = [wget(host) for host in [&#39;www.sina.com.cn&#39;, &#39;www.sohu.com&#39;, &#39;www.163.com&#39;]]
loop.run_until_complete(asyncio.wait(wgetList))
loop.close()
</code></pre></li>
</ul>

<h5 id="toc_10">18.4 async/await</h5>

<ul>
<li>使用asyncio的@asyncio.coroutine把一个generator标记为coroutline类型，然后在coroutline内部使用yield from调用另一个coroutine实现异步操作</li>
<li><p>为了简化使用和代码简洁，Python 3.5引入新的语法 <code>async（代替@asyncio.coroutine）</code> 和 <code>await（代替yield from）</code></p>

<pre><code class="language-python">import asyncio
import threading

async def hello():
    print(&#39;Hello World: (%s)...&#39; % threading.current_thread())
    r = await asyncio.sleep(3)
    print(r)
    print(&#39;Hello Again: (%s)...&#39; % threading.current_thread())
</code></pre></li>
</ul>

<h5 id="toc_11">18.5 aiohttp</h5>

<ul>
<li>把asyncio（实现单线程并发IO操作）应用在Web服务器，可以实现多用户的高并发支持（HTTP连接就是IO操作）</li>
<li><p>aiohttp是基于asyncio实现的HTTP框架；asyncio实现了TCP、UDP、SSL等协议，loop_create_server()则利用asyncio创建TCP服务</p>

<pre><code class="language-python"># 编写Web应用：
# /（首页返回b&#39;&lt;h1&gt;Index&lt;/h1&gt;&#39;）、
# /hello/{name}（根据URL参数返回文本hello, %s!）
import asyncio
from aiohttp import web

async def index(request):
    await  asyncio.sleep(0.5)
    return web.Response(body=b&#39;&lt;h1&gt;Index&lt;/h1&gt;&#39;)

async def hello(request):
    await asyncio.sleep(0.5)
    text = &#39;&lt;h1&gt;hello, %s!&lt;/h1&gt;&#39; % request.match_info[&#39;name&#39;]
    return web.Response(body=text.encode(&#39;utf-8&#39;))

async def init(loop):
    app = web.Application(loop=loop)
    app.router.add_route(&#39;GET&#39;, &#39;/&#39;, index)
    app.router.add_route(&#39;GET&#39;, &#39;/hello/{name}&#39;, hello)
    # 若需要其他设备访问，ip设为0.0.0.0
    svr = await loop.create_server(app.make_handler(), &#39;127.0.0.1&#39;, 8000)
    return srv

loop = asyncio.get_event_loop()
loop.run_until_complete(init(loop))
loop.run_forever()
</code></pre></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(15网络编程、16访问数据库)]]></title>
    <link href="http://www.justisit.com/15125773962317.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773962317.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">15. 网络编程</a>
<ul>
<li>
<a href="#toc_1">15.1 TCP/IP简介</a>
</li>
<li>
<a href="#toc_2">15.2 TCP编程</a>
</li>
<li>
<a href="#toc_3">15.3 UDP编程</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">16. 访问数据库</a>
<ul>
<li>
<a href="#toc_5">16.1 概述</a>
</li>
<li>
<a href="#toc_6">16.2 SQLite</a>
</li>
<li>
<a href="#toc_7">16.3 MySQL</a>
</li>
<li>
<a href="#toc_8">16.4 使用SQLAlchemy</a>
</li>
</ul>
</li>
</ul>


<h4 id="toc_0">15. 网络编程</h4>

<h5 id="toc_1">15.1 TCP/IP简介</h5>

<ul>
<li>为了实现把全世界的所有不同类型的计算机都连接起来，规定了一套全球通用的协议（互联网协议簇，Internet Protocol Suite）</li>
<li>互联网协议簇包含了上百种协议标准，但最重要的两个协议是TCP和IP协议，故把互联网协议簇简称TCP/IP协议</li>
<li>IP协议负责把包数据从一台计算机通过网络发送到另一台计算机

<ul>
<li>IP包数据会被按块发送，途径多个路由，但不保证能到达，也不保证顺序到达</li>
<li>传输数据时，双方必须知道对方的互联网上的唯一标识IP地址</li>
<li>IPv4地址为32bit位数字，通常使用点分十进制表示（192.168.0.1）</li>
<li>IPv6地址为128bit为数字，通常使用冒号分十六进制表示（2001:0db8:85a3:0042:1000:8a2e:0370:7334）</li>
</ul></li>
<li>TCP协议负责两台计算机之间建立可靠连接，保证数据包按顺序到达

<ul>
<li>TCP协议是建立在IP协议之上的</li>
<li>TCP协议通过握手建立连接，然后对每个IP包编号，确保对方按顺序收到，若IP包丢失则自动重发</li>
<li>许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等</li>
</ul></li>
<li>端口是用来区分同一台计算机上运行的不同网络程序，每个网络程序都会向系统申请可用的端口号

<ul>
<li>一个IP包除了包含要传输的数据外，还包含源IP和目标IP，源端口和目标端口</li>
<li>计算机之间的两个进程在建立网络连接，就需要各自的的IP及端口</li>
<li>一个进程也可能同时与其他多个计算机建立链接，因此可以同时申请多个端口</li>
<li>一个端口被占用了，就不可以再被使用了；TCP的端口和UDP的端口之间是独立的，可以使用相同的端口号</li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->

<h5 id="toc_2">15.2 TCP编程</h5>

<ul>
<li>Socket是网络编程的一个抽象概念，通常用一个Socket表示“打开了一个网络链接”

<ul>
<li>创建Socket时，指定IPv4协议使用 <code>AF_INET</code>，指定IPv6协议使用 <code>AF_INET6</code>；指定使用TCP协议使用 <code>SOCK_STREAM</code>，指定使用UDP协议使用<code>SOCK_DGRAM</code></li>
<li>创建成功Socket后，还需要手动建立连接</li>
<li>多数连接都是使用可靠的TCP连接；创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器</li>
<li>作为服务器提供什么样的服务，端口就必须固定下来；比如，常用的HTTP的端口为80，FTP的端口为21</li>
<li>端口号小于1024的是Internet标准服务端口，端口号大于1024的可以任意使用</li>
</ul></li>
<li><p>TCP连接创建的是双向通道，双方都可以同时给对方发送数据</p>

<ul>
<li>但是谁先发送谁后发，怎么协调，要根据具体的协议来决定；比如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发送数据给客户端</li>
<li>调用recv(max)方法接收数据，一次最多接收指定数量的字节数据；因此，需要在一个while循环中反复进行接收数据，直到recv()返回空数据表示接收完毕，退出循环</li>
<li>接收完毕数据后，调用close()方法关闭Socket，这样一次完整的网络通信就结束了</li>
</ul>

<pre><code class="language-python"># 创建一个基于TCP连接的Socket
import socket  # 导入socket库

# 创建一个socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
# 建立连接, 注意参数是个tuple
s.connect((&#39;www.sina.com.cn&#39;, 80))
# 发送符合HTTP标准格式的数据（进行GET请求）
s.send(b&#39;GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n&#39;)  

# 接收数据
buffer = []
while True:
    # 每次最多接收1k数据
    d = s.recv(1024)
    if d:
        buffer.append(d)
    else:
        break
data = b&#39;&#39;.join(buffer)
# 关闭连接
s.close() 

# 处理接收到的数据
header, html = data.split(b&#39;\r\n\r\n&#39;, 1)
print(header.decode(&#39;utf-8&#39;))
with open(&#39;sina.html&#39;, &#39;wb&#39;) as f:
    f.write(html)
</code></pre></li>
<li><p>服务器端的进程需要先开启一个端口，并监听来自其他客户端的连接</p>

<ul>
<li>若某个客户端连接过来，服务器就与该客户端建立一个Socket连接，随后的通信就靠这个Socket连接</li>
<li>服务器可以区分不同的客户端，一个Socket连接唯一确定一个客户端</li>
<li>一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口</li>
<li>服务器需要同时响应多个客户端的请求；所以，每个连接都需要一个新的进程或新的线程来处理，否则，服务器在处理连接的过程中，无法接受其他客户端的连接</li>
</ul>

<pre><code class="language-python"># 案例：服务器将客户端发的字符串加上Hello再发回去
# tcp_server.py
import socket, threading, time

def tcplink(sock, addr):
    print(&#39;Accept new connection from %s:%s&#39; % addr)
    sock.send(b&#39;Welcome!&#39;)
    while True:
        d = sock.recv(1024)
        time.sleep(1)
        if not d or d.decode(&#39;utf-8&#39;) == &#39;exit&#39;:
            break
        d = (&#39;Hello, %s!&#39; % d.decode(&#39;utf-8&#39;)).encode(&#39;utf-8&#39;)
        sock.send(d)
    sock.close()
    print(&#39;Connection from %s:%s closed.&#39; % addr)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 绑定端口
s.bind((&#39;127.0.0.1&#39;, 9999))
# 调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量
s.listen(5)
print(&#39;Waiting for connection...&#39;)

# 服务器通过一个永久循环来接受客户端的连接，
# accept()会等待连接（阻塞线程）并返回一个客户端的连接
while True:
    sock, addr = s.accept()  # 接受一个新的TCP连接
    # 创建新线程来处理TCP连接
    t = threading.Thread(target=tcplink, args=(sock, addr))
    t.start()
</code></pre>

<pre><code class="language-python"># tcp_client.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((&#39;127.0.0.1&#39;, 9999))
print(s.recv(1024).decode(&#39;utf-8&#39;))
for data in [b&#39;Tom&#39;, b&#39;Jack&#39;, b&#39;HaHa&#39;]:
    s.send(data)
    print(s.recv(1024).decode(&#39;utf-8&#39;))
s.send(b&#39;exit&#39;)
s.close()
</code></pre></li>
</ul>

<h5 id="toc_3">15.3 UDP编程</h5>

<ul>
<li>TCP协议是建立可靠连接，并且通信双方都可以以流的形式发送数据；而UDP协议则是面向无连接的协议

<ul>
<li>使用UDP协议不需要建立连接，只需要知道对方的IP及端口，就可以直接发送数据包，但是不能确定数据包师傅到达</li>
<li>虽然使用UDP传输数据不可靠，但它的优点是比TCP速度快；对于不要求可靠到达的数据，就可以使用UDP</li>
</ul></li>
<li><p>和TCP类似，使用UDP的通信双方也分为客户端和服务器，服务器也需要先绑定端口，但不需要监听了</p>

<pre><code class="language-python"># udp_server.py
import socket

# 使用socket.SOCK_DGRAM指明是UDP
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
# 绑定端口（不需要调用listen()方法，而是直接接收任何客户端的数据）
s.bind((&#39;127.0.0.1&#39;, 9999))
print(&#39;Bind UDP on 9999...&#39;)
while True:
    # recvfrom()方法接收数据，返回值为客户端的地址与端口，
    # 这样服务器就能使用sendto()方法返回数据给客户端
    data, addr = s.recvfrom(1024)
    print(&#39;Received from %s:%s&#39; % addr)
    s.sendto(b&#39;Hello, %s!&#39; % data, addr)
</code></pre></li>
<li><p>客户端使用UDP时，首先创建基于UDP的Socket，然后直接通过sendto()给服务器发送数据，不需要调用connect()进行连接</p>

<pre><code class="language-python"># udp_client.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
for data in [b&#39;Tom&#39;, b&#39;Jack&#39;, b&#39;HaHa&#39;]:
    # 发送数据
    s.sendto(data, (&#39;127.0.0.1&#39;, 9999))
    # 接收数据（从服务器端接收数据仍然调用recv()方法）
    print(s.recv(1024).decode(&#39;utf-8&#39;))
s.close()
</code></pre></li>
</ul>

<h4 id="toc_4">16. 访问数据库</h4>

<h5 id="toc_5">16.1 概述</h5>

<ul>
<li>数据库类型：关系型数据库（Oracle、MySQL、SQLite、SQL Server等）、NoSQL（非关系型数据库）</li>
</ul>

<h5 id="toc_6">16.2 SQLite</h5>

<ul>
<li>要操作关系型数据库，首先要连接数据库，一个数据库连接称为Connection</li>
<li>连接到数据库后，打开游标Cursor，通过Cursor执行SQL语句，然后获取执行结果</li>
<li>Python定义了一套操作数据库的API接口；只需要提供符合Python标准的数据库驱动，即可通过Python连接到任何数据库</li>
<li><p>Python标准库内置了SQLite3驱动，可以直接使用</p>

<pre><code class="language-python"># sqlite使用
import sqlite3  # 导入SQLite驱动

# 连接到SQLite数据库，数据库文件test.db若不存在则在当前目录进行创建
conn = sqlite3.connect(&#39;test.db&#39;)
# 创建一个cursor
cursor = conn.cursor()

# 执行创建user表的sql
cursor.execute(&#39;create table user (id varchar(20) primary key, name varchar(20))&#39;)
# 执行插入一条记录的sql
cursor.execute(&#39;insert into user (id, name) values (\&#39;1\&#39;, \&#39;Tom\&#39;)&#39;)
# 通过rowcount获取上面执行sql后影响的行数
cursor.rowcount # 1

# 执行查询sql
cursor.execute(&#39;select * from user where id=?&#39;, (&#39;1&#39;,))
# 获取查询结果集
values = cursor.fetchall() # [(&#39;1&#39;, &#39;Tom&#39;)]
# 再次获取为空
values = cursor.fetchall() # []

# 关闭cursor
cursor.close()
# 提交事务
conn.commit()
# 关闭连接
conn.close()
</code></pre></li>
<li><p>对Cursor执行insert、update、delete语句后，影响的行数由rowcount返回</p></li>
<li><p>对Cursor执行select语句后，通过featchall()获取结果集；结果集是一个list，每一个元素都是一个tuple，对应表中一行记录</p></li>
<li><p>若sql语句带有参数，需要把参数按照位置传递给execute()方法，有几个?占位符就必须对应几个参数，参数以tuple形式提供：<br/>
<code>cursor.execute(&#39;select * from user where name=? and pwd=?&#39;, (&#39;abc&#39;, &#39;password&#39;))</code></p></li>
<li><p>执行产生数据库变化的操作要进行commit()提交事务</p></li>
<li><p>打开的Connection对象、Cursor对象要被正确地关闭，否则就会泄漏资源；可使用 <code>try...except...finally...</code> ，确保在出错的情况也能关闭掉Cursor对象、Connection对象</p>

<pre><code class="language-python"># 练习：根据分数段查找指定的名字
import os, sqlite3

db_file = os.path.join(os.path.dirname(__file__), &#39;test.db&#39;)
if os.path.isfile(db_file):
    os.remove(db_file)

# 初始数据
conn = sqlite3.connect(db_file)
cursor = conn.cursor()
cursor.execute(&#39;create table user(id varchar(20) primary key, name varchar(20), score int)&#39;)
cursor.execute(r&quot;insert into user values (&#39;A-001&#39;, &#39;Adam&#39;, 95)&quot;)
cursor.execute(r&quot;insert into user values (&#39;A-002&#39;, &#39;Bart&#39;, 62)&quot;)
cursor.execute(r&quot;insert into user values (&#39;A-003&#39;, &#39;Lisa&#39;, 78)&quot;)
cursor.close()
conn.commit()
conn.close()

def get_score_in(low, high):
    # 返回指定分数区间的名字，按分数从低到高排序
    try:
        conn = sqlite3.connect(db_file)
        cursor = conn.cursor()
        cursor.execute(&#39;select name from user where score &gt;= ? and score &lt;= ?&#39;, (low, high))
        values = cursor.fetchall()
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()
    return [v[0] for v in values]

# 测试
assert get_score_in(80, 95) == [&#39;Adam&#39;], &quot;%s失败&quot; % get_score_in(80, 95)
assert get_score_in(60, 80) == [&#39;Bart&#39;, &#39;Lisa&#39;], &quot;%s失败&quot; % get_score_in(60, 80)
assert get_score_in(60, 100) == [&#39;Bart&#39;, &#39;Lisa&#39;, &#39;Adam&#39;], &quot;%s失败&quot; % get_score_in(60, 100)
print(&#39;Pass&#39;)
</code></pre></li>
</ul>

<h5 id="toc_7">16.3 MySQL</h5>

<ul>
<li>MysQL数据库默认的编码为UTF-8，执行SQL语句 <code>show variables like &#39;%char%&#39;;</code> 可以查询配置的编码格式</li>
<li>my.cnf为MySQL的配置文件，若要修改编码格式可以修改此文件；修改文件后需要重启MySQL</li>
<li><p>若MySQL的版本&gt;=5.5.3，可以将编码设置为utf8mb4（和utf8完全兼容），该编码支持最新的Unicode标准，可以存储显示emoji字符</p>

<pre><code>[client]
default-character-set = utf8mb4

[mysqld]
character-set-server = utf8mb4
collation-server = utf8mb4_general_ci
</code></pre>

<pre><code class="language-sql"># SQL语句
show databases;  # 查询所有的数据库
use test;  # 使用test数据库
show tables;  # 查询当前数据库下的所有的表
describe 表名;  # 显示表的数据结构
</code></pre></li>
<li><p>MySQL服务器以独立的进程运行，并通过网络对外服务，所以Python需要MySQL驱动来连接MySQL服务器</p></li>
<li><p>MySQL提供了官方驱动mysql-connector-python，但是在安装的时候需要给pip命令添加参数-allow-external，安装命令为<code>pip install mysql-connector-python --allow-external mysql-connector-python</code>，或者手动安装</p></li>
<li><p>Python的DB API定义都是通用的，所以操作MySQL和SQLite类似；不过，MySQL使用的占位符是%s，SQLite使用的是?</p>

<pre><code class="language-python">import mysql.connector

conn = mysql.connector.connect(user=&#39;root&#39;, password=&#39;&#39;, database=&#39;test&#39;)
cursor = conn.cursor()

cursor.execute(&#39;create table user (id varchar(20) primary key, name varchar(20))&#39;)
cursor.execute(&#39;insert into user (id, name) values (%s, %s)&#39;, [&#39;1&#39;, &#39;Tom&#39;])
cursor.rowcount # 1

cursor.close() 
conn.commit()

cursor = conn.cursor()
cursor.execute(&#39;select * from user where id = %s&#39;, (&#39;1&#39;,))
values = cursor.fetchall() # [(&#39;1&#39;, &#39;Tom&#39;)]

cursor.close()
conn.close()
</code></pre></li>
</ul>

<h5 id="toc_8">16.4 使用SQLAlchemy</h5>

<ul>
<li><p>ORM（Object-Relational Mapping）：把关系数据库的表结构映射到对象上；Python中最有名的ORM框架是SQLAlchemy</p>

<pre><code class="language-python">from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, String, create_engine
from sqlalchemy.orm import sessionmaker

# 第1步：创建基类Base
Base = declarative_base()

# 定义User，继承Base
class User(Base):
    # 表的名称
    __tablename__ = &#39;user&#39;

    # 表的结构
    id = Column(String(20), primary_key=True)
    name = Column(String(20))

# 第2步：初始化数据库连接，创建DBSession
engine = create_engine(&#39;mysql+mysqlconnector://root:@localhost:3306/test&#39;)
DBSession = sessionmaker(bind=engine)
</code></pre>

<ul>
<li>上述代码完成了SQLAlchemy的初始化和具体每个表的class定义</li>
<li><strong>create_engine()用于初始化数据库连接，SQLAlchemy用一个字符串表示连接信息，格式如下：<code>数据库类型+数据库驱动名称://用户名:口令@机器地址:端口/数据库库名</code></strong></li>
</ul>

<pre><code class="language-python"># 第3步：创建DBSession对象
session = DBSession()

# 第4步：创建User，添加到session
new_user = User(id=&#39;5&#39;, name=&#39;Bob&#39;)
session.add(new_user)

# 第5步：提交(保存)到数据库
session.commit()

# 第6步：关闭session
session.close()
</code></pre>

<ul>
<li>DBSession对象可以视为当前数据库连接</li>
<li>向数据库表中添加一行记录（添加一个User对象），需要先获取session，然后把对象添加到session，最后提交并关闭</li>
</ul>

<pre><code class="language-python">session = DBSession()

# 创建Query查询，filter是where条件；
# 调用one()返回唯一行，调用all()返回所有行；
# 从数据库中查询出来的不再是tuple，而是User对象
user = session.query(User).filter(User.id==&#39;5&#39;).one()

print(&#39;type:&#39;, type(user)) # type: &lt;class &#39;__main__.User&#39;&gt;
print(&#39;name:&#39;, user.name) # name: Bob
session.close()
</code></pre></li>
<li><p>数据库的多个表可以用外键实现一对多、多对多等关联；相应的，ORM框架也可以提供两个对象之间的一对多、多对多等功能</p>

<pre><code class="language-python">from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, String, ForeignKey
from sqlalchemy.orm import relationship

Base = declarative_base()

class User(Base):
    __tablename__ = &#39;user&#39;

    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    # 一对多
    book = relationship(&#39;Book&#39;)

class Book(Base):
    __tablename__ = &#39;book&#39;

    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    # &quot;多&quot;的一方的book表是通过外键关联到user表的
    user_id = Column(String(20), ForeignKey(&#39;user.id&#39;))

# 当查询到一个User对象时，其books属性是一个包含若干个Book对象的list
</code></pre></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(13常见内建模块(下)、14常用第三方模块)]]></title>
    <link href="http://www.justisit.com/15125773962250.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773962250.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">13. 常见内建模块(下)</a>
<ul>
<li>
<a href="#toc_1">13.5 hashlib</a>
</li>
<li>
<a href="#toc_2">13.6 itertools</a>
</li>
<li>
<a href="#toc_3">13.7 ParserCreate（XML）</a>
</li>
<li>
<a href="#toc_4">13.8 HTMLParser（HTML）</a>
</li>
<li>
<a href="#toc_5">13.9 urllib</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">14. 常用第三方模块</a>
<ul>
<li>
<a href="#toc_7">14.1 概述</a>
</li>
<li>
<a href="#toc_8">14.2 PIL</a>
</li>
<li>
<a href="#toc_9">14.3 virturalenv</a>
</li>
</ul>
</li>
</ul>


<h4 id="toc_0">13. 常见内建模块(下)</h4>

<h5 id="toc_1">13.5 hashlib</h5>

<ul>
<li><p>hashlib提供了常见的摘要算法（如MD5、SHA等）；摘要算法又称为哈希算法、散列算法，通过把任意长度的数据转换为一个长度固定的字符串（16进制表示的字符串）</p>

<pre><code class="language-python">import hashlib

md5 = hashlib.md5()
# 先转成字节，再进行hash
md5.update(&#39;how to use md5 in python hashlib?&#39;.encode(&#39;utf-8&#39;))
m = md5.hexdigest()
print(m)  # d26a53750bc40b38b65a520292f69306

# 若数据量较大，可分多次调用update()，最后计算的结果是一样的
md5 = hashlib.md5()
md5.update(&#39;how to use md5 in &#39;.encode(&#39;utf-8&#39;))
md5.update(&#39;python hashlib?&#39;.encode(&#39;utf-8&#39;))
m = md5.hexdigest()
print(m)  # d26a53750bc40b38b65a520292f69306
</code></pre></li>
</ul>

<span id="more"></span><!-- more -->

<ul>
<li>MD5生成的结果是固定的128bit，通常用一个32位的16进制字符串表示；SHA1的结果是160bit，通常用一个40位的16进制字符串表示</li>
<li><p>比SHA1更安全的算法是SHA256和SH512；不过，越安全的算法不仅生成越慢，而且摘要长度更长</p>

<pre><code class="language-python">sha1 = hashlib.sha1()
sha1.update(&#39;how to use md5 in &#39;.encode(&#39;utf-8&#39;))
sha1.update(&#39;python hashlib?&#39;.encode(&#39;utf-8&#39;))
m = sha1.hexdigest()
print(m)  # b752d34ce353e2916e943dc92501021c8f6bca8c
</code></pre></li>
<li><p>摘要算法应用：</p>

<ul>
<li>网站存储用户登录的用户名和口令信息，其中口令信息是口令的摘要（如MD5），防止数据库泄漏或被人为查看；用户登录时对用户输入的明文口令先进行MD5运算，之后再和数据库存储的MD5进行对比</li>
<li>常见字符串（如123）的MD5、SHA1容易被破解，一般会对原始口令加一个复杂字符串后再进行MD5、SHA1，俗称“加盐（Salt）”，这样就很难通过MD5、SHA1反推常见字符串明文口令</li>
<li>若两个用户使用相同口令，则MD5值一样，这时可以使用用户登录名作为Salt，这样相同口令加不同的Salt得到不同的MD5值</li>
</ul></li>
<li><p><strong>摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改；但是它的单向计算特性决定了可以在不存储明文口令的情况下++验证++用户口令</strong></p>

<pre><code class="language-python"># 举例：模拟用户注册登录
import hashlib

db = {}
def calc_md5(password, salt):
    md5 = hashlib.md5()
    md5.update(password.encode(&#39;utf-8&#39;))
    md5.update(salt.encode(&#39;utf-8&#39;))
    return md5.hexdigest()

def register(username, password):
    db[username] = calc_md5(password, username)
    print(&#39;register successfully!&#39;)
    print(db)
    login(username, password)

def login(username, password):
    if username in db:
        if db[username] == calc_md5(password, username):
            print(&#39;%s login successfully!&#39; % username)
        else:
            print(&#39;password incorrect!&#39;)
    else:
        print(&#39;%s don\&#39;t exist!&#39; % username)
        print(&#39;registing..&#39;)
        register(username, password)

if __name__ == &#39;__main__&#39;:
    username = input(&#39;Your username: &#39;)
    password = input(&#39;Your password: &#39;)
    login(username, password)
</code></pre></li>
</ul>

<h5 id="toc_2">13.6 itertools</h5>

<ul>
<li>itertools模块提供一些非常有用的处理迭代功能的函数，它们的返回值不是list，而是Iterator，只有进行循环迭代的时候才开始真正计算</li>
<li><p>“无限”迭代器：count()、cycle()、repeat()</p>

<pre><code class="language-python">import itertools

# count()：创建一个无限的迭代器，遍历时无法停止，只能强行退出
natuals = itertools.count(1) # 1表示从数字1开始
for n in natuals:
    print(n)

# cycle()：把一个序列中的元素无限重复下去（字符串也是序列的一种）
cs = itertools.cycle(&#39;ABC&#39;)
for c in cs:
    print(c)

# repeat()：把一个元素无限重复下去，第2个参数可以限定重复次数
ns = itertools.repeat(&#39;A&#39;, 3)
for n in ns:
    print(n)
</code></pre>

<pre><code class="language-python">natuals = itertools.count(1)
# 通常使用takewhile()等函数根据条件判断来截取出一个有限的序列
ns = itertools.takewhile(lambda x: x &lt; 10, natuals)
l = list(ns)
print(l)
</code></pre></li>
<li><p>迭代组合：chian()、groupby()</p>

<pre><code class="language-python"># chian()：把一组迭代对象串联起来，形成一个更大的迭代器
for c in itertools.chain(&#39;ABC&#39;, &#39;XYZ&#39;):
    print(c) # 迭代效果：&#39;A&#39; &#39;B&#39; &#39;C&#39; &#39;X&#39; &#39;Y&#39; &#39;Z&#39;

# groupby()：把迭代对象中“相邻的”并且重复的元素挑出来放在一起
for key, group in itertools.groupby(&#39;AAABBBCCAAA&#39;):
    print(key, list(group))
# 输出结果
A [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;]
B [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;]
C [&#39;C&#39;, &#39;C&#39;]
A [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;]
</code></pre></li>
<li><p>groupby()的挑选规则实际上是通过函数完成的，只要两个元素的函数返回值相同，这两个元素就被认为是在一组的，函数返回值作为这组的key</p>

<pre><code class="language-python"># 忽略大小写分组
for key, group in itertools.groupby(&#39;AaaBBbcCAAa&#39;, lambda c: c.upper()):
    print(key, list(group))

# 输出结果
A [&#39;A&#39;, &#39;a&#39;, &#39;a&#39;]
B [&#39;B&#39;, &#39;B&#39;, &#39;b&#39;]
C [&#39;c&#39;, &#39;C&#39;]
A [&#39;A&#39;, &#39;A&#39;, &#39;a&#39;]
</code></pre></li>
</ul>

<h5 id="toc_3">13.7 ParserCreate（XML）</h5>

<ul>
<li>操作XML有两种方法：DOM和SAX

<ul>
<li>DOM：将整个XML读入内存解析为树；优点是可以任意遍历树的节点，缺点是占用内存大解析慢</li>
<li>SAX：流模式，边读边解析；优点是占用内存小解析快，缺点是需要自己处理事件；一般情况下，优先考虑SAX</li>
</ul></li>
<li>在Python中使用SAX解析XML，只需要类似start_element、end_element、char_data三个回调函数（函数名可以任意）就可以解析了</li>
<li><p>当SAX解析器读到一个节点时，比如，<code>&lt;p name=&quot;p&quot;&gt;python&lt;/p&gt;</code> 会产生3个事件：start_element事件（读取到<code>&lt;p name=&quot;p&quot;&gt;</code>时）、char_data事件（读取到<code>python</code>时）、end_element事件（读取到<code>&lt;/p&gt;</code>时）</p>

<pre><code class="language-python"># 解析XML
from xml.parsers.expat import ParserCreate

class MySaxHandler(object):
    def start_element(self, name, attrs):
        print(&#39;sax:start_element: %s, attrs: %s&#39; % (name, attrs))

    def end_element(self, name):
        print(&#39;sax:end_element: %s&#39; % name)

    def char_data(self, text):
        print(&#39;sax:char_data: %s&#39; % text)

xml = r&#39;&#39;&#39;&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;/python&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/ruby&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&#39;&#39;&#39;

parser = ParserCreate()
# 设置处理函数
handler = MySaxHandler()
parser.StartElementHandler = handler.start_element
parser.EndElementHandler = handler.end_element
parser.CharacterDataHandler = handler.char_data
parser.Parse(xml)

# 读取大段字符串时，CharacterDataHandler可能被多次调用，
# 可以人为先保存一下，之后在EndElementHandler中合并
</code></pre></li>
<li><p>生成XML最简单有效的方法就是拼接字符串</p>

<pre><code class="language-python"># 生成XML
l = []
l.append(r&#39;&lt;?xml version=&quot;1.0&quot;?&gt;&#39;)
l.append(r&#39;&lt;root&gt;&#39;)
l.append(&#39;abc&#39;)
l.append(r&#39;&lt;/root&gt;&#39;)
s = &#39;&#39;.join(l)
print(s)
</code></pre>

<pre><code class="language-python"># 练习：解析天气XML
data = r&#39;&#39;&#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot; ?&gt;
&lt;rss version=&quot;2.0&quot; xmlns:yweather=&quot;http://xml.weather.yahoo.com/ns/rss/1.0&quot; xmlns:geo=&quot;http://www.w3.org/2003/01/geo/wgs84_pos#&quot;&gt;
    &lt;channel&gt;
        &lt;title&gt;Yahoo! Weather - Beijing, CN&lt;/title&gt;
        &lt;lastBuildDate&gt;Wed, 27 May 2015 11:00 am CST&lt;/lastBuildDate&gt;
        &lt;yweather:location city=&quot;Beijing&quot; region=&quot;&quot; country=&quot;China&quot;/&gt;
        &lt;yweather:units temperature=&quot;C&quot; distance=&quot;km&quot; pressure=&quot;mb&quot; speed=&quot;km/h&quot;/&gt;
        &lt;yweather:wind chill=&quot;28&quot; direction=&quot;180&quot; speed=&quot;14.48&quot; /&gt;
        &lt;yweather:atmosphere humidity=&quot;53&quot; visibility=&quot;2.61&quot; pressure=&quot;1006.1&quot; rising=&quot;0&quot; /&gt;
        &lt;yweather:astronomy sunrise=&quot;4:51 am&quot; sunset=&quot;7:32 pm&quot;/&gt;
        &lt;item&gt;
            &lt;geo:lat&gt;39.91&lt;/geo:lat&gt;
            &lt;geo:long&gt;116.39&lt;/geo:long&gt;
            &lt;pubDate&gt;Wed, 27 May 2015 11:00 am CST&lt;/pubDate&gt;
            &lt;yweather:condition text=&quot;Haze&quot; code=&quot;21&quot; temp=&quot;28&quot; date=&quot;Wed, 27 May 2015 11:00 am CST&quot; /&gt;
            &lt;yweather:forecast day=&quot;Wed&quot; date=&quot;27 May 2015&quot; low=&quot;20&quot; high=&quot;33&quot; text=&quot;Partly Cloudy&quot; code=&quot;30&quot; /&gt;
            &lt;yweather:forecast day=&quot;Thu&quot; date=&quot;28 May 2015&quot; low=&quot;21&quot; high=&quot;34&quot; text=&quot;Sunny&quot; code=&quot;32&quot; /&gt;
            &lt;yweather:forecast day=&quot;Fri&quot; date=&quot;29 May 2015&quot; low=&quot;18&quot; high=&quot;25&quot; text=&quot;AM Showers&quot; code=&quot;39&quot; /&gt;
            &lt;yweather:forecast day=&quot;Sat&quot; date=&quot;30 May 2015&quot; low=&quot;18&quot; high=&quot;32&quot; text=&quot;Sunny&quot; code=&quot;32&quot; /&gt;
            &lt;yweather:forecast day=&quot;Sun&quot; date=&quot;31 May 2015&quot; low=&quot;20&quot; high=&quot;37&quot; text=&quot;Sunny&quot; code=&quot;32&quot; /&gt;
        &lt;/item&gt;
    &lt;/channel&gt;
&lt;/rss&gt;
&#39;&#39;&#39;

from xml.parsers.expat import ParserCreate

class WeatherSaxHandler(object):
    def start_element(self, name, attrs):
        if name == &#39;yweather:location&#39;:
            self.city = attrs[&#39;city&#39;]
            self.country = attrs[&#39;country&#39;]
        elif name == &#39;yweather:forecast&#39;:
            if not hasattr(self, &#39;today&#39;):  # 要求xml中today的天气在前面
                self.today = {&#39;text&#39;: attrs[&#39;text&#39;], &#39;low&#39;: int(attrs[&#39;low&#39;]), &#39;high&#39;: int(attrs[&#39;high&#39;])}
            elif hasattr(self, &#39;today&#39;) and (not hasattr(self, &#39;tomorrow&#39;)):
                self.tomorrow = {&#39;text&#39;: attrs[&#39;text&#39;], &#39;low&#39;: int(attrs[&#39;low&#39;]), &#39;high&#39;: int(attrs[&#39;high&#39;])}

def parse_weather(xml):
    handler = WeatherSaxHandler()
    parser = ParserCreate()
    parser.StartElementHandler = handler.start_element
    parser.Parse(xml)
    return {
        &#39;city&#39;: handler.city,
        &#39;country&#39;: handler.country,
        &#39;today&#39;: {
            &#39;text&#39;: handler.today[&#39;text&#39;],
            &#39;low&#39;: handler.today[&#39;low&#39;],
            &#39;high&#39;: handler.today[&#39;high&#39;]
        },
        &#39;tomorrow&#39;: {
            &#39;text&#39;: handler.tomorrow[&#39;text&#39;],
            &#39;low&#39;: handler.tomorrow[&#39;low&#39;],
            &#39;high&#39;: handler.tomorrow[&#39;high&#39;]
        }
    }

weather = parse_weather(data)
assert weather[&#39;city&#39;] == &#39;Beijing&#39;, &#39;%s失败&#39; % weather[&#39;city&#39;]
assert weather[&#39;country&#39;] == &#39;China&#39;, &#39;%s失败&#39; % weather[&#39;country&#39;]
assert weather[&#39;today&#39;][&#39;text&#39;] == &#39;Partly Cloudy&#39;, &#39;%s失败&#39; % weather[&#39;today&#39;][&#39;text&#39;]
assert weather[&#39;today&#39;][&#39;low&#39;] == 20, &#39;%s失败&#39; % weather[&#39;today&#39;][&#39;low&#39;]
assert weather[&#39;today&#39;][&#39;high&#39;] == 33, &#39;%s失败&#39; % weather[&#39;today&#39;][&#39;high&#39;]
assert weather[&#39;tomorrow&#39;][&#39;text&#39;] == &#39;Sunny&#39;, &#39;%s失败&#39; % weather[&#39;tomorrow&#39;][&#39;text&#39;]
assert weather[&#39;tomorrow&#39;][&#39;low&#39;] == 21, &#39;%s失败&#39; % weather[&#39;tomorrow&#39;][&#39;low&#39;]
assert weather[&#39;tomorrow&#39;][&#39;high&#39;] == 34, &#39;%s失败&#39; % weather[&#39;tomorrow&#39;][&#39;high&#39;]
print(&#39;pass&#39;)
print(&#39;Weather:&#39;, str(weather))
</code></pre></li>
</ul>

<h5 id="toc_4">13.8 HTMLParser（HTML）</h5>

<ul>
<li><p>HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML；Python提供了HTMLParser来解析HTML</p>

<pre><code class="language-python">from html.parser import HTMLParser

class MyHTMLParser(HTMLParser):
    def handle_starttag(self, tag, attrs):
        print(&#39;&lt;%s&gt;&#39; % tag)

    def handle_endtag(self, tag):
        print(&#39;&lt;/%s&gt;&#39; % tag)

    def handle_startendtag(self, tag, attrs):
        print(&#39;&lt;%s/&gt;&#39; % tag)

    def handle_data(self, data):
        print(data)

    def handle_comment(self, data):
        print(&#39;&lt;!--&#39;, data, &#39;--&gt;&#39;)

    def handle_entityref(self, name):  # 处理一些特殊字符，以&amp;开头，比如&amp;nbsp
        print(&#39;&amp;%s:&#39; % name)

    def handle_charref(self, name):  # 处理特殊字符串，以&amp;#开头的，一般是内码表示的字符
        print(&#39;&amp;#%s:&#39; % name)

html = &#39;&#39;&#39;&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;!-- test html parser --&gt;
    &lt;p&gt;Some &lt;a href=\&quot;#\&quot;&gt;html&lt;/a&gt; HTML&amp;nbsp;tutorial...&lt;br&gt;END&lt;/p&gt;
&lt;/body&gt;&amp;nbsp;&lt;/html&gt;&#39;&#39;&#39;

parser = MyHTMLParser()
parser.feed(html)
</code></pre></li>
<li><p>feed()方法可以多次调用，不需要一次把整个HTML字符串都传入，可以分批传入</p></li>
<li><p>特殊字符有两种，一种是英文表示的 <code>&amp;nbsp;</code> ，一种是数字表示的 <code>&amp;#1234;</code> ；它们都可以通过HTMLParser被解析出来</p>

<pre><code class="language-python"> # 练习：解析Python官网发布的会议时间、名称、地点
from html.parser import HTMLParser

class MyHTMLParser(HTMLParser):
    def __init__(self):
        super(MyHTMLParser, self).__init__()
        self._flag = &#39;&#39;

    def handle_starttag(self, tag, attrs):
         # 标签的属性被解析成数组（元素为单个属性tuple）
        if tag == &#39;h3&#39; and (&#39;class&#39;, &#39;event-title&#39;) in attrs:
            self._flag = &#39;Title: &#39;
        elif tag == &#39;span&#39; and (&#39;class&#39;, &#39;event-location&#39;) in attrs:
            self._flag = &#39;Location: &#39;
        elif tag == &#39;time&#39;:
            self._flag = &#39;Time: &#39;
        elif tag == &#39;span&#39; and (&#39;class&#39;, &#39;say-no-more&#39;) in attrs:
            self._flag = &#39;year&#39;

    def handle_data(self, data):
        if self._flag == &#39;Title: &#39;:
            print(&#39;-&#39; * 50)
            print(self._flag, data.strip())
        elif self._flag == &quot;Location: &quot;:
            print(self._flag, data.strip())
        elif self._flag == &#39;Time: &#39;:
            # 加参数end，打印之后不换行
            print(self._flag, data.strip(), end=&#39;~~~&#39;)
        elif self._flag == &#39;year&#39;:
            print(data.strip())
        # 在获取到数据后，必须重置当前读取的标签
        #（不可以在handle_starttag中重置，可能出现标签嵌套的情况）
        # &lt;h3 class=&quot;event-title&quot;&gt;&lt;a href=&quot;/events/python-events/360/&quot;&gt;PyCon Namibia 2016
        self._flag = &#39;&#39;

parser = MyHTMLParser()
with open(&#39;python-events.htm&#39;, &#39;r&#39;) as html:
    parser.feed(html.read())
</code></pre></li>
</ul>

<h5 id="toc_5">13.9 urllib</h5>

<ul>
<li><p>urllib的request模块可以指定URL发送HTTP请求，并返回HTTP的响应</p>

<pre><code class="language-python">from urllib import request

with request.urlopen(&#39;https://api.douban.com/v2/book/2129650&#39;) as f:
    print(&#39;Status:&#39;, f.status, f.reason)
    for k, v in f.getheaders():  # 打印响应头
        print(&#39;%s: %s&#39; % (k, v))
    print(&#39;Data:&#39;, f.read().decode(&#39;utf-8&#39;))
</code></pre></li>
<li><p>若要模拟浏览器发送请求需要使用Request对象；通过向Request对象添加HTTP头部相关信息，就可以伪装成浏览器发送请求</p>

<pre><code class="language-python"># 模拟iPhone6去请求豆瓣首页
from urllib import request

req = request.Request(&#39;http://www.douban.com/&#39;)
# User-Agent是客户端用来标识浏览器
req.add_header(&#39;User-Agent&#39;, &#39;Mozilla/6.0 (iPhone; &#39;
                             &#39;CPU iPhone OS 8_0 like Mac OS X) &#39;
                             &#39;AppleWebKit/536.26 (KHTML, like Gecko) &#39;
                             &#39;Version/8.0 Mobile/10A5376e Safari/8536.25&#39;)

with request.urlopen(req) as f:
    print(&#39;Status:&#39;, f.status, f.reason)
    for k, v in f.getheaders():
        print(&#39;%s: %s&#39; % (k, v))
    print(&#39;Data:&#39;, f.read().decode(&#39;utf-8&#39;))
</code></pre></li>
<li><p>若以POST形式发送网络请求，只需要增加参数data，数据以bytes形式传入</p>

<pre><code class="language-python">from urllib import request, parse

req = request.Request(&#39;https://passport.weibo.cn/sso/login&#39;)
req.add_header(&#39;Referer&#39;, &#39;https://passport.weibo.cn/signin/login?entry=mweibo&#39;
                          &#39;&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#39;)

login_data = parse.urlencode([(&#39;username&#39;, &#39;tom@tom.com&#39;), (&#39;password&#39;, &#39;123&#39;)])

with request.urlopen(req, data=login_data.encode(&#39;utf-8&#39;)) as f:
    print(&#39;Status:&#39;, f.status, f.reason)
    for k, v in f.getheaders():
        print(&#39;%s: %s&#39; % (k, v))
    print(&#39;Data:&#39;, f.read().decode(&#39;utf-8&#39;))
</code></pre></li>
<li><p>若需要更复杂的请求控制，比如通过一个Proxy去访问，就需要使用ProxyHandler来处理</p>

<pre><code class="language-python">proxy_handler = urllib.request.ProxyHandler({&#39;http&#39;: &#39;http://www.example.com:3128/&#39;})

proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()
proxy_auth_handler.add_password(&#39;realm&#39;, &#39;host&#39;, &#39;username&#39;, &#39;password&#39;)

opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)
with opener.open(&#39;http://www.example.com/login.html&#39;) as f:
    pass
</code></pre></li>
</ul>

<h4 id="toc_6">14. 常用第三方模块</h4>

<h5 id="toc_7">14.1 概述</h5>

<ul>
<li>除了内置模块外，Python还有大量的第三方模块；基本上，所有的第三方模块都会在PyPI - the Python Package Index（<code>https://pypi.python.org/pypi/</code>）上注册，只有找到对应的模块名字，即可用pip安装</li>
</ul>

<h5 id="toc_8">14.2 PIL</h5>

<ul>
<li><p>PIL（Python Imaging Library）是Python平台上功能强大使用简单的图像处理标准库</p>

<ul>
<li>由于PIL仅支持Python2.7，一群志愿者在PIL的基础上创建了支持Python 3的兼容版本Pillow</li>
<li>安装Pillow：pip3 install pillow</li>
<li>Pillow支持图像缩放、切片、旋转、滤镜、输出文字、调色板等功能</li>
</ul>

<pre><code class="language-python"># 图片缩放
from PIL import Image

img = Image.open(&#39;git.jpg&#39;)  # 打开一个jpge文件，注意路径
w, h = img.size  # 获取图像尺寸
print(&#39;Original image size: %sx%s&#39; % (w, h))

img.thumbnail((w // 2, h // 2))  # 缩放到50%，//整除
print(&#39;Resize image size: %sx%s&#39; % (w // 2, h // 2))
img.save(&#39;thumbnail.jpg&#39;, &#39;jpeg&#39;)  # 把缩放后的图像用jpeg格式保存

# 模糊效果
from PIL import Image, ImageFilter

img = Image.open(&#39;git.jpg&#39;)
img2 = img.filter(ImageFilter.BLUR)  # 应用模糊滤镜
img2.save(&#39;blur.jpg&#39;, &#39;jpeg&#39;)
</code></pre></li>
<li><p>PIL的ImageDraw提供了一系列绘图方法，比如可以用来生成字母验证码图片</p>

<pre><code class="language-python">from PIL import Image, ImageDraw, ImageFont, ImageFilter
import random

# 随机字母
def rndChar():
    return chr(random.randint(65, 90))

# 随机颜色1
def rndColor():
    return random.randint(64, 255), random.randint(64, 255), random.randint(64, 255)

# 随机颜色2
def rndColor2():
    return random.randint(32, 127), random.randint(32, 127), random.randint(32, 127)

# 240 * 60
width = 60 * 4
height = 60

image = Image.new(&#39;RGB&#39;, (width, height), (255, 255, 255))
draw = ImageDraw.Draw(image)  # 创建Draw对象
for x in range(width):  # 填充每个像素
    for y in range(height):
        draw.point((x, y), fill=rndColor())

font = ImageFont.truetype(&#39;Arial.ttf&#39;, 36)  # 创建Font对象
for t in range(4):  # 输出文字
    draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())

image = image.filter(ImageFilter.BLUR)  # 模糊
image.save(&#39;code.jpg&#39;, &#39;jpeg&#39;)
</code></pre></li>
</ul>

<h5 id="toc_9">14.3 virturalenv</h5>

<ul>
<li>在开发Python（比如使用Python3）应用程序时，所有的第三方的包都会被pip3安装到Python3的site-package目录下；比如应用A需要的jinja2.7，应用B需要的jinja2.6，此时，最好让每个应用都各自拥有一套“独立”的Python运行环境</li>
<li><p>virtualenv就是用来创建一套“隔离”的Python运行环境；安装virtualenv：<code>pip3 install virturalenv</code> ；注意使用pip3进行安装，这样创建的“隔离”的运行环境才是Python3的</p>

<pre><code class="language-python"># 假设开发一个新的项目，需要一套独立的Python运行环境
# 第一步，创建目录
XXPro:Desktop xx$ mkdir myproject

# 第二步，创建一个独立的Python运行环境，命名为myvenv
XXPro:Desktop xx$ cd myproject/
XXPro:myproject xx$ virtualenv --no-site-packages myvenv
Using base prefix 。。。。。。 wheel...done.
XXPro:myproject xx$ ls
myvenv

# 第三步：进入独立的Python运行环境（使用source命令）
XXPro:myproject xx$ source myvenv/bin/activate
# 注意命令提示符变了，有个(myvenv)的前缀，表示当前环境是一个名为myvenv的Python环境
(myvenv) XXPro:myproject xx$ python  # 直接使用python进入的是Python3
Python 3.5.1 。。。。。。 for more information.
&gt;&gt;&gt; from PIL import Image  # 此时发现无法导入之前pip3的PIL
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named &#39;PIL&#39;
&gt;&gt;&gt; exit()

# 第四步：为独立的Python运行环境安装第三方库
(myvenv) XXPro:myproject xx$ pip install pillow  
Collecting pillow 。。。。。。 installed pillow-3.2.0
# 在myvenv环境下，用pip安装的包都被安装到myvenv这个环境下，系统Python环境不受影响；
# 也就是说，myvenv环境是专门针对myproject这个应用创建的
(myvenv) XXPro:myproject xx$ python
Python 3.5.1 。。。。。。 for more information.
&gt;&gt;&gt; from PIL import Image  # 可以使用PIL
&gt;&gt;&gt; exit()

# 第五步：退出当前的myvenv环境（使用deactivate命令）
(myvenv) XXPro:myproject xx$ deactivate 
XXPro:myproject xx$ python  # 进入的是系统的Python2
Python 2.7.10 。。。。。。 more information.
&gt;&gt;&gt; exit()
</code></pre></li>
<li><p>virtualenv命令创建一个独立的Python运行环境，参数--no-site-packages表示不将系统的安装的第三方模块复制过来</p></li>
<li><p>独立的Python环境存放在当前目录下的环境名称目录中（比如上面的myvenv），之后使用source命令进入该环境</p></li>
<li><p>针对每个应用创建独立的Python运行环境，可以解决不同应用间使用的库多版本的冲突问题</p></li>
<li><p>virturalenv创建“独立”的Python运行环境原理：把系统Python复制一份到virtualenv环境，用命令“source myvenv/bin/activate”进入一个virtualenv环境时，virtualenv会修改环境变量，让命令python和pip均指向当前的virtualenv环境<br/>
Python3.3开始新增内置的创建虚拟环境的venv，其操作和virtualenv类似，创建一个“隔离环境”：<code>python3 -m venv myvenv</code></p></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(12正则表达式、13常见内建模块(上))]]></title>
    <link href="http://www.justisit.com/15125773962190.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773962190.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">12. 正则表达式</a>
<ul>
<li>
<a href="#toc_1">12.1 基础</a>
</li>
<li>
<a href="#toc_2">12.2 re模块</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">13. 常见内建模块(上)</a>
<ul>
<li>
<a href="#toc_4">13.1 datetime</a>
</li>
<li>
<a href="#toc_5">13.2 collections</a>
</li>
<li>
<a href="#toc_6">13.3 base64</a>
</li>
<li>
<a href="#toc_7">13.4 struct</a>
</li>
</ul>
</li>
</ul>


<h4 id="toc_0">12. 正则表达式</h4>

<h5 id="toc_1">12.1 基础</h5>

<ul>
<li>匹配字符：

<ul>
<li>\d匹配一个数字，\D匹配一个非数字</li>
<li>\w匹配一个数字字母，\W匹配一个非数字字母</li>
<li>\s匹配一个空白符（包含空格Tab等空白符），\S匹配一个非空白符</li>
<li>.匹配任意一个字符</li>
<li>[]表示精确匹配范围，例如[a-zA-Z]匹配一个字母、[0-9a-zA-Z_]匹配找一个数字、字母或下划线</li>
<li>特殊字符使用\进行转义，例如-</li>
</ul></li>
<li>匹配长度：

<ul>
<li>*表示任意个字符（包含0个）</li>
<li>+表示至少一个</li>
<li>?表示0个或1个</li>
<li>{n}表示n个，{n, m}表示n~m个，例如[a-zA-Z_][0-9a-zA-Z_]{0, 19}匹配长度为1-20个字符（前面1个是字母或下划线，后面最多19个数字、字母或下划线）</li>
</ul></li>
<li>^表示行的开头，例如<sup>\d表示必须以数字开头</sup></li>
<li>\(表示行的结束，\d\)表示必须以数字结束，py可以匹配python，但是<sup>py$就只能匹配py</sup></li>
<li>A|B表示可以匹配A或B，但有时候需要加小括号()进行限制长度（此时也就会出现了分组）；例如(P|p)ython可以匹配Python或python，P|python只能匹配P或python</li>
<li>单个字符的或匹配，也可以使用字符集[]来实现，例如[Pp]ython可以匹配Python或python</li>
</ul>

<span id="more"></span><!-- more -->

<h5 id="toc_2">12.2 re模块</h5>

<ul>
<li><p>Python中的re模块提供了正则表达式的功能；注意Python的字符串本身也用\进行转义</p>

<pre><code class="language-python">s = &#39;ABC\\-001&#39; # 字符串为&#39;ABC\-001&#39;
# 使用Python的r前缀，就不用考虑转义的问题了
s = r&#39;ABC\\-001&#39; # 字符串为&#39;ABC\\-001&#39;  
</code></pre></li>
<li><p>re.match()：从字符串的起点进行匹配，成功返回一个Match，否则返回None</p></li>
<li><p>re.search()：在字符串内查找匹配，只找到一个就匹配返回，成功返回一个Match，否则返回None；re.search(r&#39;<sup>a&#39;,</sup> &#39;cba&#39;)与re.match(r&#39;a&#39;, &#39;cba&#39;)是等价的</p></li>
<li><p>re.sub()：用于替换字符串中的匹配项</p></li>
<li><p>re.split()：分割字符串，使用正则表更灵活（可以识别连续空格）</p></li>
<li><p>re.findall()：以list形式返回全部匹配的子串</p>

<pre><code class="language-python">import re

m = re.match(r&#39;a&#39;, &#39;cba&#39;)
print(m)  # None
m = re.search(r&#39;a&#39;, &#39;cba&#39;)
print(m)  # &lt;_sre.SRE_Match object; span=(2, 3), match=&#39;a&#39;&gt;

m = re.match(r&#39;\d{3}-\d{3,8}$&#39;, &#39;010-12345&#39;)
print(m)

# 将字符串中所有的空格替换成-
re.sub(r&#39;\s+&#39;, &#39;-&#39;, str)

l = &#39;a b    c&#39;.split(&#39; &#39;)
print(l)  # [&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;]

l = re.split(r&#39;\s+&#39;, &#39;a b    c&#39;)
print(l)  # [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

# split()还可以屏蔽一些特殊字符
l = re.split(r&#39;[\s\\,\\;]+&#39;, &#39;a,b, c;;    d&#39;)
print(l)  # [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
</code></pre></li>
<li><p>分组：使用()表示要提取的分组（Group），即提取子串</p>

<ul>
<li>若正则表达式中定义了组（使用了“()”）并且匹配成功

<ul>
<li>可以在Match对象上用group(1)、group(2)提取出第1、2个子</li>
<li>&#39;\1&#39;、&#39;\2&#39;也可以表示分组中的第1、2个子串</li>
<li>groups()返回所有的子串组成的tuple</li>
<li>group()或group(0)返回整个正则表达式匹配上的子串（不要求正则中是否定义了组）</li>
</ul></li>
<li>若匹配不成功，返回None，调用group(0)、group(1)会报错</li>
</ul>

<pre><code class="language-python"># ^(\d{3})-(\d{3,8})$定义两个组用于提取出区号和号码
m = re.match(r&#39;^(\d{3})-(\d{3,8})$&#39;, &#39;010-12345&#39;)

print(m) # &lt;_sre.SRE_Match object; span=(0, 9), match=&#39;010-12345&#39;&gt;
print(m.group(0)) # 010-12345
print(m.group(1)) # 010
print(m.group(2)) # 12345
</code></pre></li>
<li><p>贪婪匹配：正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符</p>

<pre><code class="language-python">m = re.match(r&#39;^(\d+)(0*)$&#39;, &#39;102300&#39;).groups()
print(m)  # (&#39;102300&#39;, &#39;&#39;)

# 加个?就让\d+采用非贪婪匹配（也就是尽可能少匹配）
# 注意：单个?表示的是0个或1个
m = re.match(r&#39;^(\d+?)(0*)$&#39;, &#39;102300&#39;).groups()
print(m)  # (&#39;1023&#39;, &#39;00&#39;)
</code></pre></li>
<li><p>当在Python中使用正则表达式时，re模块内部会干两件事情：</p>

<ul>
<li>a. 编译正则表达式，若该表达式的字符串本身不合法，会报错</li>
<li>b. 用编译后的正则表达式去匹配字符串</li>
</ul></li>
<li><p>若一个正则表达式需要被重复使用多次，可以预编译该正则表达式，之后重复使用时就不需要编译这个步骤，直接进行匹配</p>

<pre><code class="language-python"># 编译，生成Regular Expression对象（包含正则表达式）
re_phone = re.compile(r&#39;^(\d{3})-(\d{3,8})$&#39;) 
# 匹配使用
m = re_phone.match(&#39;010-12345&#39;).groups()

print(m)  # (&#39;010&#39;, &#39;12345&#39;)
</code></pre></li>
<li><p>re提供的函数都有个可省略的flags参数（匹配模式），其有以下几个常用取值：</p>

<ul>
<li>re.I(IGNORECASE；忽略大小写)</li>
<li>re.M(MULTILINE；多行模式，改变&#39;<sup>&#39;和&#39;$&#39;的行为)</sup></li>
<li>re.S(DOTALL；点任意匹配模式，改变&#39;.&#39;的行为)；</li>
<li>多个匹配模式使用或运算符|进行组合</li>
</ul></li>
</ul>

<h4 id="toc_3">13. 常见内建模块(上)</h4>

<ul>
<li>Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用</li>
</ul>

<h5 id="toc_4">13.1 datetime</h5>

<ul>
<li><p>datetime模块是Python处理日期和时间的标准库，datetime模块还包含一个datetime类</p>

<pre><code class="language-python">from datetime import datetime

# 获取当前日期和时间
now = datetime.now()  # 返回类型为datatime
print(now)
print(type(now))

# 获取指定日期和时间
dt = datetime(2015, 10, 1, 9, 20)  # 用参数直接构造一个datetime
print(dt)
</code></pre></li>
<li><p>将1970.1.1 00:00:00 UTC+00:00的时刻称为epoch time，记为0；当前时间相对于epoch time的秒数称为timestamp（1970年之前为负数）；timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00 = 1970-1-1 08:00:00 UTC+8:00</p></li>
<li><p>由于timestamp和时区没有关系，全球各地的计算机在任意时刻的timestamp是完全相同的，所以计算机存储的当前时间是以timestamp表示的</p></li>
<li><p>Python中的timestamp是一个浮点数，小数位表示毫秒数；某些编程语言（如Java和JS）的timestamp使用整数表示毫秒数，此时只需要把timestamp除以1000就得到Python的timestamp</p>

<pre><code class="language-python"># 将datetime转timestamp
#（若datetime的时区属性为None，转换时时区取当前时区）
now = datetime.now()
print(now.timestamp())

# 将timestamp转为datetime（当前时区时间）
#（timestamp没有时区概念，datetime有时区概念）
ts = 0
print(datetime.fromtimestamp(ts))  # 1970-01-01 08:00:00

# 将timestamp转为datetime（UTC标准时间）
print(datetime.utcfromtimestamp(ts))  # 1970-01-01 00:00:00
</code></pre></li>
<li><p>datetime格式化：字符串&#39;%Y-%m-%d %H:%M:%S&#39;规定了日期和时间部分的格式</p>

<pre><code class="language-python"># datetime转str
now = datetime.now()
print(now.strftime(&#39;%a, %b %d %H:%M&#39;))

# str转datetime（没有时区信息）
dt = datetime.strptime(&#39;2015-6-1 18:20:12&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;)
print(dt)
</code></pre></li>
<li><p>对日期和时间进行加减就是把datetime往后往前计算得到新的datetime；加减可直接用+、-运算符操作timedelta类</p>

<pre><code class="language-python">from datetime import timedelta

print(now)
newNow = now + timedelta(hours=10)  # 加10小时
print(newNow)

newNow = now - timedelta(days=1)  # 减1天
print(newNow)

newNow = now + timedelta(days=2, hours=12)  # 加2天12小时
print(newNow)
</code></pre></li>
<li><p><strong>datetime有一个时区属性tzinfo，默认为None</strong>，所以无法区分该datetime是哪个时区的，需要人为设置一个时区</p>

<pre><code class="language-python">from datetime import datetime, timedelta, timezone

# 强制设置时区（使用replace()方法）
# 举例1
tz_utc_8 = timezone(timedelta(hours=8))  # 创建时区UTC + 8:00
now = datetime.now()
print(now)  # 2015-11-05 12:39:20.526329
dt = now.replace(tzinfo=tz_utc_8)  # 强制设置UTC + 8:00
print(dt)  # 2015-11-05 12:39:20.526329+08:00

# 举例2
# utcnow()可以获取当前的UTC时间
utc_now = datetime.utcnow()  # 时区属性tzinfo为None
print(utc_now)  # 2015-11-05 04:41:30.332392
utc_dt = utc_now.replace(tzinfo=timezone.utc)  # 强制转为UTC + 0:00时区
print(utc_dt)  # 2015-11-05 04:41:30.332392+00:00

# 时区转换
# astimezone()方法将一个时区的datetime转到另一个时区的datetime
bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8))) 
print(bj_dt)  # 2015-11-05 12:41:30.332392+08:00
tokyo_dt = bj_dt.astimezone(timezone(timedelta(hours=9)))
print(tokyo_dt)  # 2015-11-05 13:41:30.332392+09:00
</code></pre></li>
<li><p>datetime不含有时区信息时表示为当前本地时间；存储datetime的最佳方法是将其转为timestamp再存储</p>

<pre><code class="language-python"># 练习：将日期时间字符串及时区信息字符串转为timestamp
import re
from datetime import datetime, timezone, timedelta

def to_timestamp(dt_str, tz_str):
    d = datetime.strptime(dt_str, &quot;%Y-%m-%d %H:%M:%S&quot;)
    h = int(re.match(r&#39;UTC([+|-]\d+):&#39;, tz_str).group(1))
    tz = timezone(timedelta(hours=h))
    d = d.replace(tzinfo=tz)  # 在调用d.timestamp()前，先调用设置时区
    return d.timestamp()

t1 = to_timestamp(&#39;2015-6-1 08:10:30&#39;, &#39;UTC+7:00&#39;)
assert t1 == 1433121030.0, &#39;函数返回值:%s&#39; % t1

t2 = to_timestamp(&#39;2015-5-31 16:10:30&#39;, &#39;UTC-09:00&#39;)
assert t2 == 1433121030.0, &#39;函数返回值:%s&#39; % t2

print(&#39;Pass&#39;)
</code></pre></li>
</ul>

<h5 id="toc_5">13.2 collections</h5>

<ul>
<li>collections是Python内建的一个集合模块，提供了许多有用的集合类</li>
<li><p>a. namedtuple</p>

<ul>
<li>tuple是不可变集合，使用tuple可以表示一个坐标(x, y)，但是无法直接以x、y属性形式去访问值，而定义一个class又小题大做</li>
<li>namedtuple是一个函数，可以创建一个自定义的tuple对象，之后可以以属性形式而不是索引形式去访问tuple的某个元素，使用非常方便</li>
</ul>

<pre><code class="language-python">from collections import namedtuple

Point = namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])
p = Point(1, 2)
print(&#39;x:&#39;, p.x)
print(&#39;y:&#39;, p.y)
print(isinstance(p, Point)) # True
print(isinstance(p, tuple)) # True

Circle = namedtuple(&#39;Circle&#39;, [&#39;x&#39;, &#39;y&#39;, &#39;r&#39;])；
</code></pre></li>
<li><p>b. duque</p>

<ul>
<li>使用list存储数据时，按索引访问元素很快，但是插入删除元素就比较慢（list是线性存储）</li>
<li>deque是双向链表，可以高效地插入删除元素，适合用于队列和栈</li>
<li>deque除了实现list的append()和pop()外，还支持appendleft()和popleft()可以高效地向队列的头部添加删除元素，也可以按照索引取值</li>
</ul>

<pre><code class="language-python">from collections import deque

q = deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
q.append(&#39;x&#39;)
q.appendleft(&#39;y&#39;)
print(q)
print(q[2])
</code></pre></li>
<li><p>c. defaultdict</p>

<ul>
<li>使用dict时，若key不存在则抛出KeyError；若希望key不存在时就返回一个默认值，可以使用defaultdict</li>
<li>默认值是由创建defaultdict对象时传入的函数调用返回的</li>
<li>除了在key不存在时返回一个默认值，defaultdict的使用和dict是完全一样</li>
</ul>

<pre><code class="language-python">from collections import defaultdict

dd = defaultdict(lambda: &#39;N/A&#39;)  # 传入提供默认值的函数
dd[&#39;key1&#39;] = &#39;abc&#39;
print(dd[&#39;key1&#39;]) # abc
print(dd[&#39;key2&#39;]) # N/A
</code></pre></li>
<li><p>d. OrderDict</p>

<ul>
<li>dict的key是无序的，在对dict做迭代时无法确定key的顺序；若要保持key的顺序可以用OrderDict</li>
</ul>

<pre><code class="language-python">from collections import OrderedDict

l = [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]

d = dict(l)
print(d)

od = OrderedDict(l)  # 通过list构造dict
print(od)

od = OrderedDict()
# key会按照插入的顺序排序，不是key本身排序
od[&#39;z&#39;] = 1
od[&#39;y&#39;] = 2
od[&#39;x&#39;] = 3
print(list(od.keys()))
</code></pre>

<pre><code class="language-python"># 使用OrderedDict实现一个FIFO的dict，当容量超出限制时，先删除最早添加的元素
from collections import OrderedDict

class LastUpdateOrderedDict(OrderedDict):
    def __init__(self, capacity):
        super(LastUpdateOrderedDict, self).__init__()
        self.__capcity = capacity

    def __setitem__(self, key, value):
        contains_key = 1 if key in self else 0  # Python三元表达式 
        if len(self) - contains_key &gt;= self.__capcity:
            # last为True是LIFO即为堆栈，反之是FIFO即为队列
            last = self.popitem(last=False)
            print(&#39;remove:&#39;, last)
        if contains_key:
            del self[key]  # 可以不删除，直接覆盖
            print(&#39;set:&#39;, (key, value))
        else:
            print(&#39;add:&#39;, (key, value))
        OrderedDict.__setitem__(self, key, value)  # 调用父类方法，添加元素
</code></pre>

<pre><code class="language-python"># 补充（两个list合并成dict）：
list1 = [&#39;key1&#39;, &#39;key2&#39;, &#39;key3&#39;]
list2 = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]
d = dict(zip(list1, list2))
print(d)
</code></pre></li>
<li><p>e. Counter</p>

<ul>
<li>一个简单的计数器，实际上是dict的一个子类</li>
</ul>

<pre><code class="language-python"># 统计字符出现的个数
from collections import Counter

c = Counter()
for ch in &#39;programming&#39;:
    c[ch] += 1
print(c)  

# Counter({&#39;r&#39;: 2, &#39;g&#39;: 2, &#39;m&#39;: 2, &#39;i&#39;: 1, &#39;n&#39;: 1, &#39;o&#39;: 1, &#39;a&#39;: 1, &#39;p&#39;: 1})
</code></pre></li>
</ul>

<h5 id="toc_6">13.3 base64</h5>

<ul>
<li>若使用记事本打开exe、jpg等二进制文件会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符；若让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法，base64是一种常见的二进制编码方法</li>
<li>base64用64个可打印字符可以表示任意二进制数据</li>
<li>base64编码原理

<ul>
<li>a. 先准备一个包含64个字符的数组表[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, .... &#39;a&#39;,...&#39;0&#39;,... &#39;+&#39;,&#39;/&#39;]</li>
<li>b. 对二进制数据进行处理，每3个字节为一大组（3*8=24bit），再每6个bit分隔为一小组，共4小组</li>
<li>c. 根据得到的4个小组对应的数值（小于64）做索引，在上面的数组表中查找获取相应的4个字符，这些字符就是编码之后的字符</li>
<li>d. 若分大组时剩余的字节数不是3的倍数（8、16bit）则无法被6整除，需要在末尾补bit0（分别补4、2个bit0后为12、18bit，最后分别生成2、3个字符）；之后再在编码的末尾添加=号（剩余字节数为1时补2个=，剩余字节数为2时补1个=），让其满足编码后的字符数（含=）恰好是4的倍数，解码的时候=号会自动去掉</li>
</ul></li>
<li>base64编码会把3字节的二进制数据编码为4字节的文本数据，文件大小增加33%</li>
<li><p>Python内置了支持base64编码解码的base64模块</p>

<pre><code class="language-python">import base64

en = base64.b64encode(b&#39;binary\x00string&#39;)  # 编码，一共6+1+6个字节
print(en)  # b&#39;YmluYXJ5AHN0cmluZw==&#39;
de = base64.b64decode(b&#39;YmluYXJ5AHN0cmluZw==&#39;)  # 解码
print(de)
</code></pre></li>
<li><p>使用标准的base64编码可能出现字符/和+，但是字符/和+在URL中不能直接作为参数，所以出现了一种“url safe”的base64编码（其实就是把字符/和+分别变成_和-）</p>

<pre><code class="language-python">en = base64.b64encode(b&#39;i\xb7\x1d\xfb\xef\xff&#39;)
print(en)  # b&#39;abcd++//&#39;

sf_en = base64.urlsafe_b64encode(b&#39;i\xb7\x1d\xfb\xef\xff&#39;)
print(sf_en)  # b&#39;abcd--__&#39;
sf_de = base64.urlsafe_b64decode(b&#39;abcd--__&#39;)
print(sf_de)  # b&#39;i\xb7\x1d\xfb\xef\xff&#39;
</code></pre></li>
<li><p>编码中也可能也出现字符=，但字符=在URL、Cookie中会造成歧义；所以，很多base64编码会把字符=去掉，解码时先添加字符=再进行解码（base64编码本质就是让3字节变为4字节（字符），所以只需手动添加字符=让字符串的长度是4的倍数即可）</p></li>
<li><p>可以自定义64个字符的排序顺序，这样就是自定义base64编码，不过通常没有必要</p></li>
<li><p>base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行</p></li>
<li><p>base64适用于小段内容的编码，比如数字证书签名、Cookie、URL等</p>

<pre><code class="language-python"># 处理去掉=的base64的解码
import base64

def safe_base64_decode(s):
    # 3 % 4 = 3，-3 / 4 = 1； b&#39;=&#39; * 2结果为b&#39;==&#39;
    s += (-len(s) % 4) * b&#39;=&#39;
    return base64.b64decode(s)

assert b&#39;abcd&#39; == safe_base64_decode(b&#39;YWJjZA==&#39;), safe_base64_decode(&#39;YWJjZA==&#39;)
assert b&#39;abcd&#39; == safe_base64_decode(b&#39;YWJjZA&#39;), safe_base64_decode(&#39;YWJjZA&#39;)
print(&#39;Pass&#39;)
</code></pre></li>
<li><p>base64编码补充： </p>

<ul>
<li>早期的一些邮件服务器只支持文本信息，不支持二进制信息和文件，而base64编码后的结果都是ASCII纯文本的，适合用电子邮件来传送二进制数据</li>
<li>网页中的图片可以使用base64编码减少了HTTP请求（不是所有浏览器都支持），比如&lt;img src=&quot;data:image/gif;base64,R0lGODlhAwADAIABAL6+v=&quot;/&gt;，</li>
<li>在URL中若使用标准的base64编码，还需要进行urlencode，处理特殊字符+和/，或者将编码后的字符串进行特殊字符替换；建议直接使用urlsafe_b64encod()</li>
<li>urlencode：将除了-_.之外的其他非字母数字字符，编码成百分号%后跟2位十六进制数，空格则编码为加号+</li>
</ul></li>
</ul>

<h5 id="toc_7">13.4 struct</h5>

<ul>
<li><p>Python没有专门处理字节的数据类型，虽然str既可以表示字符串，又可以表示字节（b&#39;\x00\x9c&#39;）</p>

<pre><code class="language-python"># 把一个32位无符号整数变成字节（4个bytes），需要使用位运算（若是浮点数就无解了）
n = 10240099
print(&#39;%x&#39; % n)  # 9c4063

b1 = (n &amp; 0xff000000) &gt;&gt; 24
b2 = (n &amp; 0xff0000) &gt;&gt; 16
b3 = (n &amp; 0xff00) &gt;&gt; 8
b4 = n &amp; 0xff
print(&#39;%x, %x, %x, %x&#39; % (b1, b2, b3, b4))  # 0, 9c, 40, 63
bs = bytes([b1, b2, b3, b4])
print(bs)  # b&#39;\x00\x9c@c&#39;
</code></pre></li>
<li><p>struct模块可以解决bytes和二进制数据类型的转换（二进制文件的编码解码存储；这一部分操作通常是系统底层自动完成）；decode、endcode解决的是bytes和str的转换</p>

<pre><code class="language-python">import struct

# pack: 把任意数据类型变成bytes
# 第1参数是处理指令；&gt;表示字节顺序是big-endian，也就是网络序，
# I表示4字节无符号整数，H表示2字节无符号整数，f表示4字节float，d表示8字节double...
b = struct.pack(&#39;&gt;I&#39;, 10240099)
print(b)  # b&#39;\x00\x9c@c&#39;

# 多个参数：参数个数要和处理指令中的一致
# &gt;IH表示要转换的依次为：4字节无符号整数、2字节无符号整数
b = struct.pack(&#39;&gt;IH&#39;, 10240099, 32896)
print(b)  # b&#39;\x00\x9c@c\x80\x80&#39;

# unpack：把bytes变成相应的数据类型
s = struct.unpack(&#39;&gt;I&#39;, b&#39;\x00\x9c@c&#39;)
print(s)  # (10240099,)

s = struct.unpack(&#39;&gt;IH&#39;, b&#39;\x00\x9c@c\x80\x80&#39;) 
print(s)  # (10240099, 32896)
</code></pre></li>
<li><p>尽管Python不适合编写底层操作字节流的代码，但是对性能要求不高的地方使用struct还是比较方便</p>

<pre><code class="language-python"># 举例：使用struct分析Windows的位图文件（.bmp)，读取前30个字节来分析
s = b&#39;\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00&#39; \
    b&#39;\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01&#39; \
    b&#39;\x00\x00\x01\x00\x18\x00&#39;
s = struct.unpack(&#39;&lt;ccIIIIIIHH&#39;, s)
print(s)  # (b&#39;B&#39;, b&#39;M&#39;, 691256, 0, 54, 40, 640, 360, 1, 24)

BMP格式采用小端方式存储数据，文件头的结构按顺序如下：
两个字节：&#39;BM&#39;表示Windows位图，&#39;BA&#39;表示OS/2位图；
一个4字节整数：表示位图大小；
一个4字节整数：保留位，始终为0；
一个4字节整数：实际图像的偏移量；
一个4字节整数：Header的字节数；
一个4字节整数：图像宽度；
一个4字节整数：图像高度；
一个2字节整数：始终为1；
一个2字节整数：颜色数。
</code></pre></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(11进程和线程)]]></title>
    <link href="http://www.justisit.com/15125773962077.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773962077.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">11. 进程和线程</a>
</li>
<li>
<a href="#toc_1">11.1 概述</a>
</li>
<li>
<a href="#toc_2">11.2 多进程</a>
<ul>
<li>
<a href="#toc_3">a. fork()函数</a>
</li>
<li>
<a href="#toc_4">b. Process（multiprocessing模块）</a>
</li>
<li>
<a href="#toc_5">c. Pool（multiprocessing模块）</a>
</li>
<li>
<a href="#toc_6">d. subprocess</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">11.3 进程间通信</a>
</li>
<li>
<a href="#toc_8">11.4 多线程</a>
<ul>
<li>
<a href="#toc_9">a. Lock（线程同步）</a>
</li>
<li>
<a href="#toc_10">b. 多核CPU（多线程执行）</a>
</li>
<li>
<a href="#toc_11">c. ThreadLocal（数据独立）</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">11.5 进程 VS 线程</a>
<ul>
<li>
<a href="#toc_13">a. 计算密集型 VS IO密集型</a>
</li>
<li>
<a href="#toc_14">b. 异步IO</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">11.6 分布式进程</a>
</li>
</ul>


<h4 id="toc_0">11. 进程和线程</h4>

<h4 id="toc_1">11.1 概述</h4>

<ul>
<li>多任务：简单地说就是系统可以同时运行多个任务</li>
<li>对于系统来说，一个任务就是一个进程（Process）

<ul>
<li>单核CPU：系统轮流让各个任务交替执行，由于CPU的执行速度太快，感觉所有任务都是在同时执行</li>
<li>多核CPU：真正实现并行执行多任务，由于任务数量远远多于CPU的核心数量，所以系统会自动把多任务轮流调度到每个核心上执行</li>
</ul></li>
<li>有些进程要同时干多件事（比如Word，同时进行打字、拼写检查、打印等），就需要同时运行多个“子任务”，进程内的这些“子任务”称之为线程（Thread）

<ul>
<li>线程是最小的执行单元</li>
<li>由于每个进程至少要干一件事，所以，一个进程至少有一个线程</li>
<li>多个线程也是可以同时执行，执行方式和多个进程类似，由系统在多个线程之间快速切换；但真正地同时执行多线程需要多核CPU</li>
</ul></li>
<li>同时执行多个任务有以下解决方案：

<ul>
<li>a. 多进程模式：启动多个进程，每个进程虽然只有一个线程，但多个进程可以一起执行多个任务</li>
<li>b. 多线程模式：启动一个进程，在一个进程内启动多个线程，这样多个线程可以一起执行多个任务</li>
<li>c. 多进程+多线程模式：启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了；这种模型更复杂，实际很少采用</li>
</ul></li>
<li>同时执行多个任务，通常各个任务之间并不是没有关联的，而是需要互相通信和协调的；多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂</li>
<li>Python既支持多进程，又支持多线程</li>
</ul>

<span id="more"></span><!-- more -->

<h4 id="toc_2">11.2 多进程</h4>

<h5 id="toc_3">a. fork()函数</h5>

<ul>
<li>普通的函数调用，调用一次，返回一次</li>
<li>Uinx/Linux系统提供了一个fork()函数（Windows没有该函数）；但是fork()调用一次，返回两次，系统会自动把当前进程（称为父进程）复制了一份（称为子进程），然后分别在父进程和子进程内返回

<ul>
<li>父进程返回子进程的ID，子进程永远返回0；一个父进程可以fork出很多子进程，所以父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID</li>
<li>Python的os模块封装了常见的系统调用，其中就包含fork</li>
</ul></li>
<li><p>有了fork()，一个进程在接到新任务时就可以复制出一个子进程来处理新任务；常见的Apcache Server就是由父进程监听端口，当有新的http请求时，就fork出子进程来处理新的http请求</p>

<pre><code class="language-python">import os

print(&quot;Process (%s) start...&quot;, os.getpid())

pid = os.fork()
if pid == 0: # child process
    print(&#39;I am child process (%s) and my parent is %s.&#39; % (os.getpid(), os.getppid()))
else:
    print(&#39;I (%s) just created a child process (%s)&#39; % (os.getpid(), pid))

# 输出结果
Process (%s) start... 1388
I (1388) just created a child process (1389)
I am child process (1389) and my parent is 1388.
</code></pre></li>
</ul>

<h5 id="toc_4">b. Process（multiprocessing模块）</h5>

<ul>
<li><p>Python是跨平台的，提供了multiprocessing模块支持跨平台的多进程；其中Process类代表一个子进程</p>

<pre><code class="language-python">import os
from multiprocessing import Process

# 子进程要执行的代码
def run_proc(name):
    print(&#39;Run child process %s (%s)...&#39; % (name, os.getpid()))

if __name__ == &#39;__main__&#39;:
    print(&quot;Parent process %s.&quot; % os.getpid())
    # 创建一个子进程（Process实例）
    p = Process(target=run_proc, args=(&#39;ABC&#39;, )) 
    print(&#39;Child process will start.&#39;)
    # start()方法启动子进程
    p.start()
    # join()方法等待该子进程结束后再继续往下运行（通常用于进程间的同步）
    p.join() 
    print(&#39;Child process end.&#39;)

# 输出结果
Parent process 1516.
Child process will start.
Run child process ABC (1517)...
Child process end. # 后打印，由于p.join()导致的
</code></pre></li>
</ul>

<h5 id="toc_5">c. Pool（multiprocessing模块）</h5>

<ul>
<li><p>若要启动大量的子进程，可以用进程池Pool批量创建子进程</p>

<pre><code class="language-python">import os, time, random
from multiprocessing import Pool

def long_time_task(name):
    print(&#39;Run task %s (%s)...&#39; % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print(&#39;Task %s run %.2f seconds.&#39; % (name, (end - start)))

if __name__ == &#39;__main__&#39;:
    print(&#39;Parent processs %s.&#39; % os.getpid())
    pl = Pool(4)
    for i in range(5):
        pl.apply_async(long_time_task, args=(i,))
    print(&#39;Waiting for all subprocesses dones...&#39;)
    # 调用close()之后就不能添加新的Process
    pl.close()
    # 调用join()之前必须先调用close()
    pl.join()
    print(&#39;All subprocesses done.&#39;)

# 输入结果是task 0, 1, 2, 3是立即执行的，task 4要等待前面某个task完成后才执行
# 这是因为设置Pool的大小为4（不设置，默认是当前电脑的CPU核数），因此最多同时执行4个子进程
# 可以设置其他数值，比如5，这样5个子进程可以同时执行
</code></pre></li>
</ul>

<h5 id="toc_6">d. subprocess</h5>

<ul>
<li>很多情况下，其他多进程并不是我们自己创建的子进程，而是外部进程</li>
<li><p>之前其他进程是自己创建的子进程，很容易控制子进程的输入和输出；对于外部进程，subprocess模块提供启动外部进程、控制其输入和输出的功能</p>

<pre><code class="language-python"># 举例：在python代码中运行命令&quot;nslookup www.python.org&quot;
import subprocess

# 调用nslookup并添加参数，返回结果码
r = subprocess.call([&#39;nslookup&#39;, &#39;www.python.org&#39;]) 
print(&#39;Exit code:&#39;, r)

# 若子进程还需要输入，则可以通过commuicate()方法输入
proc = subprocess.Popen([&#39;nslookup&#39;], stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
out, err = proc.communicate(b&#39;set q=mx\npython.org\nexit\n&#39;)
print(out.decode(&#39;utf-8&#39;))
print(&#39;Exit code&#39;, p.returncode)

# 上面的代码相当于：在命令行执行&quot;nslookup&quot;后，再手动输入以下内容
set q=mx
python.org
exit
</code></pre></li>
</ul>

<h4 id="toc_7">11.3 进程间通信</h4>

<ul>
<li><p>系统提供了很多机制来实现进程间的通信；Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式供进程间交换数据</p>

<pre><code class="language-python"># 以Queue方式交换数据
# 在父进程中创建两个进程，一个往Queue中写数据，一个从Queue中读数据
from multiprocessing import Process, Queue
import os, time, random

# 写数据的进程
def write(q):
    print(&#39;Process to write: %s&#39; % os.getpid())
    for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:
        print(&#39;Put %s to queue...&#39; % value)
        q.put(value)  # 向Queue中写数据
        time.sleep(random.random())

# 读数据的进程
def read(q):
    print(&#39;Process to read: %s&#39; % os.getpid())
    while True:
        value = q.get(True)  # 从Queue中读数据
        print(&#39;Get %s from queue.&#39; % value)

if __name__ == &#39;__main__&#39;:
    # multiprocess.Queue为跨进程通信队列，各子进程共有
    q = Queue() 
    # 父进程创建Queue，并传给各个子进程
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    pw.start()  # 启动子进程pw写入
    pr.start()  # 启动子进程pr读取
    pw.join()  # 等待进程pw结束
    pr.terminate()  # 进程pr是死循环，只能强行终止（在pw结束后，此时写入已完毕）
</code></pre></li>
</ul>

<h4 id="toc_8">11.4 多线程</h4>

<ul>
<li>Python的线程是真正的&quot;Posix Thread&quot;，而不是模拟出来的</li>
<li>Python提供了_thread、threading两个模块支持多线程；_thread是低级模块，threading是高级模块（对_thread进行了封装；绝大多数情况下使用）</li>
<li><p>启动一个线程：创建Threading实例并把一个函数传入，然后调用start()开始执行</p>

<pre><code class="language-python">import time, threading

# 新线程执行的代码
def loop():
    print(&#39;thread %s is running...&#39; % threading.current_thread().name) # current_thread()函数返回当前线程的实例
    n = 0
    while n &lt; 5:
        n += 1
        print(&#39;thread %s &gt;&gt; %s&#39; % (threading.current_thread().name, n))
        time.sleep(1)
    print(&#39;thread %s ended.&#39; % threading.current_thread().name)

print(&#39;thread %s is running...&#39; % threading.current_thread().name)
t = threading.Thread(target=loop, name=&#39;LoopThread&#39;)
t.start()
t.join()  # join()也能阻塞线程
print(&#39;thread %s ended.&#39; % threading.current_thread().name)
</code></pre></li>
<li><p>任何进程默认就会启动一个线程，被称为主线程（线程实例名字叫&quot;MainThread&quot;）；主线程又可以启动新的子线程（线程实例名字在创建时指定，若不指定则自动命名为&quot;Thread-1&quot;、&quot;Thread-2&quot;...）</p></li>
</ul>

<h5 id="toc_9">a. Lock（线程同步）</h5>

<ul>
<li><strong>进程间通信主要是指多个进程间的数据交互,而线程间同步主要指维护多个线程之间数据准确、一致性</strong></li>
<li><p>在多进程中，变量在每个进程各自有一份拷贝，互不影响；而在多线程中，变量是所有线程共享，都可以被任何一个线程修改</p>

<pre><code class="language-python"># 模拟由于多线程，导致的数据错乱
import time, threading

balance = 0  # 假设银行存款

# 先存后取,结果应该为0
def change_it(n):
    # 声明为全局变量，这样可以就在函数内部&#39;修改&#39;变量值；
    # 否则，Python会认为该变量是函数内局部的，函数之外（主块）
    # 的同名变量是另一个变量，修改该变量（内部的）不会对外部的产生影响
    global balance  
    balance += n
    balance -= n

def run_thread(n):
    for i in range(1000000):
        change_it(n)

t1 = threading.Thread(target=run_thread, args=(2, ))
t2 = threading.Thread(target=run_thread, args=(8, ))
t1.start()
t2.start()
t1.join()
t2.join()
print(balance)
</code></pre>

<pre><code class="language-python"># 为确保balance计算正确，要给change_it()上一把锁；
# 当某个线程开始执行change_it()时获取了锁，因此其他线程不能同时
# 执行change_it()，只能等到锁被释放后，获取到该锁以后才能改
import time, threading

lock = threading.Lock()
balance = 0

def change_it(n):
    global balance
    balance += n
    balance -= n

def run_thread(n):
    for i in range(1000000):
        # 先要获取锁
        lock.acquire()
        try:
            change_it(n)
        finally:
            # 改完后一定要释放锁
            lock.release()

t1 = threading.Thread(target=run_thread, args=(2, ))
t2 = threading.Thread(target=run_thread, args=(8, ))
t1.start()
t2.start()
t1.join()
t2.join()
print(balance)
</code></pre></li>
<li><p>通过threading.Lock()创建一个锁；由于锁只有一个，同一时刻最多只有一个线程持有该锁，所以不会造成修改的冲突</p></li>
<li><p>获取到锁的线程用完后一定要释放锁，否则那些等待锁的线程将永远等待下去，成为死线程；用try...finally来确保锁一定会被释放</p></li>
<li><p>锁的好处是确保某段关键代码只能由一个线程从头到尾完整地执行，坏处是阻止了多线程并发执行</p></li>
<li><p>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成<strong>死锁</strong>，导致多个线程全部挂起，既不能执行，也无法结束，只能由系统强制终止</p></li>
</ul>

<h5 id="toc_10">b. 多核CPU（多线程执行）</h5>

<ul>
<li><p>若想让N核CPU的核心全部跑满，就必须启动N个死循环线程；比如，在多核CPU中，有2个死循环线程，会监控到占用200%的CPU，也就是占用2个CPU核心</p>

<ul>
<li>使用Python启动CPU核心数量的多个线程，比如在4核CPU上，会监控到CPU占用率为102%，也就是使用1核</li>
<li>使用C、C++、Java来改写相同的死循环，却可以把全部核心跑满（4核就用400%，8核就用800%），而Python却不可以</li>
</ul>

<pre><code class="language-python"># 尝试使用Python编写一个死循环（谨慎使用）
import threading, multiprocessing

def loop():
    x = 0
    while True:
        x = x ^ 1

for i in range(multiprocessing.cpu_count()):
    t = threading.Thread(target=loop)
    t.start()
</code></pre></li>
<li><p>Python的线程虽然是真正的线程，但是解释器执行代码时，有一个GIL锁（Gloabal Interpreter Lock)</p></li>
<li><p>任何线程执行前，必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行</p></li>
<li><p>GIL全局锁实际上把所有线程的执行代码都给上了锁，所以多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核</p></li>
<li><p>GIL是Python解释器设计的历史遗留问题，通常我们使用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器</p></li>
<li><p>Python虽然不能利用多线程实现多核任务（即不能并行；但可以并发），但是可以通过多进程实现多核任务；多个Python进程有各自独立的GIL锁，互不影响</p></li>
</ul>

<h5 id="toc_11">c. ThreadLocal（数据独立）</h5>

<ul>
<li><p>每个线程都有自己的数据；一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有当前线程可见，不会影响其他线程，而全局变量的修改必须加锁；但是使用局部变量，在函数调用的时候传递起来很麻烦</p>

<pre><code class="language-python">def process_thread():
    # std是局部变量，每个函数调用都必须传入
    # 这里不能使用全局变量，因为每个线程（process_thread）要处理不同的Student对象
    std = Student(name)
    func1(std)
    func2(std)
    func3(std)
    func4(std)
</code></pre></li>
<li><p>解决方案：使用一个全局的dict存放所有的Student对象，然后以thread自身作为key获取该线程对应的Student对象</p>

<pre><code class="language-python">global_dict = {}

def process_thread():
    std = Student(name)
    # 把std存放到全局变量globalDict中
    global_dict[threading.current_thread()] = std
    func1() 
    func2()
    func3()
    func4()
# funX()函数中使用s = global_dict[threading.current_thread()]的方式进行获取
</code></pre></li>
<li><p>Python的ThreadLocal提供上面的代码的封装，不用人为创建用于查找的dict，ThreadLocal自动做这件事情</p>

<pre><code class="language-python">import threading

class Student(object):
    def __init__(self, name):
        self.name = name

# a. 创建一个全局的ThreadLocal对象
local_student = threading.local()

def process_thread(name):
    # b. 绑定ThreadLocal的student
    local_student.std = Student(name)
    func1()

def func1():
    # c. 获取当前线程相关的student
    std = local_student.std
    print(&#39;Hello, %s, %s&#39; % (std.name, threading.current_thread().name))

t1 = threading.Thread(target=process_thread, args=(&#39;Tom&#39;, ), name=&#39;Thread-A&#39;)
t2 = threading.Thread(target=process_thread, args=(&#39;Jack&#39;, ), name=&#39;Thread-B&#39;)
t1.start()
t2.start()
# local\_student是全局变量，但是它的每个属性（如std）
# 是线程的局部变量，可以不用加锁任意读写互不干扰
</code></pre></li>
<li><p>ThreadLocal常见使用场景：为每个线程绑定一个数据库连接、HTTP请求、用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源</p></li>
</ul>

<h4 id="toc_12">11.5 进程 VS 线程</h4>

<ul>
<li>要实现多任务，通常会设计Master-Worker模式，Master（一个）负责分配任务，Worker（多个）负责执行任务；若用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker；若用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker</li>
<li>a. 多进程Master-Worker：

<ul>
<li>优点是稳定性高，一个子进程崩溃不会影响主进程和其他子进程（若主进程挂了则其他子进程也都会挂，但主进程只负责分配任务，挂掉的概率低）</li>
<li>缺点是创建进程的代价大（在Uinx/Linux使用fork调用还行，在Windows下创建进程开销巨大）；而且系统能同时运行的进程数也是有限制的，大量进程的系统调度也会成问题</li>
</ul></li>
<li>b. 多进程Master-Worker：

<ul>
<li>优点是通常比多进程快（但不明显）</li>
<li>缺点是任何一个线程挂掉都可能导致整个进程的崩溃，因为所有线程共享进程的内存</li>
</ul></li>
<li>无论是多进程还是多线程，只有任务数量一多，系统可能就主要忙着切换任务（保护现场、准备新环境），根本没有多少时间去执行任务，效率就上不去了</li>
</ul>

<h5 id="toc_13">a. 计算密集型 VS IO密集型</h5>

<ul>
<li>是否采用多任务还要考虑任务类型，可以任务分为计算密集型和IO密集型</li>
<li>计算密集型：

<ul>
<li>需要大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码，要高效利用CPU</li>
<li>任务同时进行的数量应当等于CPU的核心数；同时代码运行效率也很重要（Python运行效率很低，最好使用C语言编写）</li>
</ul></li>
<li>IO密集型：

<ul>
<li>涉及到网络、硬盘IO任务，消耗CPU很少，任务的大部分时间都在等待IO操作完成（IO速度远远低于CPU和内存速度）；</li>
<li>任务越多，CPU效率越高，但也有一个限度；最合适的语言就是开发效率高的语言，而不是运行速度极快的语言</li>
</ul></li>
</ul>

<h5 id="toc_14">b. 异步IO</h5>

<ul>
<li>由于CPU和IO之间的巨大速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程、单线程会导致别的任务无法并行执行，因此需要多进程、多线程支持任务并发执行</li>
<li>现在的系统对IO操作已做了巨大的改进，最大的特点就是支持异步IO</li>
<li>异步IO

<ul>
<li>可以用单进程、单线程模型来执行多任务，这种全新的模型称为事件驱动模型</li>
<li>Nginx就是支持异步IO的Web服务器，在单核CPU上采用单进程模型就可以高效支持多任务，在多核CPU上可以运行和CPU核心数相同的多个进程，充分利用多核CPU</li>
<li>使用异步IO来实现多任务是一个主要趋势</li>
</ul></li>
<li>Python中的<strong>单进程</strong>的<strong>异步编程模型</strong>称为<strong>协程（Coroutine）</strong></li>
</ul>

<h4 id="toc_15">11.6 分布式进程</h4>

<ul>
<li>在Process和Thread中应当优选Process，因为Process更稳定，而且Process可以分布在多台机器上，而Thread最多只能分布到同一台机器的多个CPU上</li>
<li><p>Python的multiprocessing模块不仅支持多进程，而且其managers子模块还支持把多进程分布到多台机器上；一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信</p>

<ul>
<li>之前的Queue不仅可以让两个进程在同一机器上进行通信，也可以让这两个进程在两个机器进行通信；继续使用原来的Queue，使用managers模块把Queue通过网络暴露出去，就可以让其他机器的进程访问该Queue了</li>
<li>服务进程负责启动Queue，把Queue注册到网络上，然后往Queue里面写入任务</li>
</ul>

<pre><code class="language-python"># 服务进程：task_master.py
import random, queue
from multiprocessing.managers import BaseManager

class QueueManager(BaseManager):  # 从BaseManager继承的QueueManager
    pass

task_queue = queue.Queue()    # 发送任务的队列
result_queue = queue.Queue()  # 接收结果的队列

# 把两个Queue都注册到网络上（name、callable参数关联的Queue对象）
QueueManager.register(&#39;get_task_queue&#39;, callable=lambda: task_queue)
QueueManager.register(&#39;get_result_queue&#39;, callable=lambda: result_queue)

# 绑定端口5000，设置验证码authkey进行机器验证
manager = QueueManager(address=(&#39;&#39;, 5000), authkey=b&#39;abc&#39;)
manager.start()  # 启动

# 获取通过网络访问的Queue对象
task = manager.get_task_queue()
result = manager.get_result_queue()

# 放几个任务进去
for i in range(10):
    n = random.randint(0, 10000)
    print(&#39;Put task %d...&#39; % n)
    task.put(n)

# 从result队列中读取结果
print(&#39;Try get result...&#39;)
for i in range(10):
    r = result.get(timeout=10)
    print(&#39;Result: %s&#39; % r)

manager.shutdown()  # 关闭
print(&#39;master exit...&#39;)
</code></pre></li>
<li><p>当在一台机器上编写多进程时，创建的Queue可以直接拿来使用；但是在分布式多进程情况下，不可以直接对原始的task_queue进行“添加任务到Queue”操作，必须使用通过manager.get_task_queue()获取Queue，进行添加（否则绕过了QueueManager对Queue的封装，注册Queue也就没有意义）；result_queue同理</p>

<pre><code class="language-python"># 任务进程：task_worker.py
import time, queue
from multiprocessing.managers import BaseManager

class QueueManager(BaseManager):  # 创建类似的QueueManager
    pass

# 由于只能从网络上获取Queue，所以注册时只提供name
# 注意服务进程和任务进程的注册Queue的名称要一致，否则报错
QueueManager.register(&#39;get_task_queue&#39;)
QueueManager.register(&#39;get_result_queue&#39;)

# 连接到服务器，也就是运行task_master.py的机器
# 任务进程需要通过网络连接到服务进程，要指定服务进程的IP
server_addr = &#39;127.0.0.1&#39;
print(&#39;Connect to server %s...&#39; % server_addr)
# 端口和验证码注意要和task_master.py设置的一致
manager = QueueManager(address=(server_addr, 5000), authkey=b&#39;abc&#39;)
manager.connect()  # 网络连接

# 获取通过网络访问的Queue对象
task = manager.get_task_queue()
result = manager.get_result_queue()

# 从task队列取任务，并把结果写入result队列
for i in range(10):
    try:
        n = task.get(timeout=1)
        print(&#39;run task %d...&#39; % n)
        r = &#39;%d * %d = %d&#39; % (n, n, n * n)
        time.sleep(1)
        result.put(r)
    except Queue.Empty:
        print(&#39;task queue is empty.&#39;)

# 处理结束，注意不要调用manager.shutdown()
print(&#39;worker exit...&#39;)
</code></pre></li>
<li><p>task_worker.py中并没有创建Queue，Queue对象在task_master.py进程中；使用QueueManager实现能够通过网络访问Queue</p></li>
<li><p>Queue的作用就是用来传递任务和接收结果，每个任务的描述数量要尽量小；比如，发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，再由Worker进程去路径位置读取日志文件</p></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(10IO编程)]]></title>
    <link href="http://www.justisit.com/15125773962028.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773962028.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">10. IO编程</a>
</li>
<li>
<a href="#toc_1">10.1 概述</a>
</li>
<li>
<a href="#toc_2">10.2 读写文件</a>
<ul>
<li>
<a href="#toc_3">a. 读文件</a>
</li>
<li>
<a href="#toc_4">b. 写文件</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">10.3 StringIO、BytesIO</a>
</li>
<li>
<a href="#toc_6">10.4 操作文件和目录</a>
</li>
<li>
<a href="#toc_7">10.5 序列化</a>
<ul>
<li>
<a href="#toc_8">a. JSON</a>
</li>
<li>
<a href="#toc_9">b. JSON进阶</a>
</li>
</ul>
</li>
</ul>


<h4 id="toc_0">10. IO编程</h4>

<h4 id="toc_1">10.1 概述</h4>

<ul>
<li>流只能单向流动；既收又发数据就必须建立两个流（输入流、输出流）</li>
<li>在IO编程中，存在着速度严重不匹配额问题，解决方式有两种：

<ul>
<li>a. CPU暂停执行后续代码，等待数据读取或写入完毕后再执行（同步IO模式）</li>
<li>b. CPU不等待继续执行后续代码，数据读取或写入一边进行着（异步IO模式）</li>
</ul></li>
<li>同步IO和异步IO的区别是否等待IO执行的结果；使用异步IO来编写的程序性能远远高于同步IO，但是异步IO的缺点是编程模型复杂，异步IO需要“通知”别人其已执行完毕，“通知”有两种：

<ul>
<li>a. 回调，IO主动告诉别人</li>
<li>b. 轮询，别人不断去检查IO是否执行完毕</li>
</ul></li>
<li>操作IO的能力是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外</li>
<li>本章讨论的IO编程都是同步模式的</li>
</ul>

<span id="more"></span><!-- more -->

<h4 id="toc_2">10.2 读写文件</h4>

<ul>
<li>读写磁盘上的文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘</li>
<li>读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后使用系统提供的接口从这个文件对象中读取数据、或者把数据写入这个文件对象</li>
</ul>

<h5 id="toc_3">a. 读文件</h5>

<ul>
<li>打开文件：<code>f = open(&#39;modeltest.py&#39;, &#39;r&#39;)</code> ，传入文件名和标示符（&#39;r&#39;表示读）；若文件不存在，这会抛出一个IOError（FileNotFoundError）异常</li>
<li>读文件：read()方法可以一次性读取文件的全部内容到内存中</li>
<li>关闭文件：调用close()方法关闭文件；文件使用完毕后必须关闭，因为文件对象会占用系统的资源，并且系统同一时间能打开的文件数量也是有限的</li>
<li><p>由于文件读写可能产生IOError，一旦异常错误会导致后面的close()方法不被调用了，所以要处理异常（在此位置关闭文件）</p>

<pre><code class="language-python"># try...finally来实现
try:
    f = open(&#39;modeltest.py&#39;, &#39;r&#39;)  # 默认调用read()方法时返回文本字符串（以UTF-8解码）
    print(f.read())
finally:
    if f:
        f.close()
</code></pre></li>
<li><p>Python引入了<code>with</code>语句可以自动调用close()方法，不需要认为调用close()方法，简化代码书写</p>

<pre><code class="language-python">with open(&#39;modeltest.py&#39;, &#39;r&#39;) as f:
    print(f.read())
</code></pre></li>
<li><p>调用read(size)方法，每次最多读取size个字节的内容；不加size参数则读取全部内容</p></li>
<li><p>调用readline()可以每次读取一行内容；调用readlines()一次读取所有内容并按行返回list</p></li>
<li><p>若文件小则调用read()，若不确定文件大小则反复调用read(size)比较保险，若是配置文件则调用readlines()最方便</p>

<pre><code class="language-python">with open(&#39;modeltest.py&#39;, &#39;r&#39;) as f:
    for line in f.readlines():
        print(line.strip())  # 将末尾的&#39;\n&#39;删掉
</code></pre></li>
<li><p>像open()函数返回的这种有read()方法的对象，在Python中统称为file-like Object；file-like Object除了file，还可以是内存的字节流、网络流、自定义流等，其不要求从特定类继承，只要有read()方法即可；比如，StringIO就是内存中创建的file-like Object，常用作临时缓冲</p></li>
<li><p>上面讲的都是调用read()方法时返回文本字符串（以UTF-8解码），若要调用read()方法时返回二进制数据，比如读取图片、视频等，则使用&#39;rb&#39;模式打开文件即可</p>

<pre><code class="language-python">with open(&#39;git.jpg&#39;, &#39;rb&#39;) as f:
    print(f.read())
# 返回数据
b&#39;\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00..&#39;

with open(&#39;orm.py&#39;, &#39;r&#39;) as f:
    print(f.read())  # 返回数据：class Field(object): 
with open(&#39;orm.py&#39;, &#39;rb&#39;) as f:
    print(f.read())  # 返回数据：b&#39;class Field(object):\r\n
</code></pre></li>
<li><p>字符编码：若要以指定编码读取文本文件，需要给open()函数传入encoding参数（二进制文件不需要encoding参数）；比如，读取UTF-8编码的文件</p>

<pre><code class="language-python">with open(&#39;orm.py&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
    print(f.read())
</code></pre></li>
<li><p>有些编码不规范的文本文件，可能夹杂了一些非法编码的字符，此时打开文件会抛出“UnicodeDecodeError”异常；open()函数还可接收一个errors参数，表示若遇到编码错误后该如何处理，最简单的方式是直接忽略</p>

<pre><code class="language-python">with open(&#39;orm.py&#39;, &#39;r&#39;, errors=&#39;ignore&#39;) as f:
    print(f.read())
</code></pre></li>
</ul>

<h5 id="toc_4">b. 写文件</h5>

<ul>
<li>在调用open()函数时，写文本文件传入标示符&#39;w&#39;、写二进制文件则传入标示符&#39;wb&#39;、追加文件则传入标示符&#39;a&#39;</li>
<li>可以反复调用write()写文件，最后必须调用close()关闭文件

<ul>
<li>当调用write()写文件时，系统不会立即把数据写入磁盘，而是先将数据放到内存缓存起来，空闲的时候再写入磁盘；只有调用close()方法，才能保证系统将数据全部写入磁盘</li>
</ul></li>
<li><strong>文件在磁盘中保存都是二进制数据的；有些二进制数据文件通过字符解码可以显示成有意义的文字，这些文字就是文本，那么这个文件就被称为文本文件；另一些二进制数据文件通过字符解码显示成无意义的文字，这个文字就不是文本，那么这个文件就被称为二进制文件，需要按照其他的特殊解码才能有意义，比如图片</strong></li>
<li><p><strong>编码是为了节约空间、标记数据类型，所以硬盘存储、网页传输都需要先编码</strong></p>

<pre><code class="language-python">with open(&#39;test.txt&#39;, &#39;w&#39;) as f:
    f.write(&#39;hello world&#39;)
</code></pre></li>
</ul>

<h4 id="toc_5">10.3 StringIO、BytesIO</h4>

<ul>
<li><p>数据的读写操作的不一定是文件，也可以是内存；StringIO就是在内存中读写str</p>

<pre><code class="language-python">from io import StringIO

f = StringIO()
f.write(&#39;hello&#39;)  # 写入数据
f.write(&#39; &#39;)
f.write(&#39;world&#39;)
print(f.getvalue())  # getValue()获取写入后的数据

# 用一个str初始化StringIO，之后就可以像操作文件的方式操作StringIO
f = StringIO(&#39;Hello\nWorld&#39;)  
while True:
    s = f.readline()
    if s == &#39;&#39;:
        break
    print(s.strip())
</code></pre></li>
<li><p>StringIO操作的只能是str，若需要操作二进制数据就需要使用BytesIO</p>

<pre><code class="language-python">from io import BytesIO

f = BytesIO()
# 注意写入的不是str，而是经过UTF-8编码的bytes
f.write(&#39;中文&#39;.encode(&#39;utf-8&#39;)) 
print(f.getvalue())

f = BytesIO(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)
print(f.read())
</code></pre></li>
</ul>

<h4 id="toc_6">10.4 操作文件和目录</h4>

<ul>
<li><p>要操作文件、目录，可以在命令行下输入系统提供的各种命令来完成，比如dir、cp等命令；其实系统提供的命令只是调用了系统提供的接口函数，Python内置的os模块也可以直接调用系统提供的接口函数</p>

<pre><code class="language-python">import os  # 导入os模块，注意os模块的某些函数与特定操作系统相关的

print(os.name)  # 系统类型，Linux、Unix、OSX是posix，Windows是nt
print(os.uname())  # 详细系统信息（Windows不支持）
print(os.environ)  # 系统的所有环境变量
print(os.environ.get(&#39;PATH&#39;))  # 获取环境变量PATH的值
print(os.environ.get(&#39;X&#39;, &#39;default&#39;))  # 获取环境变量X的值
</code></pre></li>
<li><p>操作文件、目录的函数有些在os模块中，有些在os.path模块中</p>

<pre><code class="language-python">os.mkdir(new) # 创建目录
os.rmdir(new) # 删除目录

base = os.path.abspath(&#39;.&#39;)  # 获取当前的绝对路径
print(base)
newpath = os.path.join(base, &#39;test&#39;)  # 拼接路径
print(newpath)
</code></pre></li>
<li><p>操作文件路径时不要直接拼接、拆分字符串，应该使用join()、split()函数，这样可以正确处理不同系统的文件路径分隔符</p></li>
<li><p>文件路径的拼接、拆分函数并不要求目录和文件真实存在，它们只是对字符串进行操作</p>

<pre><code class="language-python"># split拆分一个路径为两部分，后面一部分为最后级别的目录或文件名
print(os.path.split(&#39;/Users/scott/Desktop/task_master.py&#39;))  
# 结果：(&#39;/Users/scott/Desktop&#39;, &#39;task_master.py&#39;)

# splitext拆分一个路径为两部分，后面一部分为文件的扩展名
print(os.path.splitext(&#39;/Users/scott/Desktop/task_master.py&#39;))  
# 结果：(&#39;/Users/scott/Desktop/task_master&#39;, &#39;.py&#39;)

os.rename(&#39;test.txt&#39;, &#39;abc.txt&#39;)  # 文件重命名
os.remove(&quot;abc.txt&quot;)  # 删除文件
</code></pre></li>
<li><p>os模块没有提供复制文件的函数</p></li>
<li><p>shutil模块提供了copyfile()函数用于复制文件；该模块中还有其他实用函数，可以看作是os模块的补充</p>

<pre><code class="language-python">import shutil

shutil.copyfile(&quot;orm.py&quot;, &#39;orm.txt&#39;)  # 复制文件
</code></pre></li>
<li><p>os.listdir()函数可以列举文件；并且可以进一步进行过滤</p>

<pre><code class="language-python"># 列出当前目录下的所有目录
l = [x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)]
print(l)

# 列出当前目录下的所有的.py文件
l = [x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1]==&#39;.py&#39;]
print(l)
</code></pre>

<pre><code class="language-python"># 练习1：利用os模块编写一个实现ls -l输出程序
import os
from datetime import datetime

print(&#39;      Size    Last Modified       Name&#39;)
print(&#39;--------------------------------------------&#39;)
for f in os.listdir(os.path.abspath(&#39;.&#39;)):
    size = os.path.getsize(f)
    time = datetime.fromtimestamp(os.path.getmtime(f)).strftime(&#39;%Y-%m-%d %H:%M&#39;)
    flag = &#39;/&#39; if os.path.isdir(f) else &#39;&#39;
    print(&#39;%10d    %s    %s%s&#39; % (size, time, f, flag))

# 练习2： 打印当前目录及其子目录包含指定字符串的文件
import os

def search_key(path, key):
    fs = [x for x in os.listdir(path)]
    result = []
    for f in fs:
        f = os.path.join(path, f)
        if os.path.isdir(f):
              # listA.extend(listB)即复制listB中的元素到listA中
              # 注意这里不能使用append（若用append，则增加的是数组，而不是数组中的元素）
            result.extend(search_key(f, key))
        elif key in f:  # 判断字符串中是否包含指定字符串，可以用in来判断
            result.append(f)
    return result

l = search_key(os.path.abspath(&#39;.&#39;), &#39;xx&#39;)
print(l)
</code></pre></li>
</ul>

<h4 id="toc_7">10.5 序列化</h4>

<ul>
<li>把内存中的数据变为可存储数据的过程称之为序列化，在Python中叫pickling（pickle：腌渍泡菜等），其他语言中称为serialization、marshalling、flattening等；<strong>序列化之后，就可以把序列化后的内容写入磁盘或者网络传输到其他设备上</strong></li>
<li>反过来，把序列化的数据重新读到内存里的过程称之为反序列化，即unpickling</li>
<li>Python提供了picke模块来实现序列化、反序列化</li>
<li><p>picke.dump()函数（dump：倾倒、倾销）将对象序列化后写入一个file-like Object；picke.dumps()函数将对象序列化成一个bytes数据</p>

<pre><code class="language-python">import pickle

d = dict(name=&#39;Tom&#39;, age=20, score=99)
# 方式一：
with open(&#39;dump.txt&#39;, &#39;wb&#39;) as f:
    pickle.dump(d, f)
# dump.txt存放着Python保存的对象内部信息

# 方式二：
b = pickle.dumps(d)
print(b)
</code></pre></li>
<li><p>pickle.load()函数从一个file-like Object中直接反序列化出对象；pickle.loads()函数将一个bytes数据序列化出对象</p>

<pre><code class="language-python"># 方式一：
with open(&#39;dump.txt&#39;, &#39;rb&#39;) as f:
    d = pickle.load(f)      
print(d)

# 方式二：
d = pickle.loads(b) 
print(d)
</code></pre></li>
<li><p><strong>反序列化得到的对象只是内容和之前的一样，但是和之前的对象没有任何关系</strong></p></li>
<li><p>pickle是Python特有的序列化技术，不同语言的序列化后的数据不兼容；并且不同版本Python的pickle的数据可能彼此不兼容</p></li>
</ul>

<h5 id="toc_8">a. JSON</h5>

<ul>
<li><p>Python内置的json模块提供了Python对象到JSON字符串的转换</p>

<pre><code class="language-python">import json

# Obj TO Json str方式一：
# 将Python对象序列化成JSON字符串后写入file-like Object
with open(&#39;json.txt&#39;, &#39;w&#39;) as f:
    json.dump(d, f)

# Obj TO Json str方式二：
# 将对象序列化成JSON字符串，内容是标准的JSON字符串
d = dict(name=&#39;Tom&#39;, age=20, score=99)
s = json.dumps(d)  
print(s)

# Json str TO Obj方式一：
# 从file-like Object中读取JSON字符串后，反序列化为Python对象
with open(&#39;json.txt&#39;, &#39;r&#39;) as f:
    d = json.load(f)  
    print(d)

# Json str TO Obj方式二：
# 将JSON字符串反序列化为Python对象
json_str = &#39;{&quot;score&quot;: 99, &quot;age&quot;: 20, &quot;name&quot;: &quot;Tom&quot;}&#39;
d = json.loads(json_str) 
print(d)
</code></pre></li>
</ul>

<h5 id="toc_9">b. JSON进阶</h5>

<ul>
<li><p>对自定义对象进行序列化、反序列化需要设置“转换函数”（告诉dump如何去序列化），否则报TypeError错误</p>

<pre><code class="language-python">import json

class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score

# 转换函数        
def student2dict(stu):
    return {
        &#39;name&#39;: stu.name,
        &#39;age&#39;: stu.age,
        &#39;score&#39;: stu.score
    }
def dict2student(d):
     return Student(d[&#39;name&#39;], d[&#39;age&#39;], d[&#39;score&#39;])

# Obj TO Json str
# 序列化通过default参数设置转换函数
s = Student(&#39;Tom&#39;, 20, 10)
# 方式一：
print(json.dumps(s, default=student2dict)) 
# 方式二：
# 不人为自定义转换函数，使用lambda obj: obj.__dict__
# 通常class的实例都有一个__dict__属性（dict），
# 存储着属性name及value（定义了__slots__的class除外）
print(json.dumps(s, default=lambda obj: obj.__dict__))

# Json str TO Obj
# 反序列化通过object__hook参数设置转换函数
json_str = &#39;{&quot;score&quot;: 99, &quot;age&quot;: 20, &quot;name&quot;: &quot;Tom&quot;}&#39;
s = json.loads(json_str, object_hook=dict2student)
print(s)
</code></pre></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(09异常、测试)]]></title>
    <link href="http://www.justisit.com/15125773961976.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773961976.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">09. 异常、测试</a>
</li>
<li>
<a href="#toc_1">9.1 异常</a>
<ul>
<li>
<a href="#toc_2">a. 捕获异常</a>
</li>
<li>
<a href="#toc_3">b. 抛出异常</a>
</li>
<li>
<a href="#toc_4">c. 捕获抛出异常</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">9.2 调试</a>
<ul>
<li>
<a href="#toc_6">a. 断言</a>
</li>
<li>
<a href="#toc_7">b. logging</a>
</li>
<li>
<a href="#toc_8">c. pdb</a>
</li>
<li>
<a href="#toc_9">d. pdb.set_trace()</a>
</li>
<li>
<a href="#toc_10">e. 使用IDE调试</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">9.3 单元测试</a>
<ul>
<li>
<a href="#toc_12">a. 编写单元测试</a>
</li>
<li>
<a href="#toc_13">b. 运行单元测试</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">9.4 文档测试</a>
</li>
</ul>


<h4 id="toc_0">09. 异常、测试</h4>

<h4 id="toc_1">9.1 异常</h4>

<h5 id="toc_2">a. 捕获异常</h5>

<ul>
<li>可以用多个“except”（except：把…除外）来捕获不同类型的异常；但是需要将父类型的异常写在后面，否则父类型的异常会捕获其子类型的所有异常</li>
<li>所有的异常继承于BaseException，比如Exception； UnicodeError是ValueError的子类</li>
<li><p>使用“try...except”捕获异常有一个好处，就是可以跨越多层调用；也就是说，不需要在每个可能出错的地方捕获异常错误，只要在合适的层次地方去捕获异常错误就可以</p>

<pre><code class="language-python">try:
    print(&#39;try...&#39;)
    # r = 10 / 0
    # r = 10 / int(&#39;a&#39;)
    r = 10 / 2
    print(&#39;result:&#39;, r)
except ZeroDivisionError as e:
    print(&#39;ZeroDivisionError, except:&#39;, e)
except ValueError as e:
    print(&#39;ValueError, except:&#39;, e)
else: # 其它情况（没有异常、其它异常）
    print(&#39;no error&#39;)
finally:
    print(&#39;finally...&#39;)  # 最终都会执行（不论是否有异常）
print(&#39;END&#39;) # 程序会继续执行（不论是否有异常）

# 比如函数的main()调用了fun1()，fun1()调用了fun2()，结果fun2()出错了
def fun2(s):
    return 10 / int(s)
def fun1(s):
    return fun2(s) * 2
#   只在main()中捕获到处理  
def main():
    try:
        fun1(&#39;s&#39;)
    except Exception as e:
        print(&#39;Error:&#39;, e)
    finally:
        print(&#39;finally...&#39;)

main()
</code></pre></li>
</ul>

<span id="more"></span><!-- more -->

<ul>
<li>调用堆栈：若异常没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出（后面的代码不会执行）</li>
<li>记录异常：import logging、logging.exception(e)</li>
</ul>

<h5 id="toc_3">b. 抛出异常</h5>

<ul>
<li><strong>捕获一个异常就是捕获到该异常class的一个实例对象；异常并不是凭空产生的，而是有意创建并抛出的</strong></li>
<li><p>Python的内置函数会抛出很多类型的异常，我们自己编写的函数也可以抛出异常</p>

<ul>
<li>若要抛出自定义的异常，首先根据需要定义一个异常的class，选择好继承关系，然后用raise语句抛出一个异常的实例对象</li>
<li>只有在必要的时候才定义我们自己的异常类型，尽量使用Python内置的异常类型</li>
</ul>

<pre><code class="language-python">class FooError(ValueError):
    pass

def fun2(s):
    n = int(s)
    if n == 0:
        raise FooError(&#39;invalid value: %s&#39; % s)
    return 10 / n

fun2(&#39;0&#39;)
</code></pre></li>
</ul>

<h5 id="toc_4">c. 捕获抛出异常</h5>

<ul>
<li><strong>处理异常的第一种方式：捕获异常；第二种处理异常的方式：先去捕获异常，打印出异常信息后，然后又把异常通过raise语句抛出去</strong></li>
<li>该处理比较常见，捕获异常的目的只是记录一下便于后续追踪，但是由于当前函数不知道应该怎样处理该异常，所以最恰当的方式是继续往上抛，让顶层调用者去处理</li>
<li><p><strong>raise语句若不带参数，就会把当前异常错误原样抛出</strong></p>

<pre><code class="language-python">def fun2(s):
    n = int(s)
    if n == 0:
        raise ValueError(&#39;invalid value: %s&#39; % s)
    return 10 / n

def fun1():
    try:
        fun2(&quot;0&quot;)
    except ValueError as e:  # 捕获记录一下
        print(&#39;Value Error!&#39;)
        raise # 再往上原样抛出

fun1()
print(&#39;END...&#39;)  # 不执行了
</code></pre></li>
<li><p>此外，先except后raise一个异常时，还可以把该类型的异常转化成另一种类型的异常；只要是合理的转换逻辑就可以，但决不应该把一个IOError转换成毫不相干的ValueError</p>

<pre><code class="language-python">try:
    10 / 0
except ZeroDivisionError:
    raise ValueError(&#39;input error!&#39;)
</code></pre></li>
</ul>

<h4 id="toc_5">9.2 调试</h4>

<h5 id="toc_6">a. 断言</h5>

<ul>
<li>若断言失败，则assert语句本身就会抛出AssertionError异常（AssertionError继承于Exception）</li>
<li><p>启动Python解释器时，可以用-O参数来关闭assert，此时assert语句被当成pass来看，比如 <code>python -O err.py</code></p>

<pre><code class="language-python">def foo(s):
    n = int(s)
    assert n != 0, &#39;n is zero!&#39;  # 逗号后面的内容（&#39;n is zero!&#39;）为断言失败输出的信息
    return 10 / n

def main():
    foo(&#39;0&#39;)

main()
</code></pre></li>
</ul>

<h5 id="toc_7">b. logging</h5>

<ul>
<li>logging的好处就是可以指定日志信息的类别，有debug、info、warning、error等几个级别；</li>
<li>当指定level=INFO时，logging.debug就不起作用了，当指定level=WARNING后，debug和info就不起作用了；这样就可以设置输出级别，达到统一控制输出哪个级别的信息了</li>
<li><p>logging的另外一个好处就是通过简单的配置，将日志信息可以同时输出到不同的地方，比如console、文件</p>

<pre><code class="language-python">import logging
# 加上配置信息，否则除了ZeroDivisionError，无内容输出
logging.basicConfig(level=logging.INFO)

s = &#39;0&#39;
n = int(s)
logging.info(&#39;n = %d&#39; % n)
print(10 / n)
</code></pre></li>
</ul>

<h5 id="toc_8">c. pdb</h5>

<ul>
<li>启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态</li>
<li><p>该调试方法不常用；过于麻烦，若有多行代码，执行多少行需要输入多少行代码</p>

<pre><code>python -m pdb helloworld.py  # 加上-m pdb参数，pdb定位到下一步要执行的代码
&gt;...helloworld.py(111)&lt;module&gt;()
-&gt; s = &#39;0&#39;
(Pdb) l  #【1】输入&#39;l&#39;查看代码
106     # s = &#39;0&#39;
107     # n = int(s)
108     # logging.info(&#39;n = %d&#39; % n)
109     # print(10 / n)
110
111  -&gt; s = &#39;0&#39;
112     n = int(s)
113     print(10 / n)
[EOF]
(Pdb) n  #【2】输入&#39;n&#39;可以单步执行代码
&gt; ...helloworld.py(112)&lt;module&gt;()
-&gt; n = int(s)
(Pdb) n
&gt; ...helloworld.py(113)&lt;module&gt;()
-&gt; print(10 / n)
(Pdb) n
ZeroDivisionError: division by zero
&gt; ...helloworld.py(113)&lt;module&gt;()
-&gt; print(10 / n)
(Pdb) p s  #【3】输入&#39;p 变量名&#39;来参看变量
&#39;0&#39;
(Pdb) p n
0
(Pdb) q  #【4】输入&#39;q&#39;结束调试
</code></pre></li>
</ul>

<h5 id="toc_9">d. pdb.set_trace()</h5>

<ul>
<li>该调试方法也是使用pdb，但是不需要单步执行</li>
<li><p><code>import pdb</code> 后，在可能出错的位置放一个 <code>pdb.set_trace()</code> ，就是设置一个断点，之后输入命令c继续运行</p>

<pre><code class="language-python">import pdb

s = &#39;0&#39;
n = int(s)
pdb.set_trace()  # 运行到这里会自动暂停
print(10 / n)
</code></pre></li>
</ul>

<h5 id="toc_10">e. 使用IDE调试</h5>

<h4 id="toc_11">9.3 单元测试</h4>

<ul>
<li><p>编写一个Dict类，这个类的行为和dict一致，但是可以通过属性来访问</p>

<pre><code class="language-python">class Dict(dict):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value
</code></pre></li>
</ul>

<h5 id="toc_12">a. 编写单元测试</h5>

<ul>
<li><p>编写一个继承于unittest.TestCase（导入unittest模块）的测试类；以test开头的方法被认为是测试方法（测试时会被自动调用），不以test开头的方法被认为不是测试方法（不会被自动调用）</p>

<ul>
<li>可以调用unitest.TestCase中的内置的断言方法，判断输出是否符合我们的期望；assertEqual()断言传入的两个参数值是否相等，assertRasises()断言抛出指定类型的异常</li>
<li>可以在单元测试中，编写两个特殊的方法setUp()、tearDown()，这两个方法会分别在每调用一个测试方法的前后分别被执行，通常用于初始化、扫尾操作</li>
<li>比如测试需要启动一个数据库，可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样就不必在每一个测试方法中写重复相同的代码</li>
</ul>

<pre><code class="language-python">import unittest

class TestDict(unittest.TestCase):
    def test_init(self):
        d = Dict(a=1, b=&#39;test&#39;)
        self.assertEqual(d.a, 1)  # 断言相等
        self.assertEqual(d.b, &#39;test&#39;)
        self.assertTrue(isinstance(d, dict))  # 断言为True

    def test_key(self):
        d = Dict()
        d[&#39;key&#39;] = &#39;value&#39;
        self.assertEqual(d.key, &#39;value&#39;)
        self.assertEqual(d[&#39;key&#39;], &#39;value&#39;)

    def test_attr(self):
        d = Dict()
        d.key = &#39;value&#39;
        self.assertTrue(&#39;key&#39; in d)
        self.assertEqual(d[&#39;key&#39;], &#39;value&#39;)

    def test_keyError(self):
        d = Dict()
        with self.assertRaises(KeyError):  # 断言会抛出KeyError
            value = d[&#39;empty&#39;]

    def test_attrError(self):
        d = Dict()
        with self.assertRaises(AttributeError):  # 断言会抛出AttributeError
            value = d.empty

    def setUp(self):
        print(&#39;setUp...&#39;)

    def tearDown(self):
        print(&#39;tearDown...&#39;)
</code></pre></li>
</ul>

<h5 id="toc_13">b. 运行单元测试</h5>

<ul>
<li><p>方式一：在单元测试类中加入以下代码，然后运行 <code>python3 dicttest.py(当前Python文件)</code></p>

<pre><code class="language-python">if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre></li>
<li><p>方式二（推荐使用）：命令行运行时加&quot;-m unittest&quot;参数，例如 <code>python -m unittest dicttest.py(当前Python文件)</code></p>

<pre><code class="language-python">&gt;python -m unittest dicttest.py # 测试通过打.，测试不通过打E
.....
----------------------------------------------------------------------
Ran 5 tests in 0.001s

OK
</code></pre></li>
</ul>

<h4 id="toc_14">9.4 文档测试</h4>

<ul>
<li><p>Python内置的“文档测试”（doctest）模块可以直接提取注释中的“代码”并执行测试</p>

<ul>
<li>将代码在交互命令行中输入并执行，交互命令行中输出显示的“结果内容”后，将“结果内容”粘贴到代码注释中，这些“结果内容”是可以运行的</li>
<li>doctest严格按照Python交互命令行中的“输入输出”来判断测试结果是否正确；可以用“...”代替测试中出现的大段输出的异常日志</li>
<li>文档测试通过则什么也不输出，测试失败则打印实际执行结果（注意编写时的空格，比如&gt;&gt;&gt; dl = Dict()）</li>
</ul>

<pre><code class="language-python"># 用doctest来测试之前编写的Dict类
class Dict(dict):
    &#39;&#39;&#39;  # 文档测试开始
    Simple dict

    &gt;&gt;&gt; dl = Dict()
    &gt;&gt;&gt; dl[&#39;x&#39;] = 100
    &gt;&gt;&gt; dl.x
    100
    &gt;&gt;&gt; dl[&#39;y&#39;] = 200
    &gt;&gt;&gt; dl.y
    200
    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&#39;3&#39;)
    &gt;&gt;&gt; d2.c
    &#39;3&#39;
    &gt;&gt;&gt; d2[&#39;empty&#39;]
    Traceback (most recent call last):
        ...
    KeyError: &#39;empty&#39;
    &gt;&gt;&gt; d2.empty
    Traceback (most recent call last):
        ...
    AttributeError: &#39;Dict&#39; object has no attribute &#39;empty&#39;
    &#39;&#39;&#39;  # 文档测试结束

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value

if __name__ == &#39;__main__&#39;:
    import doctest
    doctest.testmod()
</code></pre>

<pre><code class="language-python"># 用doctest来测试fact(n)函数
def fact(n):
    &#39;&#39;&#39;
    &gt;&gt;&gt; fact(0)
    Traceback (most recent call last):
        ...
    ValueError
    &gt;&gt;&gt; fact(1)
    1
    &gt;&gt;&gt; fact(5)
    120
    &#39;&#39;&#39;

    if n &lt; 1:
        raise ValueError()
    if n == 1:
        return 1
    return n * fact(n - 1)

if __name__ == &#39;__main__&#39;:
    import doctest
    doctest.testmod()
</code></pre></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(08面向对象高级编程)]]></title>
    <link href="http://www.justisit.com/15125773961928.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773961928.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">08. 面向对象高级编程</a>
<ul>
<li>
<a href="#toc_1">8.1 动态绑定方法</a>
</li>
<li>
<a href="#toc_2">8.2 使用__slots</a>
</li>
<li>
<a href="#toc_3">8.3. 使用@property</a>
</li>
<li>
<a href="#toc_4">8.4 多重继承</a>
</li>
<li>
<a href="#toc_5">8.5 定制类</a>
</li>
<li>
<a href="#toc_6">8.6 使用枚举类</a>
</li>
<li>
<a href="#toc_7">8.7 使用元类（metaclass）</a>
</li>
<li>
<a href="#toc_8">8.7 自定义ORM框架</a>
</li>
</ul>
</li>
</ul>


<h4 id="toc_0">08. 面向对象高级编程</h4>

<h5 id="toc_1">8.1 动态绑定方法</h5>

<ul>
<li><p>types模块MethodType()函数可以创建一个方法，给实例变量、类动态绑定方法</p>

<pre><code class="language-python">class Student(object):
    pass

# 注意是带有self参数的函数，不是方法
def set_age(self, age):  
    self.age = age

from types import MethodType
s = Student()
s.set_age = MethodType(set_age, s)  # 给一个实例变量动态绑定方法，只能该实例变量可以调用
s.set_age(25)
s.age # 25

s2 = Student()
s2.set_age(25)
Traceback (most recent call last):
 File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#39;Student&#39; object has no attribute &#39;set_age&#39;

def set_score(self, score):
    self.score = score

# 给类绑定方法，所有实例变量都可以使用
Student.set_score = MethodType(set_score, Student) 
s.set_score(100)
s.score # 100

s2.set_score(99) # 99
s2.score
</code></pre></li>
</ul>

<span id="more"></span><!-- more -->

<h5 id="toc_2">8.2 使用__slots</h5>

<ul>
<li>默认情况下，可以给实例变量绑定任意属性；使用__slots__则可以限制只能添加指定的属性</li>
<li><p>注意，__slots__定义的属性仅对当前类的实例限制作用，对继承的子类不起作用；除非在子类中也定义了__slots__，这样子类实例允许定义的属性就是自身的__slots__加上父类的__slots__</p>

<pre><code class="language-python">class Student(object):
    __slots__ = (&#39;name&#39;, &#39;age&#39;)  # 用tuple定义允许绑定的属性名称

s = Student()
s.name = &#39;Tom&#39;
s.age = 25
s.score = 99
Traceback (most recent call last):
 File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#39;Student&#39; object has no attribute &#39;score&#39;

class GraduateStudent(Student):
    pass

g = GraduateStudent()
g.score = 999
</code></pre></li>
</ul>

<h5 id="toc_3">8.3. 使用@property</h5>

<ul>
<li>在绑定属性时，若直接把属性暴露出去，虽然获取、设置属性写法简单，但无法对参数进行校验</li>
<li>为了对参数进行校验，通常使用方法来进行处理；但是这样调用方法略显复杂，没有直接使用属性那么直接简单</li>
<li><p>Python内置的 <code>@property装饰器</code> 可以将一个方法变成属性，这样既能进行参数校验，也能直接以“访问属性的形式”去调用方法</p>

<ul>
<li>把一个getter方法XXX变成属性，只需要加上@property即可；此时@property本身又创建另一个装饰器@XXX.setter，负责把一个setter方法变成属性赋值，这样我们就拥有一个可控的属性操作</li>
<li>还可以定义只读属性（只定义getter方法，不定义setter方法）</li>
</ul>

<pre><code class="language-python">class Student(object):
    @property   
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer&#39;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value

from testpy import Student
stu = Student()
stu.score = 100
stu.score # 100 
stu._score # 100
stu.score = 200
Traceback (most recent call last):
 File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
 File &quot;/Users/tom/Desktop/testpy.py&quot;, line 336, in score
   raise ValueError(&#39;score must between 0 ~ 100!&#39;)
ValueError: score must between 0 ~ 100!

# get、set方法名不一致
class Student(object):
    @property 
    # 使用stu.gscore进行访问，也可以使用stu.sscore进行访问
    def gscore(self):
        return self._score

    @gscore.setter  # 注意，必须是@gscore.setter，而不是@sscore.setter
    # 只能使用stu.sscore = 20进行设置值，不可以使用stu.gscore = 20
    def sscore(self, value):  
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer&#39;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value

# 定义只读属性
class Screen(object):  # 给一个Screen对象加上width和height、resolution属性
    @property
    def width(self):
        return self._width
    @width.setter
    def width(self, value):
        self._width = value
    @property
    def height(self):
        return self._height
    @height.setter
    def height(self, value):
         self._height = value
    @property
    def resolution(self):
        return self._width * self._height
</code></pre></li>
</ul>

<h5 id="toc_4">8.4 多重继承</h5>

<ul>
<li>在设计类的继承关系，通常主线都是单一继承下来的，若需要“混入”额外的功能，可以通过多重继承来实现，这种设计通常称之为MixIn</li>
<li>MixIn的目的就是给一个类增加多个功能，在设计类的时候优先通过“多重继承“来组合多个功能，而不是设计“多层次的复杂的继承关系”</li>
<li><p>Python自带很多库也使用了MixIn；比如TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMaxIn提供，通过组合可以创造出合适的服务</p>

<pre><code class="language-python">class MyTCPServer(TCPServer, ForkingMixIn):  # 多进程TCP服务
    pass

class MyUDPServer(UDPServer, ThreadingMixIn):  # 多线程UDP服务
    pass

class MyTCPServer(TCPServer, CoroutineMixIn):  # 协程TCP服务
    pass
</code></pre></li>
</ul>

<h5 id="toc_5">8.5 定制类</h5>

<ul>
<li><p>a. 打印对象</p>

<ul>
<li>print()打印对象，内容就是__str__方法返回的字符串</li>
<li>直接打印对象（调试中使用），内容就是__repr__方法返回的字符串；通常让__str__和__repr__返回的内容一样</li>
</ul>

<pre><code class="language-python">class Student(object):
    def __init__(self, name):
        self.name = name

&gt;&gt;&gt; print(Student(&#39;Tom&#39;))
&lt;__main__.Student object at 0x1018b60b8&gt;
&gt;&gt;&gt; s = Student(&#39;Michael&#39;)
&gt;&gt;&gt; s
&lt;__main__.Student object at 0x1018ca860&gt;

class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):  # 重写__str__方法
        return &#39;Student object (name: %s)&#39; % self.name
    __repr__ = __str__  # 重写__repr__方法

&gt;&gt;&gt; print(Student(&#39;Michael&#39;))
Student object (name: Michael)
&gt;&gt;&gt; s = Student(&#39;Michael&#39;)
&gt;&gt;&gt; s
Student object (name: Michael)
</code></pre>

<ul>
<li><strong>报错IndentationError: unindent does not match any outer indentation level，表示输入的空格、tab有问题</strong></li>
</ul></li>
<li><p>b. 遍历对象、取值、赋值</p>

<ul>
<li>若一个对象可以被用于“for ... in”循环，类似于list或tuple，就必须实现__iter__()方法和__next__()方法；</li>
<li>__iter__()方法需要返回一个迭代对象；__next__()方法返回每次循环的结果；Python进行遍历直到遇到StopInteration错误时退出循环</li>
<li>若一个对象可以像list直接按照位置索引取值，需要实现__getitem__()方法</li>
<li>若一个对象可以使用切片，也是需要实现__getitem__()方法，只是要做一下参数类型判断，参数是int（位置索引取值）还是切片（切片取值）</li>
</ul>

<pre><code class="language-python">class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1
    def __iter__(self):  # 返回需要被循环的对象（self）
        return self
    def __next__(self):  # 返回每次循环后的结果
        self.a, self.b = self.b, self.a + self.b
        if self.a &gt; 100:
            raise StopIteration()
        return self.a

    def __getitem__(self, n):  # 返回位置索引取值、切片取值
        if isinstance(n, int):  # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice):  # n是切片（slice）
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:  # 从start开始
                    L.append(a)
                a, b = b, a + b
            return L

&gt;&gt;&gt; from testpy import Fib
&gt;&gt;&gt; for n in Fib():
...     print(n)
... 
1
1
2
3
5
8
13
21
34
55
89

&gt;&gt;&gt; f = Fib()
&gt;&gt;&gt; f[20]
10946
&gt;&gt;&gt; f[10:20]
[89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]
&gt;&gt;&gt; f[:10]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre>

<ul>
<li>要正确实现一个__getitem__()需要做很多判断；若对象以dict的方式访问，__getitem__()的参数是一个作key的object（例如str）</li>
<li>实现__setitem__()方法用于对集合（把对象视为list或dict）赋值</li>
<li>实现__delitem__()方法用于删除某个元素</li>
<li>通过实现上面的方法，完全可以自定义的一个类，表现得和Python自带的list、tuple、dict没什么区别；这归功于动态语言的“鸭子类型”，不需要强制继承某个类、实现某个接口</li>
</ul></li>
<li><p>c. 获取设置属性、方法</p>

<ul>
<li>正常情况下，当调用对象的属性、方法时，若不存在则报错</li>
<li>为避免此错误，可以重写__getattr__()方法动态返回一个属性、方法；比如调用不存在的属性score时，Python解释器会试图调用__getattr__(self, &#39;score&#39;)来尝试获得属性，重写该方法就可以控制返回score的值</li>
</ul>

<pre><code class="language-python"># 返回属性
class Student(object):
    def __getattr__(self, attr):
        if attr == &#39;score&#39;:
            return 99

&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.score
99

# 返回函数
class Student(object):
    def __getattr__(self, attr):
        if attr == &#39;age&#39;:
            return lambda: 25

&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; f = s.age
&gt;&gt;&gt; f
&lt;function Student.__getattr__.&lt;locals&gt;.&lt;lambda&gt; at 0x10050cbf8&gt;
&gt;&gt;&gt; f()
25
&gt;&gt;&gt; s.age()
25
</code></pre>

<ul>
<li><strong>注意，只有在没有找到属性、方法的情况下（以obj.x对象方式、getattr(obj, &#39;x&#39;, NO=one)函数方式），才调用__getattr__()；若已存在属性、方法则不会调用__getattr__()</strong></li>
<li>此外，若重写了__getattr__()时要设置返回默认处理；比如，上面定义的__getattr__()默认返回None，这样将导致调用任何不存在且没有处理的属性、方法时都会返回None；要让class只响应特定的几个不存在的属性、方法，其他不存在的则抛出AttributeError错误</li>
</ul>

<pre><code class="language-python">&gt;&gt;&gt; s.abc  # 不报任何错误（返回None）

class Student(object):
    def __getattr__(self, attr):
        if attr == &#39;age&#39;:
            return lambda: 25
        raise AttributeError(&#39;\&#39;Student\&#39; object has no attribute \&#39;%s\&#39;&#39; % attr)

&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.abc
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
 File &quot;&lt;stdin&gt;&quot;, line 5, in __getattr__
AttributeError: &#39;Student&#39; object has no attribute &#39;abc&#39;

# 应用场景：URL动态调用
class Chain(object):
    def __init__(self, path=&#39;&#39;):
        elf._path = path
    def __getattr__(self, path):
        return Chain(&#39;%s/%s&#39; % (self._path, path))
    def __str__(self):
        return self._path
    __repr__ = __str__

&gt;&gt;&gt; Chain().stutus.user.timeline.list
/stutus/user/timeline/list
&gt;&gt;&gt; Chain().stutus.user.timeline
/stutus/user/timeline
</code></pre></li>
<li><p>d. __call__()方法</p>

<ul>
<li>一个实例变量可以有自己的属性和方法，当调用实例的方法时使用instance.method()的方式来调用；但是也可以直接调用实例本身上，只需要实现__call__()方法即可</li>
</ul>

<pre><code class="language-python">class Student(object):
    def __init__(self, name):
        self.name = name
    def __call__(self):
        print(&#39;My name is %s.&#39; % self.name)

&gt;&gt;&gt; s = Student(&#39;Michael&#39;)
&gt;&gt;&gt; s()  # 调用实例本身，不是方法调用
My name is Michael.
</code></pre>

<ul>
<li><strong>__call__()方法还可以定义参数，对实例的直接调用相当于对一个函数调用</strong>；完全可以将对象和函数看成一样，函数本身也是运行期动态创建出来的，对象也是运行期创建出来的</li>
<li>一个对象是若能被调用则该对象是一个Callable对象，可使用callable()函数来判断</li>
</ul>

<pre><code class="language-python">&gt;&gt;&gt; callable(Student(&#39;Tom&#39;))
True
&gt;&gt;&gt; callable(max)
True
&gt;&gt;&gt; callable([1, 2, 3])
False
&gt;&gt;&gt; callable(None)
False
&gt;&gt;&gt; callable(&#39;str&#39;)
False
</code></pre></li>
</ul>

<h5 id="toc_6">8.6 使用枚举类</h5>

<ul>
<li>当需要定义常量时，一种方式是用大写变量通过整数来定义（例如月份）；好处是简单，缺点是类型是int且仍然是变量</li>
<li><p>更好的方式是将这样的类型定义一个class类型（枚举类型），然后每一个常量都是class的一个唯一实例；Python提供了Enum类来实现该功能</p>

<pre><code class="language-python">from enum import Enum
M = Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))

# 获取到Month类型的枚举类，可以直接使用如Month.Jan的方式来引用一个常量
&gt;&gt;&gt; for name, member in M.__members__.items():
...      print(name, &#39;,&#39;, member, &#39;,&#39;, member.value)
... 
Jan , Month.Jan , 1  # value属性则是自动赋给成员的int常量，默认从1开始
Feb , Month.Feb , 2
Mar , Month.Mar , 3
Apr , Month.Apr , 4
May , Month.May , 5
Jun , Month.Jun , 6
Jul , Month.Jul , 7
Aug , Month.Aug , 8
Sep , Month.Sep , 9
Oct , Month.Oct , 10
Nov , Month.Nov , 11
Dec , Month.Dec , 12
</code></pre></li>
<li><p>若需要精确控制枚举类型，可以从Enum派生出自定义类</p>

<pre><code class="language-python">from enum import Enum, unique
@unique  # @unique装饰器可以检查保证没有重复值
class WeekDay(Enum):
    Sun = 0  # Sum的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6

&gt;&gt;&gt; day1 = WeekDay.Mon  # 访问枚举方式一
&gt;&gt;&gt; day1
&lt;WeekDay.Mon: 1&gt;
&gt;&gt;&gt; print(day1)
WeekDay.Mon

&gt;&gt;&gt; print(WeekDay[&#39;Mon&#39;])  # 访问枚举方式二
WeekDay.Mon

&gt;&gt;&gt; print(WeekDay(1))  # 访问枚举方式三（根据value获取其对应的枚举常量）
WeekDay.Mon

&gt;&gt;&gt; print(WeekDay.Mon.value)
1
&gt;&gt;&gt; WeekDay(7)
Traceback (most recent call last):
ValueError: 7 is not a valid WeekDay

&gt;&gt;&gt; print(day1 == WeekDay.Mon)
True
</code></pre></li>
</ul>

<h5 id="toc_7">8.7 使用元类（metaclass）</h5>

<ul>
<li>动态语言和静态语言最大的不同，就是函数和类的定义不是编译时定义的，而是运行时动态创建的</li>
<li><p>type()函数可以获取、判断对象类型，返回对应Class类型；比如，Hello是一个class，它的类型是type，h是一个实例，它的类型是class Hello</p>

<pre><code>class Hello(object):
    def hello(self, name=&#39;world&#39;):
        print(&#39;Hello, %s&#39; % name)

&gt;&gt;&gt; print(type(Hello))
&lt;class &#39;type&#39;&gt;
&gt;&gt;&gt; print(type(h))
&lt;class &#39;__main__.Hello&#39;&gt;
</code></pre></li>
<li><p><strong>type()函数还可以可以创建出新的数据类型；class的定义就是运行时调用type()函数动态创建的</strong></p>

<ul>
<li>要创建一个class，type()函数需要依次传入3个参数：class的名称、继承的父类集合（Python支持多继承，若只有一个父类注意单个元素的tuple写法）、class的方法名与函数名绑定的dict</li>
<li>通过type()函数创建的class和直接代码定义的class是完全一样的；因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class</li>
</ul>

<pre><code>def fn(self, name=&#39;world&#39;):
     print(&#39;Hello, %s&#39; % name)

# 通过type()函数创建出Hello类，无需通过“class Hello(object)...”的代码方式进行定义
# hello方法与函数fn进行绑定
Hello = type(&#39;Hello&#39;, (object,), dict(hello=fn))

&gt;&gt;&gt; h = Hello()
&gt;&gt;&gt; h.hello()
Hello, world
&gt;&gt;&gt; print(type(Hello))
&lt;class &#39;type&#39;&gt;
&gt;&gt;&gt; print(type(h))
&lt;class &#39;__main__.Hello&#39;&gt;
</code></pre></li>
<li><p><strong>除了使用type()函数动态创建类以外，还可以，使用metaclass（元类）控制类的创建行为</strong></p>

<ul>
<li>可以把类看作是metaclass创建出来的“实例”；metaclass是类的模板，所以必须从type类型派生</li>
<li>先有metaclass，再有类，最后才是实例</li>
<li>按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass</li>
</ul>

<pre><code class="language-python">class ListMetaclass(type):
    def __new__(cls, name, base, attrs):  # 实现__new__()方法，增加add()方法
        attrs[&#39;add&#39;] = lambda self, value: self.append(value)
        return type.__new__(cls, name, base, attrs)

# 定义类时使用关键字参数metaclass，说明使用ListMetaclass来进行定制
# 给自定义的MyList增加一个add方法
class MyList(list, metaclass=ListMetaclass): 
    pass

&gt;&gt;&gt; l = MyList()
&gt;&gt;&gt; l.add(1)  # 调用增加的add()方法；
# 虽然是类方法，但是没有对象方法，调用时使用调用类方法，和类属性与对象属性的调用顺序类似
&gt;&gt;&gt; l
[1]

&gt;&gt;&gt; l2 = list()
&gt;&gt;&gt; l2.add(1)  # 普通的list没有add()方法
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#39;list&#39; object has no attribute &#39;add&#39;
</code></pre>

<ul>
<li>在metaclass的__new__()方法中，可以修改类的定义（比如增加新的方法），然后再返回修改后的定义</li>
<li><strong>__new__()方法接收的参数依次是：当前准备创建的类的对象、类的名字、类继承的父类集合、类属性方法集合（不是对象的；参考类属性与对象属性的调用顺序）</strong></li>
</ul></li>
<li><p>动态修改有什么意义？直接在MyList定义时增加add()方法不是更简单吗？正常情况下，确实应该直接在MyLis定义时增加add()方法；但是有需要通过metaclass修改类定义的情景，比如ORM</p></li>
<li><p>ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表；这样写代码更简单，不用直接操作SQL语句</p></li>
</ul>

<h5 id="toc_8">8.7 自定义ORM框架</h5>

<ul>
<li><p>编写底层模块的第一步，就是先把接口写出来；比如，定义一个User类来操作对应的数据库User</p>

<pre><code class="language-python"># 使用
class User(Model): 
    id = IntegerField(&#39;t_id&#39;) # 类属性
    name = StringField(&#39;t_username&#39;)
    email = StringField(&#39;t_email&#39;)
    password = StringField(&#39;t_password&#39;)

u = User(id=12345, name=&#39;Tom&#39;, email=&#39;tom@tom.com&#39;, password=&#39;123&#39;)  
# dict语法； Model继承于dict，不需要实现__init__()方法进行绑定属性    
u.save()
</code></pre>

<pre><code class="language-python"># Field类负责保存数据库表的字段名和字段类型
class Field(object):  # IntegerField、StringField的父类
    def __init__(self, name, col_type):
        self.name = name
        self.col_type = col_type

    def __str__(self):
        return &#39;&lt;%s:%s&gt;&#39; % (self.__class__.__name__, self.name)

# 在Field的基础上，进一步定义各种类型的Field
class IntegerField(Field):
    def __init__(self, name):
        super(IntegerField, self).__init__(name, &#39;bigint&#39;)  # 调用父类的方法

class StringField(Field):
    def __init__(self, name):
        super(StringField, self).__init__(name, &#39;varchar(100)&#39;)
</code></pre>

<pre><code class="language-python">class ModelMetaclass(type):
    def __new__(cls, name, base, attrs):
        if name == &#39;Model&#39;:
            return type.__new__(cls, name, base, attrs)

        # 解析定义类User中定义的映射关系
        mappings = dict()
        # attrs.items保存的是类属性方法（如id = IntegerField(&#39;t_id&#39;)），而不是创建对象时传入的dict
        for k, v in attrs.items(): 
            if isinstance(v, Field):  # 是自定义的“Field类型”的类属性
                # print(&#39;Found mapping: %s ==&gt; %s&#39; % (k, v))
                mappings[k] = v

        # 方式2：删除类属性
        # 注意，不要在上面迭代过程中修改迭代对象
        # for k in mappings.keys():
            # attrs.pop(k) 

        # 增加两个类属性（关系映射、表名）
        attrs[&#39;__mappings__&#39;] = mappings
        attrs[&#39;__table__&#39;] = name
        return type.__new__(cls, name, base, attrs)
</code></pre>

<pre><code class="language-python"># Model继承于dict，初始化对象时其内部会初始化一个字典
# m.id访问的是id属性，m[&#39;id&#39;]访问的是字典中‘id’对应的value
class Model(dict, metaclass=ModelMetaclass):
    def __init__(self, **kwargs):
        super(Model, self).__init__(**kwargs)

    # 方式2：重写__getattr__
    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;&#39;Model&#39; object has no attribute %s&quot; % key)

    def __setattr__(self, key, value):
        self[key] = value

    def save(self):
        fields = []
        params = []
        types = []
        args = []
        # 遍历保存的关系映射（k为类属性名，v.name为表中的字段名，v.col_type为表中的字段类型）
        for k, v in self.__mappings__.items():
            fields.append(v.name)
            params.append(&#39;?&#39;)
            types.append(v.col_type)

            # 方式1：
            # 直接读取dict，但是外界访问.k依然返回的是类属性的值（在这里是Field对象）
            args.append(self[k]) 

            # 方式2：
            # 要以“.k”的形式读取的dic中的数据，即[&#39;k&#39;]，则必须删除该类属性k，然后重写__getattr__()方法，并在该方法内部读取[&#39;k&#39;]返回
            # 必须删除，否则__getattr__()方法不会被调用
            # args.append(getattr(self, k, None))

        fieldsStr = &#39;,&#39;.join(fields)
        paramsStr = &#39;,&#39;.join(params) 

        sql = &#39;insert into %s (%s) values (%s)&#39; % (self.__table__, fieldsStr, paramsStr)
        print(&#39;SQL: %s&#39; % sql)
        print(&#39;TYPES: %s&#39; % str(types))
        print(&#39;ARGS: %s&#39; % str(args))
</code></pre>

<pre><code># 输出结果
Found mapping: id ==&gt; &lt;IntegerField:t_id&gt;
Found mapping: password ==&gt; &lt;StringField:t_password&gt;
Found mapping: name ==&gt; &lt;StringField:t_username&gt;
Found mapping: email ==&gt; &lt;StringField:t_email&gt;
SQL: insert into User (t_id,t_password,t_username,t_email) values (?,?,?,?)
TYPES: [&#39;bigint&#39;, &#39;varchar(100)&#39;, &#39;varchar(100)&#39;, &#39;varchar(100)&#39;]
ARGS: [12345, &#39;123&#39;, &#39;Tom&#39;, &#39;tom@tom.com&#39;]
</code></pre></li>
<li><p>当用户定义一个class User(Model)时，Python解释器首先在当前类User的定义中查找metaclass，若没有找到就继续在父类Model中查找metaclass</p></li>
<li><p>若在父类Model中找到了，就使用父类Model中定义的metaclass（ModelMetaclass）来创建User类；也就是说，metaclass可以隐式地继承到子类，子类自己却不知道</p></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(06模块、07面向对象编程)]]></title>
    <link href="http://www.justisit.com/15125773961879.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773961879.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">06. 模块</a>
<ul>
<li>
<a href="#toc_1">6.1 概述</a>
</li>
<li>
<a href="#toc_2">6.2 使用模块</a>
</li>
<li>
<a href="#toc_3">6.3 模块中的函数、变量的作用域</a>
</li>
<li>
<a href="#toc_4">6.4 安装第三方模块</a>
</li>
<li>
<a href="#toc_5">6.5 模块搜索路径</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">07. 面向对象编程</a>
<ul>
<li>
<a href="#toc_7">7.1 概述</a>
</li>
<li>
<a href="#toc_8">7.2 类、实例、绑定属性、方法</a>
</li>
<li>
<a href="#toc_9">7.3 属性访问限制</a>
</li>
<li>
<a href="#toc_10">7.4 继承和多态</a>
</li>
<li>
<a href="#toc_11">7.5 获取对象信息</a>
</li>
<li>
<a href="#toc_12">7.6 实例属性、类属性</a>
</li>
</ul>
</li>
</ul>


<h4 id="toc_0">06. 模块</h4>

<h5 id="toc_1">6.1 概述</h5>

<ul>
<li>在Python中，一个.py文件称之为一个模块（Module），模块可以被其他地方导入使用</li>
<li>为了避免模块名冲突，Python按照文件夹目录的形式（称为包，Package）来组织各个模块；abc.py的模块名为abc，mycompany目录下的abc.py的模块名为mycompany.abc</li>
<li>每一个包目录下必须有一个__init__.py的文件（模块），否则Python就把这个目录当成普通目录而不是一个包目录；__init__.py可以是一个空文件，也可以有Python代码</li>
<li>自己创建的模块要注意命名，不要和Python自带的模块冲突；例如Python自带sys模块，自己的模块就不可命名为sys .py，否则将无法导入Python自带的sys模块</li>
</ul>

<span id="more"></span><!-- more -->

<h5 id="toc_2">6.2 使用模块</h5>

<ul>
<li><strong>使用模块中的变量、函数、类等有两种导入方式：</strong>

<ul>
<li><strong>a. 导入模块：<code>import XX</code></strong>

<ul>
<li><strong>XX为模块名</strong></li>
<li><strong>使用模块内的属性、函数、类时需要加模块名前缀，例如 <code>import sys、print(sys.path)</code>、<code>import testpy、print(testpy.say())</code></strong></li>
<li><strong>++加模块名前缀的语义用法，使得模块看起来很像一个类的实例（testpy.say()感觉是对象调用方法，实际是调用函数）或命名空间++</strong></li>
</ul></li>
<li><strong>b. 导入模块内的内容：<code>from XX import YY</code></strong>

<ul>
<li><strong>XX为模块名，YY为模块内的变量、函数、类</strong></li>
<li><strong>也可以<code>from xx import \*</code>，一次性导入该模块内的所有的变量、函数、类</strong></li>
<li><strong>使用模块内的属性、函数、类时不需要加模块名，例如 <code>from sys import path、print(path)</code>、<code>from testpy import say、print(say())</code></strong></li>
<li><strong>应避免使用此方式导入，这样可以避免名称冲突，也增强程序可读性</strong></li>
</ul></li>
</ul></li>
<li><p>Python文本头部结构信息</p>

<pre><code class="language-python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#39;a test module&#39;   # 表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释

__author__ = &#39;Tom&#39; # 申明作者
</code></pre></li>
<li><p>import sys # 表示导入sys模块，之后变量sys指向该模块；利用该sys变量访问该模块的变量、函数等</p></li>
<li><p>sys模块有一个argv变量（list）存储命令行执行时的所有参数，argv至少有一个元素（第一个元素永远是该.py文件的名称）</p>

<pre><code class="language-python">def test():
    args = sys.argv
    if len(args) == 1:
        print(&#39;Hello, world!&#39;)
    elif len(args) == 2:
        print(&#39;Hello, %s&#39; % args[1])
    else:
        print(&#39;Too many arguments!&#39;)

if __name__ == &#39;__main__&#39;:  # 当使用命令行运行该模块时，python解释器把一个特殊变量__name__赋值为&#39;__main__&#39;，若在其他地方导入该模块则不会（if判断将失败不执行test()）
    test()

# 运行:
localhost:Desktop $ python3 hello.py
Hello, world!
localhost:Desktop $ python3 hello.py Tom
Hello, Tom

&gt;&gt;&gt; import hello
&gt;&gt;&gt; hello.test()
Hello, world!
</code></pre></li>
</ul>

<h5 id="toc_3">6.3 模块中的函数、变量的作用域</h5>

<ul>
<li>正常名称的函数、变量都是公开的（public）,可以被其他模块导入后直接使用，比如abc</li>
<li>若仅仅让函数、变量在模块内部使用，可以通过给名称加‘_’前缀来表示非公开的（private），比如_abc

<ul>
<li>但是，类似__xxx__这样名称的变量是有特殊用途的变量，是公开的（public），可以直接使用，如上面的__author__、__name__、__doc__（定义文档注释）</li>
<li>注意：虽然类似_xxx和__xxx这样名称的函数、变量是非公开的（private）不应该被直接使用，比如_abc、__abc，但是实际上还是可以被访问的；<strong>是按照约定不应该，而不是不可以</strong></li>
</ul></li>
<li><p>可以通过在定义公开的函数中，调用私有的函数、变量的方式（在模块中没有私有访问限制的问题），让外界可以间接使用私有的函数、变量</p>

<pre><code class="language-python">def _private_1(name):
    return &#39;Hello, %s&#39; % name
def _private_2(name):
    return &#39;Hi, %s&#39; % name
def greeting(name):
    if len(name) &gt; 3:
        return _private_1(name)
    else:
        return _private_2(name)

&gt;&gt;&gt; from testpy import greeting
&gt;&gt;&gt; greeting(&#39;test&#39;)
&#39;Hello, test&#39;

&gt;&gt;&gt; from testpy import _private_1
&gt;&gt;&gt; _private_1(&#39;test&#39;)
&#39;Hello, test&#39;
</code></pre></li>
</ul>

<h5 id="toc_4">6.4 安装第三方模块</h5>

<ul>
<li>在Python中安装第三方模块是通过包管理工具pip完成的，例如安装Pillow：pip install Pillow</li>
<li><p>若Python2、3都存在，则python3对应的pip命令为“pip3”</p>

<pre><code class="language-python"># 生成图片缩略图:
&gt;&gt;&gt; from PIL import Image
&gt;&gt;&gt; im = Image.open(&#39;/Users/ls/Desktop/a.jpg&#39;)
&gt;&gt;&gt; print(im.format, im.size, im.mode)
JPEG (750, 1334) RGB
&gt;&gt;&gt; im.thumbnail((200, 100))
&gt;&gt;&gt; im.save(&#39;/Users/ls/Desktop/thumb.jpg&#39;, &#39;JPEG&#39;)
</code></pre></li>
</ul>

<h5 id="toc_5">6.5 模块搜索路径</h5>

<ul>
<li>当我们试图加载一个模块时，Python解释器会在指定路径下搜索对应的.py文件，若找不到则报错</li>
<li>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块；搜索路径存放在sys模块的path变量中(import sys、sys.path)</li>
<li>若需添加自定义的搜索路径有两种方法：a. 直接修改sys.path添加要搜索的目录（sys.path.append(&#39;/.../.../my_py_scripts&#39;)；b. 设置环境变量PYTHONPATH（注意只需要添加自己的搜索路径，Python自己本身的搜索路径不受影响）</li>
</ul>

<h4 id="toc_6">07. 面向对象编程</h4>

<h5 id="toc_7">7.1 概述</h5>

<ul>
<li>在Python中所有数据类型都可以视为对象，当然也可以自定义对象</li>
<li>自定义对象的数据类型就是面向对象中的类（Class）的概念</li>
</ul>

<h5 id="toc_8">7.2 类、实例、绑定属性、方法</h5>

<ul>
<li>自定义类格式：依次为 <code>class 类名(CLASS) :</code> ；“(CLASS)”表示从哪个类继承，默认为 <code>object</code> (小写的)</li>
<li><p>创建实例通过“类()”实现</p>

<pre><code class="language-python">class Student(object):
    def __init__(self, name, score):  # 这个对象拥有name和score这两属性（Property）
        self.name = name
        self.score = score
    def print_score(self):
        print(&#39;%s: %s&#39; % (self.name, self.score))

&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 59)  # 创建学生对象
&gt;&gt;&gt; lisa = Student(&#39;Lisa Simpson&#39;, 87)
&gt;&gt;&gt; bart.print_score()  # 给对象发一个print_score消息（调用对象对应的关联函数）
Bart Simpson: 59
&gt;&gt;&gt; lisa.print_score()
Lisa Simpson: 87
</code></pre>

<pre><code class="language-python">&gt;&gt;&gt; bart
&lt;__main__.Student object at 0x1024f82b0&gt;
&gt;&gt;&gt; Student
&lt;class &#39;__main__.Student&#39;&gt;
</code></pre></li>
<li><p>和静态语言不同，Python允许对实例变量自由地绑定属性；也就是说，对于两个实例，虽然它们都是同一个类的不同实例，但可以让它们拥有的属性可能不同</p>

<pre><code class="language-python">&gt;&gt;&gt; bart.intro = &#39;test&#39;
&gt;&gt;&gt; bart.intro
&#39;test&#39;
&gt;&gt;&gt; lisa.intro
Traceback (most recent call last):
 File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#39;Student&#39; object has no attribute &#39;intro&#39;
</code></pre></li>
<li><p>由于类可以起模板的作用，可把必须绑定的属性在定义__init__方法的时候进行绑定</p></li>
<li><p>__init__方法的第一个参数永远是self，表示创建的实例本身；可以把各种属性绑定到self上</p></li>
<li><p>在创建实例的时候就不能传入空的参数，必须传入与__init__方法匹配的参数；但是self参数不需要传入，Python解释器会自动把实例变量本身传入</p></li>
<li><p>定义时将封装数据的函数和类的实例进行关联起来，我们称之为方法</p></li>
<li><p>方法定义时，除了第一个参数是实例变量self外，其他和普通函数一样；方法调用时，使用“对象.”的形式进行调用，不用传入self参数，其他参数正常传入</p></li>
</ul>

<h5 id="toc_9">7.3 属性访问限制</h5>

<ul>
<li><p><strong>在Python中，若让内部属性不被外部访问，在属性的名称前加上两个下划线“__”（加一个不可以），该属性就变成私有的</strong></p>

<ul>
<li>只能内部可以访问，外部不能直接访问（但是通过特殊手段，还是可以间接访问的）</li>
<li>上面定义的Student类，外部代码是可以自由地修改一个实例的name、score属性</li>
<li><strong>注意：模块中的函数、变量只是人为意识上的私有（加一个、两个下划线都是，只要以下划线开始），实际上还是可以直接访问的</strong></li>
</ul>

<pre><code class="language-python">class Student(object):
    def __init__(self, name, score):
        self.__name = name
        self.__score = score
    def print_score(self):
        print(&#39;%s: %s&#39; % (self.__name, self.__score))

&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 98)
&gt;&gt;&gt; bart.__name
Traceback (most recent call last):
 File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#39;Student&#39; object has no attribute &#39;__name&#39;
</code></pre></li>
<li><p>若需要在外部代码获取设置私有属性，可以给类增加了get、set方法获取、设置该私有属性</p></li>
<li><p>通过定义方法去访问私有属性，而不是通过定义属性为公有的去直接访问，可以对参数做检查，避免传入无效的参数</p>

<pre><code class="language-python">class Student(object):
    def __init__(self, name, score):
        self.__name = name
        self._score = score
    def print_score(self):
        print(&#39;%s: %s&#39; %s (self.__name, self._score))
    def get_name(self):
        return self.__name
    def set_name(self, name):
        self.__name = name

&gt;&gt;&gt; from testpy import Student
&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 98)
&gt;&gt;&gt; bart.get_name()
&#39;Bart Simpson&#39;
&gt;&gt;&gt; bart.set_name(&#39;haha&#39;)
&gt;&gt;&gt; bart.get_name()
&#39;haha&#39;

# 以一个下划线“_”开头的属性不是私有的，可以直接访问
&gt;&gt;&gt; bart._score
98
</code></pre></li>
<li><p>通过特殊手段，还是可以间接访问私有属性；比如__name，Python解释器对外把__name修改为_Student__name（不同版本的Python修改的结果可能不一样），所以仍然可以通过_Student__name来访问原来的__name私有属性</p>

<pre><code class="language-python">&gt;&gt;&gt; bart._Student__name
&#39;Bart Simpson&#39;
</code></pre></li>
</ul>

<h5 id="toc_10">7.4 继承和多态</h5>

<ul>
<li>继承可以让子类获取父类的方法，也可以重写父类的方法</li>
<li>多态的好处：方法定义时用父类参数接收传入子类实例，当方法调用时需要传入参数时，优先使用实际传入参数的类型中定义的方法，而不是方法定义时参数的类型中定义的方法；这样就可以任意增加新的子类，而不必修改方法的定义</li>
<li>对于例如Java这样的静态语言，若方法定义需传入A类型参数，则调用时传入的对象必须是A类型或者A的子类类型，否则将无法调用A中定义的方法，比如run()方法</li>
<li>对于Python这样的动态语言，则不一定需要传入A类型，只需要保证传入的对象有一个run()方法即可；这就是动态语言的“鸭子类型”，并不要求严格的继承体系</li>
<li><p>Python的“file-like object”就是一种鸭子类型，不需要传入真正的文件对象，只需要是任何实现了read()方法的对象即可</p>

<pre><code class="language-python">class Animal(object):
    def run(self):
        print(&#39;Animal is running...&#39;)
class Dog(Animal):
    def run(self):
        print(&#39;Dog is running...&#39;)
class Cat(Animal):
    def eat(self):
        print(&#39;Cat is Eating...&#39;)   

class Timer(object):  # 没有继承Animal父类，只是拥有run方法
    def run(self):
        print(&#39;Start...&#39;)

def runtest(animal):
    animal.run()

&gt;&gt;&gt; runtest(Dog())
Dog is running...
&gt;&gt;&gt; runtest(Cat())
Animal is running...
&gt;&gt;&gt; runtest(Timer())
Start...
</code></pre></li>
</ul>

<h5 id="toc_11">7.5 获取对象信息</h5>

<ul>
<li><p>a. type()函数</p>

<ul>
<li>可以获取、判断对象类型，返回对应Class类型</li>
<li><p>判断基本数据类型可以直接写int、str；若要判断一个对象是否为函数，需要使用types模块中定义的变量</p>

<pre><code class="language-python">&gt;&gt;&gt; type(123)
&lt;class &#39;int&#39;&gt;
&gt;&gt;&gt; type(&#39;123&#39;)
&lt;class &#39;str&#39;&gt;
&gt;&gt;&gt; type(None)
&lt;class &#39;NoneType&#39;&gt;
&gt;&gt;&gt; type(abs)
&lt;class &#39;builtin_function_or_method&#39;&gt;
</code></pre>

<pre><code class="language-python">&gt;&gt;&gt; type(123) == type(456)
True
&gt;&gt;&gt; type(123) == int
True
&gt;&gt;&gt; type(&#39;abc&#39;) == type(&#39;123&#39;)
True
&gt;&gt;&gt; type(&#39;123&#39;) == type(123)
False

&gt;&gt;&gt; def fn():
...     pass
... 
&gt;&gt;&gt; type(fn) == types.FunctionType
True
&gt;&gt;&gt; type(abs) == types.BuiltinFunctionType
True
&gt;&gt;&gt; type(lambda x: x) == types.LambdaType
True
&gt;&gt;&gt; type((x for x in range(10))) == types.GeneratorType
True
</code></pre></li>
</ul></li>
<li><p>b. isinstance()函数</p>

<ul>
<li>对于有class的继承关系的，使用该函数判断一个对象是否是该类型本身，或者位于该类型的父继承链上</li>
<li><p>比如，进行数据类型检查，判断一个对象是否是“Iterable”、“Iterator”</p>

<pre><code class="language-python">&gt;&gt;&gt; import testpy
&gt;&gt;&gt; a = Animal()
&gt;&gt;&gt; d = Dog()
&gt;&gt;&gt; c = Cat()
&gt;&gt;&gt; t = Timer()

&gt;&gt;&gt; isinstance(c, Cat)
True
&gt;&gt;&gt; isinstance(c, Animal)
True
&gt;&gt;&gt; isinstance(a, Cat)
False

# isinstance()还可以判断一个变量是否是某些类型中的一种
&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple)) 
True
</code></pre></li>
</ul></li>
<li><p>c. dir()函数</p>

<ul>
<li><p>可以获取一个对象的所有属性和方法，返回一个包含字符串的list</p>

<pre><code class="language-python">&gt;&gt;&gt; dir(&#39;ABC&#39;)
&gt;&gt;&gt; dir(a)
</code></pre></li>
</ul></li>
<li><p>d. len()函数</p>

<ul>
<li><p>数获取一个对象的长度，实际上在该函数内部会自动调用该对象的__len__()方法</p>

<pre><code class="language-python">&gt;&gt;&gt; len(&#39;ABC&#39;)
3
&gt;&gt;&gt; &#39;ABC&#39;.__len__()
3

&gt;&gt;&gt; class MyDog(object):
...     def __len__(self):  # 重写__len__()方法
...         return 100
... 
&gt;&gt;&gt; dog = MyDog()
&gt;&gt;&gt; len(dog)
100
</code></pre></li>
</ul></li>
<li><p>e. hasattr()、getattr()、setattr()函数</p>

<ul>
<li>用来分别判断属性是否存在、获取设置对象的属性值</li>
<li>只有在不知道对象信息的时候，才以上面函数的方式进行获取对象信息，若知道的话建议直接通过obj.x方式获取</li>
<li><p>上述的三个函数也可以作用于对象的方法</p>

<pre><code class="language-python">class MyObject(object):
    def __init__(self):
        self.x = 9
    def power(self):
        return self.x * self.x

&gt;&gt;&gt; obj = MyObject()
&gt;&gt;&gt; hasattr(obj, &#39;x&#39;)  # obj对象是否有&#39;x&#39;属性
True
&gt;&gt;&gt; obj.x
9

&gt;&gt;&gt; hasattr(obj, &#39;y&#39;)  # obj对象是否有&#39;y&#39;属性
False
&gt;&gt;&gt; setattr(obj, &#39;y&#39;, 19)  # 设置obj对象的&#39;y&#39;属性的值，若没有该属性则增加该属性
&gt;&gt;&gt; hasattr(obj, &#39;y&#39;)
True
&gt;&gt;&gt; getattr(obj, &#39;y&#39;)
19
&gt;&gt;&gt; obj.y
19

# 若试图获取不存在的属性，会抛出AttributeError的错误
# 可以传入default参数，若属性不存在则返回默认值（类似于dict的[&#39;key&#39;]、get(&#39;key&#39;)方式获取value）
&gt;&gt;&gt; getattr(obj, &#39;z&#39;)
Traceback (most recent call last):
 File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#39;MyObject&#39; object has no attribute &#39;z&#39;
&gt;&gt;&gt; getattr(obj, &#39;z&#39;, 404) 
404
</code></pre>

<pre><code class="language-python">&gt;&gt;&gt; hasattr(obj, &#39;power&#39;)
True
&gt;&gt;&gt; getattr(obj, &#39;power&#39;)
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10215e630&gt;&gt;

&gt;&gt;&gt; fn = getattr(obj, &#39;power&#39;)
&gt;&gt;&gt; fn
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10215e630&gt;&gt;
&gt;&gt;&gt; fn()  # 调用fn()与调用ojc.power()是一样的
81
</code></pre></li>
<li><p>应用：若从文件流对象fp中读取数据，需要先判断fp是否存在read()方法，若存在说明该对象确实是文件流，返回文件流，否则无法读取返回None</p>

<pre><code class="language-python">def readImage(fp):
    if hasattr(fp, &#39;read&#39;):
        return readData(fp)
    return None
</code></pre></li>
</ul></li>
</ul>

<h5 id="toc_12">7.6 实例属性、类属性</h5>

<ul>
<li>实例属性可以通过给实例变量或self进行任意绑定的方式；若给类本身绑定属性则直接在class中定义属性即可，<strong>此时该类属性归类所有（类属性），但实例变量也是可以访问的（实例方法、类方法同理）</strong></li>
<li><p><strong>最好不要让实例属性和类属性使用相同的名称，若名称相同，则实例变量访问的是实例属性，而不是类属性（实例方法、类方法同理）</strong></p>

<pre><code class="language-python">class Student(object):
    name = &#39;Student&#39;  # 绑定类属性

&gt;&gt;&gt; Student.name  # 访问类属性
&#39;Student&#39;

&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.name  # 实例变量也可以访问类属性
&#39;Student&#39;
&gt;&gt;&gt; s.name = &#39;Tom&#39;  # 绑定实例属性
&gt;&gt;&gt; s.name  # 访问实例属性
&#39;Tom&#39;
&gt;&gt;&gt; Student.name  # 访问类属性
&#39;Student&#39;

&gt;&gt;&gt; del s.name  # 删除实例属性
&gt;&gt;&gt; s.name  # 访问类属性
&#39;Student&#39;
</code></pre></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(05函数式编程)]]></title>
    <link href="http://www.justisit.com/15125773961836.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773961836.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">05. 函数式编程</a>
<ul>
<li>
<a href="#toc_1">5.1 概述</a>
</li>
<li>
<a href="#toc_2">5.2 高阶函数（Higher-order function）</a>
</li>
<li>
<a href="#toc_3">a. map()函数</a>
</li>
<li>
<a href="#toc_4">b. reduce()函数</a>
</li>
<li>
<a href="#toc_5">c. filter()函数</a>
</li>
<li>
<a href="#toc_6">d. sorted()函数</a>
</li>
<li>
<a href="#toc_7">5.3 返回函数</a>
</li>
<li>
<a href="#toc_8">5.4 匿名函数</a>
</li>
<li>
<a href="#toc_9">5.5 装饰器（Decorator）</a>
</li>
<li>
<a href="#toc_10">5.6 偏函数</a>
</li>
</ul>
</li>
</ul>


<h4 id="toc_0">05. 函数式编程</h4>

<h5 id="toc_1">5.1 概述</h5>

<ul>
<li>函数式编程是一种抽象度很高的编程范式，其一个特点是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数</li>
<li>使用纯粹的函数式编程语言编写的函数是没有变量；由于Python允许使用变量，因此Python不是纯粹的函数式编程语言，对函数式编程提供部分支持</li>
<li>变量可以指向函数，例如 <code>f = abs、f(-10)</code></li>
<li>函数名也是变量名，例如 <code>abs = 10</code>，此时再调用<code>abs(-10)</code>报错“TypeError: &#39;int&#39; object is not callable”（abs指向了整数10不是求绝对值函数），若要恢复其作用需重启Python交互环境</li>
</ul>

<span id="more"></span><!-- more -->

<h5 id="toc_2">5.2 高阶函数（Higher-order function）</h5>

<ul>
<li>高阶函数就是让函数的参数能够接收别的函数</li>
</ul>

<h5 id="toc_3">a. map()函数</h5>

<ul>
<li>接收两个参数（一个是函数，一个是可迭代对象Iterable），将传入的函数参数依次作用到可迭代对象参数的每个元素，并将结果放到一个新创建的迭代器Iterator中，最后返回该迭代器Iterator</li>
<li><p>函数返回的结果是一个是Iterator（惰性序列），可以通过list()函数将转换为list对象（注：iter()函数可以将Iterable转换为Iterator）</p>

<pre><code class="language-python">&gt;&gt;&gt; l = [1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; def f(x):
...     return x * x
... 
&gt;&gt;&gt; r = map(f, l)
&gt;&gt;&gt; r
&lt;map object at 0x101aa1cc0&gt;
&gt;&gt;&gt; list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; list(map(str, l))
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]
</code></pre></li>
</ul>

<h5 id="toc_4">b. reduce()函数</h5>

<ul>
<li>接收的参数数量及类型与map()函数的相同，但是“函数参数”必须是只能接收两个参数的函数</li>
<li><p>取可迭代对象的中的前两个元素，传入到函数参数中计算结果，之后使用该结果和可迭代对象的中的后续元素，再次传入到函数参数中计算结果，循环之前的步骤；其效果是reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</p>

<pre><code class="language-python"># 将[1, 3, 5, 7, 9]变成整数13579:
from functools import reduce
def fn(x, y):
    return x * 10 + y

reduce(fn, [1, 3, 5, 7, 9])
13579

# 将str转为int:
from functools import reduce
def str2int(s):
    def fn(x, y):  # 函数可以嵌套定义
        return x * 10 + y
    def char2num(s):
        return {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}[s]
    return reduce(fn, map(char2num, s))

str2int(&#39;13579&#39;)
13579

# 将str转为int（使用lambda函数）:
from functools import reduc
def str2int(s):
    def char2num(s):
        return {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}[s]
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))

str2int(&#39;13579&#39;)
13579

# 字符串格式化:
def normalize(name):
    if isinstance(name, str):
        return name[:1].upper() + name[1:].lower()
    else:
        return name

list(map(normalize, [&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;, &#39;&#39;, &#39;123&#39;, 456]))
[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;&#39;, &#39;123&#39;, 456]

# 将str转float:
from functools import reduce
def str2float(s):
    s1, s2 = s.split(&#39;.&#39;)
    num = reduce(lambda x, y: x * 10 + y, map(int, s1 + s2))
    return num / (10 ** len(s2)) # **表示幂运算，*表示乘法

str2float(&#39;123.456&#39;)
123.456
</code></pre></li>
</ul>

<h5 id="toc_5">c. filter()函数</h5>

<ul>
<li>用于过滤序列；接收的参数数量及类型与map()函数的相同，函数参数依次作用于序列参数中的每个元素，然后根据其返回值是True还是False决定保留还是丢弃该元素</li>
<li><p>函数返回的结果是一个是Iterator（惰性序列），可以通过list()函数将转换为list对象</p>

<pre><code class="language-python"># 过滤序列中的空字符串:
&gt;&gt;&gt; def no_empty(s):
...     return s and s.strip()
...
&gt;&gt;&gt; l = [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, None, &#39;C&#39;, &#39; &#39;]
&gt;&gt;&gt; list(filter(no_empty, l))
[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]

# 求100以内的素数（埃氏筛法：筛选掉2、3、5的倍数）:
def print100():
    for n in primes():
        if n &lt; 100:
            print(n)
        else:
            break

def primes():  # 返回素数生成器
    yield 2
    it = _odd_iter()
        while True:
           n = next(it)
           print(&#39;primes...&#39;)
           yield n
           # 注意每次都会根据n动态生成新的筛选函数；it对自身进行过滤，每次过滤也会将前面的质数及其倍数过滤掉
           it = filter(_not_divisible(n), it)

def _odd_iter():  # 构建一个从3开始的奇数序列
   n = 1
   while True:
           n += 2
           print(&#39;_odd_iter...&#39;)
           yield n

def _not_divisible(n):  # 筛选函数
    return lambda x: x % n &gt; 0

# 回数（从左向右和从右向左都一样，如12321）:
def is_palindrome(n):
    s = str(n)
    return s == s[::-1] # str没有反转reverse()方法，但可使用反向切片s[::-1]实现

list(filter(is_palindrome, range(1, 1000)))
</code></pre></li>
</ul>

<h5 id="toc_6">d. sorted()函数</h5>

<ul>
<li>用于排序list；可接受一个函数参数key实现自定义排序，还可接收Bool参数reverse实现反向排序，参数key和reverse可以省略</li>
<li><p>两个元素x和y，若x&lt;y则返回-1，若x==y则返回0，若x&gt;y则返回1</p>

<pre><code class="language-python">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]

&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]

&gt;&gt;&gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower)
[&#39;about&#39;, &#39;bob&#39;, &#39;Credit&#39;, &#39;Zoo&#39;]

&gt;&gt;&gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower, reverse=True)
[&#39;Zoo&#39;, &#39;Credit&#39;, &#39;bob&#39;, &#39;about&#39;]
</code></pre></li>
</ul>

<h5 id="toc_7">5.3 返回函数</h5>

<ul>
<li>函数也可以作为返回值</li>
<li><strong>在外部函数lazy_sum中定义了内部函数sum，内部函数sum可以引用外部函数lazy_sum的参数和局部变量；当外部函数lazy_sum返回的是内部函数sum时，相关参数、变量将保存在返回的函数中，这种情况称为“闭包”</strong></li>
<li>注意：每次调用外部函数lazy_sum，即使传入相同的参数都是返回一个内部函数sum对象</li>
<li>闭包返回的函数并没有立即执行，直到调用了 <code>返回值()</code> 才执行</li>
<li><p><strong>闭包返回的函数不要引用循环变量或后续会发生变化的变量；若一定要引用则应该再创建一个内部函数，用新创建的内部函数的参数 <code>绑定</code> 该循环变量的当前值，这样无论该循环变量后续发生变化，已绑定到内部函数的参数的当前值不会受影响</strong></p>

<pre><code class="language-python">def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:  # 引用了外部函数lazy_sum的参数args
              ax += n
        return ax
    return sum

&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x0000000000D108C8&gt;
&gt;&gt;&gt; f()
25
&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)
&gt;&gt;&gt; f1 == f2
False

# 循环变量问题（闭包）:
def count():
    fs = []
    for i in range(1, 4):
        def f():
            return i * i
        fs.append(f)  # 仅仅添加f函数到数组中，f函数没有执行
    return fs

&gt;&gt;&gt; f1, f2, f3 = count()  # 取前三个元素依次赋值给f1、f2、f3
&gt;&gt;&gt; f1()
9
&gt;&gt;&gt; f2()
9
&gt;&gt;&gt; f3()
9

# 解决循环变量问题（闭包）:
def count():
    fs = []
    for i in range(1, 4):
        def g(j): # 再包装一层函数
            def f():
                return j * j
            return f
        fs.append(g(i)) # g(i)立即执行，当前的i值被传递到f函数中了（虽然还是仅仅添加f函数到数组中，f函数没有执行）
    return fs

&gt;&gt;&gt; f1, f2, f3 = count()
&gt;&gt;&gt; f1()
1
&gt;&gt;&gt; f2()
4
&gt;&gt;&gt; f3()
9
# 或者将g函数提取出来
def count():
     def g(j):
         def f():
             return j * j
         return f
     fs = []
     for i in range(1, 4):
         fs.append(g(i))
     return fs

&gt;&gt;&gt; f1, f2, f3 = count()
&gt;&gt;&gt; f1()
1
&gt;&gt;&gt; f2()
4
&gt;&gt;&gt; f3()
9
</code></pre></li>
</ul>

<h5 id="toc_8">5.4 匿名函数</h5>

<ul>
<li>使用关键字<code>lambda</code>表示匿名函数，其格式为 <code>lambda 函数的形参列表 : 函数的返回值表达式语句</code> ，返回值表达式语句就是使用该表达式的运算结果作为该匿名函数的返回值，不需要写return</li>
<li><strong>lambda可以省略函数的形参列表，注意此时lambda与:之间不能有空格</strong></li>
<li>匿名函数没有名字，不必担心函数名冲突</li>
<li><p>匿名函数也是一个函数对象；可以把匿名函数赋值给要给一个变量，也可以把匿名函数作为返回值返回</p>

<pre><code class="language-python">&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; f = lambda x: x * x
&gt;&gt;&gt; f
&lt;function &lt;lambda&gt; at 0x0000000000D10B70&gt;
&gt;&gt;&gt; f(5)
25

# lambda省略函数参数
&gt;&gt;&gt; r = lambda: 5
&gt;&gt;&gt; r
&lt;function &lt;lambda&gt; at 0x1032f5f28&gt;
&gt;&gt;&gt; r()
5
</code></pre></li>
</ul>

<h5 id="toc_9">5.5 装饰器（Decorator）</h5>

<ul>
<li>若要增强函数的功能，但又不希望修改函数的定义，这种在代码运行期间动态增加功能（比如在now()函数调前后增加自动打印日志功能）的方式称为“装饰器（Decorator）”</li>
<li><strong>装饰器（Decorator）是一个返回值为函数的高阶函数；接收一个函数作为参数并返回一个新的函数，附加了新功能</strong></li>
<li><p>函数对象都有一个__name__属性表示该函数的名称</p>

<pre><code class="language-python">def now():
    print(&#39;2015-3-25&#39;)

f = now
now.__name__  # &#39;now&#39;
f.__name__  # &#39;now&#39;

# 增强now函数功能（常规方式）:
def log(func):
    print(&#39;call %s()&#39; % func.__name__) # 这里只是打印日志，还可以有其它操作
    return func
# 调用：f = log(now)、f()
# 有缺陷：a. 执行log(now)时，f()还未执行时，但日志（增强功能）打印了；
#        b. 当now函数是有参数时，log函数无法获取now调用时传入的参数
</code></pre>

<pre><code class="language-python"># 增强now函数功能（使用装饰器，完美解决上述两个问题）:
#  a. 因为要延迟执行日志（增强功能）打印，所以需要新建内部函数，将相关代码加到内部函数中，之后并返回该内部函数
#  b. wrapper(*args, **kw)中的*args, **kw表示接受任意参数，可以为空；

# 因为返回的需要还是原来的func函数对象（这样就不用修改调用方式），但是本质是wrapper函数对象，
# 所以wrapper的参数列表应该和func一致，但是func是不确定的（任何函数都可以是func），所以参数列表需要写为任意参数的格式
def log(func):
        def wrapper(*args, **kw):
            print(&#39;call %s()&#39; % func.__name__)
            print(&#39;%s, %s&#39; % (args, kw))
            return func(*args, **kw) 
            # wrapper函数执行时，调用执行原来的func函数，返回值为func函数的返回值
        return wrapper
# 调用：f= log(now)、f()

# 最好借助python的@语法，把Decorator置于“要被增强”函数的定义处，
# 这样“要被增强”函数就被当做参数传入到Decorator中，并且被增强后的函数wrapper会被自动赋值给定义时的函数的名称变量
@log # log就是一个Decorator，相当于执行了now = log(now)
def now():
    print(&#39;2015-3-25&#39;)

now.__name__  # &#39;wrapper&#39;   
now()
# 输出结果：
call now()
(), {}
2015-3-25
</code></pre>

<pre><code class="language-python"># 增强now函数功能（Decorator带参数）:
# 因为@log(&#39;xx&#39;)相当于now = log(&#39;xx&#39;)(now)，执行了两次，所以需要再包装一层函数，
def log(text): # 该text参数为Decorator的参数
    def decorator(func): # 这一块相当于之前（Decorator不带参数）的log
        print(&#39;test...&#39;)
        def wrapper(*args, **kw):
            print(&#39;%s %s()&#39; % (text, func.__name__)) 
            print(&#39;%s, %s&#39; % (args, kw))
            return func(*args, **kw)
        return wrapper
    return decorator

@log(&#39;xx&#39;) # 相当于now = log(&#39;xx&#39;)(now)
def now():
    print(&#39;2015-3-25&#39;)

test... # 此时只是定义now，还没有调用now()，打印test...

now()
# 输出结果：
xx now()
(), {}
2015-3-25
</code></pre></li>
<li><p><strong>@log等价于func = log(func)，@log(&#39;xx&#39;)等价于func = log(&#39;xx&#39;)(func)</strong></p></li>
<li><p><strong>@log()和@log是不一样的，@log()等价于func = log()(func)</strong></p></li>
<li><p>经过Decorator装饰后的函数，其的__name__已经发生了变化；若Decorator返回的函数名称为&#39;xyz&#39;（原来为&#39;now&#39;），则now.__name__就为&#39;xyz&#39;</p></li>
<li><p>有些依赖函数签名的代码，需要保留原始函数的__name__等属性，否则执行就会出错</p></li>
<li><p>保留原始函数的__name__的方式：a. 手动赋值，wrapper.__name__ = func.__name__；b. 使用Python内置的functools.wraps(func)</p>

<pre><code class="language-python">import functools
def log(func):
    @functools.wraps(func) 
    # 在定义wrapper()的前面添加此代码，相当于wrapper.__name__ = func.__name__
    def wrapper(*args, **kw):
        print(&#39;call %s()&#39; % func.__name__)
        return func(*args, **kw)
    return wrapper

@log
def now():
    print(&#39;2015-3-25&#39;)

now.__name__  # &#39;now&#39;
</code></pre></li>
<li><p>在OOP的设计模式中，Decorator被称为装饰模式；OOP的装饰模式需要通过继承和组合来实现，而Python除了支持OOP的Decorator（用类实现），还直接从语法层次支持Decorator（用函数实现）</p></li>
<li><p>练习：编写Decorator，使其能在函数调用前后打印&#39;begin call&#39;和&#39;end call&#39;，并且同时支持@log和@log(&#39;execute&#39;)</p>

<pre><code>import functools
def log(msg):
     # callable(obj)：检查obj对象是否可以被调用；若可以则obj是函数
    if callable(msg): # 可调用，说明此时的log就是不带参数的@log
        func = msg
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print(&#39;no params, begin call&#39;)
            f = func(*args, **kw)
            print(&#39;no params, end call&#39;)
            return f
        return wrapper
    else:
        text = msg
        def decorator(func):
            @functools.wraps(func)
            def wrapper(*args, **kw):
                print(&#39;with params, begin call, %s&#39; % text)
                f = func(*args, **kw)
                print(&#39;with params, end call&#39;)
                return f
            return wrapper
        return decorator

&gt;&gt;&gt; from testpy import log
&gt;&gt;&gt; @log
... def f():
...     print(&#39;haha&#39;)
... 
&gt;&gt;&gt; f()
no params, begin call
haha
no params, end call

&gt;&gt;&gt; @log(&#39;execute&#39;)
... def f():
...     print(&#39;haha&#39;)
... 
&gt;&gt;&gt; f()
with params, begin call, execute
haha
with params, end call
</code></pre></li>
</ul>

<h5 id="toc_10">5.6 偏函数</h5>

<ul>
<li>Python的functools.partial提供了偏函数（Partical function）功能；偏函数就是把一个函数的某些参数固定住（设置默认值），然后返回一个新的函数，这样调用新函数更简单</li>
<li><p>创建偏函数时，可以接收函数对象、*args和**kw三个参数</p>

<pre><code class="language-python">&gt;&gt;&gt; int(&#39;12345&#39;)  # int()函数默认按照10进制转换
12345
&gt;&gt;&gt; int(&#39;12345&#39;, base=8)  # 可以设置int()函数的base默认关键字参数，按照base参数进制进行转换
5349
&gt;&gt;&gt; int(&#39;12345&#39;, 16)
74565

# 若需要进行大量二进制字符串转换，每次都传入base=2比较麻烦；可以自定义一个int2函数，默认将base=2传入
&gt;&gt;&gt; def int2(x, base=2):
...     return int(x, base)
... 
&gt;&gt;&gt; int2(&#39;1000000&#39;)
64

# functools.partial可以自动创建一个这样的函数（偏函数），不需要我们自己定义int2()函数
&gt;&gt;&gt; import functools 
&gt;&gt;&gt; int22 = functools.partial(int, base=2)  
&gt;&gt;&gt; int22(&#39;1000000&#39;)
64

&gt;&gt;&gt; max22 = functools.partial(max, 10)
&gt;&gt;&gt; max22(5, 6, 7)
10
</code></pre></li>
</ul>
]]></content>
  </entry>
  

</feed>
