<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[TIME TO GO]]></title>
  <link href="http://www.justisit.com/atom.xml" rel="self"/>
  <link href="http://www.justisit.com/"/>
  <updated>2018-06-01T00:01:43+08:00</updated>
  <id>http://www.justisit.com/</id>
  <author>
    <name><![CDATA[]]></name>
  </author>
  <generator uri="">ME</generator>

  
  <entry>
    <title type="html"><![CDATA[Android编程权威指南 笔记(19~24)]]></title>
    <link href="http://www.justisit.com/15237039848080.html"/>
    <updated>2018-04-14T19:06:24+08:00</updated>
    <id>http://www.justisit.com/15237039848080.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">第19章 Android辅助功能</a>
</li>
<li>
<a href="#toc_1">第20章 数据绑定与MVVM</a>
<ul>
<li>
<a href="#toc_2">20.1 为何要用MVVM架构</a>
</li>
<li>
<a href="#toc_3">20.2 创建BeatBox应用</a>
</li>
<li>
<a href="#toc_4">20.3 导入assets</a>
</li>
<li>
<a href="#toc_5">20.4 处理assets</a>
</li>
<li>
<a href="#toc_6">20.6 绑定数据</a>
</li>
<li>
<a href="#toc_7">20.7 访问assets</a>
</li>
<li>
<a href="#toc_8">20.8 深入学习：数据绑定再探</a>
</li>
<li>
<a href="#toc_9">20.10 深入学习：什么是non-assets</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">第21章 音频播放与单元测试</a>
<ul>
<li>
<a href="#toc_11">21.0 概述</a>
</li>
<li>
<a href="#toc_12">21.1 创建SoundPool</a>
</li>
<li>
<a href="#toc_13">21.2 加载音频文件</a>
</li>
<li>
<a href="#toc_14">21.3 播放音频</a>
</li>
<li>
<a href="#toc_15">21.4 ~ 21.7 添加测试依赖、创建测试类、实现测试类、编写测试方法</a>
</li>
<li>
<a href="#toc_16">21.8 数据绑定回调</a>
</li>
<li>
<a href="#toc_17">21.9 释放音频</a>
</li>
<li>
<a href="#toc_18">21.10 设备旋转和对象保存</a>
</li>
<li>
<a href="#toc_19">21.11 深入学习：是否保留fragment</a>
</li>
<li>
<a href="#toc_20">21.12 ~ 21.13 深入学习：Espresson与整合测试、深入学习：虚拟对象与测试</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">第22章 样式与主题</a>
<ul>
<li>
<a href="#toc_22">22.1 颜色资源</a>
</li>
<li>
<a href="#toc_23">22.2 样式</a>
</li>
<li>
<a href="#toc_24">22.3 主题</a>
</li>
<li>
<a href="#toc_25">22.4 添加主题颜色</a>
</li>
<li>
<a href="#toc_26">22.5 覆盖主题属性</a>
</li>
<li>
<a href="#toc_27">22.6 修改按钮属性</a>
</li>
<li>
<a href="#toc_28">22.7 深入学习：样式继承拾遗</a>
</li>
<li>
<a href="#toc_29">22.8 深入学习：引用主题属性</a>
</li>
</ul>
</li>
<li>
<a href="#toc_30">第23章 XML drawable</a>
<ul>
<li>
<a href="#toc_31">23.0 概述</a>
</li>
<li>
<a href="#toc_32">23.2 shape drawable</a>
</li>
<li>
<a href="#toc_33">23.3 state list drawable</a>
</li>
<li>
<a href="#toc_34">23.4 layer list drawable</a>
</li>
<li>
<a href="#toc_35">23.6 深入学习：使用mipmap图像</a>
</li>
<li>
<a href="#toc_36">23.7 深入学习：使用9-patch图像</a>
</li>
</ul>
</li>
<li>
<a href="#toc_37">第23章 深入学习intent和任务</a>
<ul>
<li>
<a href="#toc_38">24.2 解析隐式intent</a>
</li>
<li>
<a href="#toc_39">24.3 在运行时创建显式intent</a>
</li>
<li>
<a href="#toc_40">24.4 任务与回退栈</a>
</li>
<li>
<a href="#toc_41">24.5 使用NerdLauncher应用作为设备主屏幕</a>
</li>
<li>
<a href="#toc_42">24.7 深入学习：进程与任务</a>
</li>
<li>
<a href="#toc_43">24.8 深入学习：并发文档</a>
</li>
</ul>
</li>
</ul>


<span id="more"></span><!-- more -->

<h3 id="toc_0">第19章 Android辅助功能</h3>

<p><strong>略</strong></p>

<h3 id="toc_1">第20章 数据绑定与MVVM</h3>

<h4 id="toc_2">20.1 为何要用MVVM架构</h4>

<ul>
<li><p>MVVM（Model-View-ViewModel）架构很好地把控制器里的臃肿代码抽到布局文件里，让开发人员很容易看出哪些是动态界面；同时，也抽出部分动态控制器代码放入ViewModel类，这大大方便了开发测试和验证；</p></li>
<li><p>每个视图模型应控制成多大规模，需要具体情况具体分析，若视图模型过大，还可以继续拆分；都用MVVM架构，但业务不同，场景不一样，每个人的具体实现方法都有差异；</p></li>
</ul>

<h4 id="toc_3">20.2 创建BeatBox应用</h4>

<ul>
<li><p><strong>之前，UI布局文件及其中的组件，都是使用LayoutInflater类去<code>inflate()</code>布局文件，之后通过<code>findByID()</code>去将布局实例化后组件对象与控件变量进行关联；</strong></p></li>
<li><p><strong>现在，通过数据绑定（Data Binding）技术，可以使用DataBindingUtil类去<code>inflate()</code>布局文件，自动获得XXXBinding对象（Android Stuido自动生成该绑定类，BindingClass），之后通过该XXXBinding对象就可以直接访问UI布局内的组件对象，即通过数据绑定获取视图，省略手动去调用findByID()；</strong></p></li>
<li><p><strong>在app模块的build.gradle文件里增加以下内容，启用数据绑定；</strong></p>

<pre><code>buildTypes {
    // 打开IDE的整合功能，允许你使用数据绑定产生的类，并把它们整合到编译
    dataBinding {
        enabled true
    }
}
</code></pre></li>
<li><p><strong>要在布局中使用数据绑定：首先要把一般布局改造为<code>数据绑定布局</code>，具体做法就是把整个布局定义放入<layout>标签中；</strong></p>

<pre><code>// 之前：把一般布局
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.v7.widget.RecyclerView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/fragment_beat_box_recycler_view&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; /&gt;
</code></pre>

<pre><code>// 现在：数据绑定布局
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;android.support.v7.widget.RecyclerView
        android:id=&quot;@+id/fragment_beat_box_recycler_view&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot; /&gt;
&lt;/layout&gt;
</code></pre>

<ul>
<li><strong><layout>：让数据绑定工具处理该布局；数据绑定工具会自动生成一个绑定类（binding class），类名默认以布局文件命名（不是snake_case这种格式，是CamelCase格式）；比如上面的布局文件名为<code>fragment_beat_box.xml</code>，生成的绑定类类名为<code>FragmentBeatBoxBinding</code>；</strong></li>
<li><strong>绑定类有一个<code>getRoot()</code>方法，可以获取布局视图结构的根元素对应的UI对象；</strong></li>
<li><strong>绑定类还会为布局文件中带android:id标签的元素，自动生成一些属性，引用着对应的UI对象；比如布局文件中id为<code>fragment_beat_box_recycler_viev</code>的RecyclerView，绑定类自动生成<code>fragmentBeatBoxRecyclerView</code>属性；</strong></li>
<li><strong>若绑定类没有正常生成，需要重新编译一些项目；</strong></li>
</ul></li>
<li><p><strong>通过数据绑定获取视图：</strong></p>

<pre><code class="language-java">@Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
    // 绑定类
    FragmentBeatBoxBinding binding = DataBindingUtil.
            inflate(inflater, R.layout.fragment_beat_box, container, false);
    binding.fragmentBeatBoxRecyclerView.setLayoutManager(new GridLayoutManager(getActivity(), 3));
    binding.fragmentBeatBoxRecyclerView.setAdapter(new SoundAdapter(mBeatBox.getSounds()));

    return binding.getRoot();
}
</code></pre></li>
</ul>

<h4 id="toc_4">20.3 导入assets</h4>

<ul>
<li><p><strong>资源系统（resources system）可以用来打包应用所需的图片、XML文件以及其他非Java资源；</strong></p></li>
<li><p><strong>assets是另外一种资源打包方式，其也可以像资源系统那样打入APK包；可以将其看作随应用打包的微型文件系统，支持任意层次的文件目录结构，没有配置管理，无法自动响应屏幕显示密度、语言等设备配置变更，自然也就无法在布局或其他资源里自动使用它们；通常类似游戏这样需要加载大量图片和声音资源的应用使用assets；</strong></p></li>
<li><p><strong>resource资源也可以存储声音资源，比如在res/raw目录保存79_scream.wav这样的文件，就可以使用R.raw.79_scream这样的ID获取它，而且还可以根据屏幕显示密度、语言等设备配置使用不同的声音资源；但是这样的话，Android资源系统处理的效率低；</strong></p></li>
<li><p><strong>创建assets目录：右键app模块 -&gt; 选择New -&gt; Folder -&gt; Assets Folder，取消Change Folder Location选项，保持Target Source Set为main，即完成创建；</strong>之后将声音文件（夹）加入即可；assets目录中的所有文件都是会随着应用打包；</p></li>
</ul>

<h4 id="toc_5">20.4 处理assets</h4>

<ul>
<li><p><strong>访问assets需要使用AssetManager类，其可以从context中获取到；通常在访问assets时，不用关心究竟使用哪个Context对象，因为所有Context对象的AssetManager管理的都是同一套assets资源；</strong></p>

<pre><code class="language-java">AssetManager mAssets = context.getAssets();
</code></pre></li>
<li><p>使用assetManager的list(String)方法，能获取assets中的资源清单中，指定目录中的所有文件名；</p>

<pre><code class="language-java">String[] soundNames = mAssets.list(SOUNDS_FOLDER);
</code></pre></li>
</ul>

<h4 id="toc_6">20.6 绑定数据</h4>

<ul>
<li><p>使用数据绑定，我们还可以在布局文件中声明数据对象<code>（data、variable）</code>；</p>

<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;crime&quot;
            type=&quot;com.bignerdranch.android.criminalintent.Crime&quot;/&gt;
    &lt;/data&gt;
    ....
&lt;/layout&gt;
</code></pre></li>
<li><p>之后，使用绑定操作符<code>@{}</code>，可以在布局文件中直接使用这些数据对象的值；</p>

<pre><code>&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;crime&quot;
            type=&quot;com.bignerdranch.android.criminalintent.Crime&quot;/&gt;
    &lt;/data&gt;

    &lt;!-- 使用crime variable --&gt;
    &lt;CheckBox android:id=&quot;@+id/list_item_crime_solved_check_box&quot;
        android:checked=&quot;@{crime.isSolved()}&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;/&gt;
&lt;/layout&gt;
</code></pre>

<ul>
<li><strong>上面的数据绑定（绑定了list_item_sound.xml布局文件中的Sound对象），破坏了责任划分，Sound模型对象不可避免地需要关心显示的问题；</strong></li>
<li><strong>为了避免上述问题，引入一种叫作<code>视图模型</code>的新对象（SoundViewModel），其负责如何显示视图，这种架构称为MVVM；之前，控制器对象<code>格式化提供</code>视图所需要的数据，现在，视图模型对象<code>格式化提供</code>视图所需要的数据；</strong></li>
<li><strong>并且现在使用了数据绑定，关联数据直接在布局文件里处理；控制器负责初始化布局绑定类和视图模型对象，同时也是它们之间的联系纽带；</strong></li>
<li><strong>MVVM和数据绑定是独立的；若使用了数据绑定，MVVM更简洁；但是若只使用数据绑定，则会出现模型对象不可避免地需要关心显示的问题，而使用MVVM是可以避免此问题；</strong></li>
</ul></li>
<li><p>使用了数据绑定和MVVM：</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;
    &lt;Button
        android:id=&quot;@+id/list_item_sound_button&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;120dp&quot;
        tools:text=&quot;Sound name&quot;
        android:text=&quot;@{viewModel.title}&quot;/&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;viewModel&quot;
            type=&quot;com.example.scott.beatbox.SoundVewModel&quot; /&gt;
    &lt;/data&gt;
&lt;/layout&gt;
</code></pre>

<ul>
<li><code>@{viewModel.title}</code>：使用了”语法糖“，viewModel.title就是viewModel.getTitle()的简写；</li>
<li><strong>之后需要创建一个数据对象，将其设置给该布局对应的绑定类；在这里数据对象为SoundViewModel视图模型对象；</strong></li>
<li><strong>若数据对象中的数据变化了，最好调用绑定对象的<code>executePendingBindings()</code>方法，强制立即刷新改变；比如在RecyclerView中需要更新绑定数据；</strong></li>
</ul></li>
<li><p><strong>数据对象中的数据变化了，布局文件是不知道哪些数据变化了、需要刷新；</strong></p>

<ul>
<li><strong><code>绑定类是数据对象和布局文件之间的桥梁（数据绑定） ；</code>可以让数据对象的类实现数据绑定的<code>Observable</code>接口，绑定类在数据对象的类上设置监听器，这样，只要数据对象有变化，绑定类立即会收到回调；但该方式工作量过大；</strong></li>
<li><strong>数据绑定提供了BaseObservable类简化上述操作：</strong>

<ul>
<li><strong>a. 数据对象的类继承BaseObservable；</strong></li>
<li><strong>b. 使用<code>@Bindable</code>注解数据对象中需要监听的属性、get方法；</strong></li>
<li><strong>c. 当数据对象中的数据变化时，手动调用<code>notifyChange()</code>方法或<code>notifyPropertyChanged(int)</code>方法，通知绑定类，数据对象中的数据已更新，绑定类会再次运行<code>绑定表达式</code>更新视图；</strong></li>
</ul></li>
</ul></li>
</ul>

<h4 id="toc_7">20.7 访问assets</h4>

<ul>
<li><p>使用File对象是无法打开资源文件，需要使用AssetManager，这样才能得到标准的InputStream数据流（和Java中的InputStream使用方式一样）；</p>

<pre><code class="language-java">InputStream soundData = mAssets.open(assetPath);
</code></pre></li>
<li><p>有些API需要的是FileDescriptor类（比如SoundPool类），调用AssetManager.openFd(String)可以获取到类型的对象；</p>

<pre><code class="language-java">String assetPath = sound.getAssetPath();
AssetFileDescriptor assetFd = mAssets.openFd(assetPath);
FileDescriptor fd = assetFd.getFileDescriptor();
</code></pre></li>
</ul>

<h4 id="toc_8">20.8 深入学习：数据绑定再探</h4>

<ul>
<li><p>在布局文件里，还可以使用lambda表达式（与Java 8 lambda表达式有些差异）进行回调，比如 <code>android:onClick=&quot;@{(view) -&gt; viewModel.onButtonClick()}&quot;</code>；</p></li>
<li><p><strong>在数据绑定中，可以使用单引号代替双引号，常用于字符串中；而且其还有null自动处理机制，若数据为null会自动转为字符串&quot;null&quot;；比如<code>android:text=&quot;@{`File name: ` + viewModel.title}&quot;</code>;</strong></p></li>
<li><p>数据绑定默认会把绑定表达式解读为属性方法调用；</p></li>
</ul>

<h4 id="toc_9">20.10 深入学习：什么是non-assets</h4>

<ul>
<li><p>Android有assets和resources两大资源系统；resources资源系统设计有很好的检索机制，但它无法处理图形和声音这样的大资源，这些大资源实际上保存在assets系统中；</p></li>
<li><p>在后台，Android就是使用AssetManager类的openNonAssetFd()方法来打开这些大资源的（这些方法对外没有开放，在外面直接使用open()方法）；</p></li>
</ul>

<h3 id="toc_10">第21章 音频播放与单元测试</h3>

<h4 id="toc_11">21.0 概述</h4>

<ul>
<li>SoundPool能加载一批声音资源到内存中，并支持同时播放多个音频文件；</li>
</ul>

<h4 id="toc_12">21.1 创建SoundPool</h4>

<ul>
<li><p>Lollipop引入新的创建SoundPool的方式：使用<code>SoundPool.Builder</code>；为了兼容低版本，还可以使用<code>SoundPool(int, int, int)</code>构造方法：</p>

<ul>
<li>参数一：同时播放的音频数；</li>
<li>参数二：音频流类型，AudioManager类中的常量；Android有很多不同的音频流，它们都有各自独立的音量控制选项；这就是调低音乐音量，闹钟音量却不受影响的原因；STREAM_MUSIC是音乐和游戏常用的音量控制常量；</li>
<li>参数三：采样率转换品质（参数不起作用，传入0即可）；</li>
</ul>

<pre><code class="language-java">SoundPool mSoundPool = new SoundPool(MAX_SOUNDS, AudioManager.STREAM_MUSIC, 0);
</code></pre></li>
</ul>

<h4 id="toc_13">21.2 加载音频文件</h4>

<ul>
<li><p><strong>使用SoundPool播放前必须预加载音频，SoundPool加载的音频文件都有int类型的ID；注意保存时使用Integer类型而不是int，这样在ID没有值时可以设置为null值；</strong></p></li>
<li><p>调用<code>soundPool.load(AssetFileDescriptor, int)</code>可以把音频文件载入SoundPool中等待播放，返回值为int类型的ID；使用该ID可以方便管理、重播或卸载音频文件；</p>

<pre><code class="language-java">AssetFileDescriptor afd = mAssetManager.openFd(assetPath); // 资源描述对象
int soundId = mSoundPool.load(afd, 1);
</code></pre></li>
</ul>

<h4 id="toc_14">21.3 播放音频</h4>

<ul>
<li>播放之前需要检查soundId是否为null值，之后调用<code>soundPool.play(int, float, float, int, int, float)</code>播放音频，参数依次为音频ID、左音量、右音量、优先级（无效）、是否循环播放、速率；最大音量和常速播放的值为1.0，不循环播放值为0，无限循环播放值为-1；</li>
</ul>

<h4 id="toc_15">21.4 ~ 21.7 添加测试依赖、创建测试类、实现测试类、编写测试方法</h4>

<p><strong>略</strong></p>

<h4 id="toc_16">21.8 数据绑定回调</h4>

<ul>
<li><p>和前面使用数据绑定关联数据和UI控件一样，也可以使用lambda表达式，让数据绑定关联点击监听器和按钮；</p>

<pre><code>&lt;Button
    android:layout_width=&quot;match_parent&quot; 
    android:layout_height=&quot;120dp&quot;
    android:onClick=&quot;@{() -&gt; viewModel.onButtonClicked()}&quot; 
    android:text=&quot;@{viewModel.title}&quot;
    tools:text=&quot;Sound name&quot;/&gt;
</code></pre></li>
</ul>

<h4 id="toc_17">21.9 释放音频</h4>

<ul>
<li>音频播放完毕后，需要调用<code>soundPool.release()</code>来释放SoundPool；</li>
</ul>

<h4 id="toc_18">21.10 设备旋转和对象保存</h4>

<ul>
<li><p><strong>当设备旋转时，Activity会被销毁，同时FragmentManager也会销毁与之相关的Fragment；</strong></p>

<ul>
<li><strong>对于基本数据类型、Serializable、Parcelable等<code>可保存的数据</code>可以使用onSaveInstanceState(Bundle)方法进行保存恢复；</strong></li>
<li><strong>对于像播放中断进度等<code>不可保存的数据</code>无法使用onSaveInstanceState(Bundle)方法进行保存恢复；</strong></li>
</ul></li>
<li><p>若一个对象重度依赖另一个不可保存的对象，那么这个对象很可能也无法保存恢复；</p></li>
<li><p><strong>为了解决由于设备配置发生变化导致fragment被销毁，而且其中的<code>不可保存的数据</code>无法使用onSaveInstanceState(Bundle)方法进行保存的问题：</strong></p>

<ul>
<li><strong>fragment提供了setRetainInstance(bool)方法，可以让其在设备配置变化，activity销毁时，fragment不被销毁，进而fragment中不可保存的对象不被销毁；</strong></li>
<li><strong>fragment的retainInstance属性值默认为false，表示其不会被保留；因此设备配置发生变化时，fragment会随托管activity一起被销毁并重建；</strong></li>
<li><strong>在fragment的onCreate()方法中调用<code>setRetainInstance(true)</code>可保留fragment；</strong></li>
</ul></li>
<li><p><strong>设备配置发生变化时，会销毁fragment的视图、activity的视图、fragmentManager、activity，而fragment则会根据其retainInstance属性值，决定是否保留该fragment；新的activity创建后，新fragmentManager会找到已保留的fragment后会重新创建其对于的视图；</strong></p></li>
<li><p><strong>需要销毁与重建fragment的的视图、activity的视图的原因是：新的设备配置可能需要新的资源来匹配，应使用更合适的资源重建视图；</strong></p></li>
<li><p><strong>虽然保留的fragment没有被销毁，但是其已经脱离了activity并处于<code>保留状态</code>（销毁时只销毁fragment的视图，不销毁fragment本身）；fragment进入保留状态必须满足：设置setRetainInstance(true)、设备配置改变导致托管activity正在被销毁；</strong></p></li>
</ul>

<h4 id="toc_19">21.11 深入学习：是否保留fragment</h4>

<ul>
<li><p><strong>不建议使用保留fragment：</strong></p>

<ul>
<li>a. 相对于非保留fragment，保留fragment用起来更复杂，出现问题不容易排查；</li>
<li>b. <strong>保留fragment只能处理activity因设备旋转销毁的情况；若activity因系统回收内存而销毁，则所有保留的fragment也会随之销毁，数据也就随之丢失；</strong></li>
</ul></li>
<li><p>onSaveInstanceState与setRetainInstance比较：</p>

<ul>
<li><strong>onSaveInstanceState默认保存view的状态，并且可以长久保存；</strong></li>
<li><strong>setRetainInstance无法长久保存，若因系统回收销毁activity，则fragment及相关数据则无法进行恢复；</strong></li>
</ul></li>
</ul>

<h4 id="toc_20">21.12 ~ 21.13 深入学习：Espresson与整合测试、深入学习：虚拟对象与测试</h4>

<p><strong>略</strong></p>

<h3 id="toc_21">第22章 样式与主题</h3>

<h4 id="toc_22">22.1 颜色资源</h4>

<ul>
<li><p><strong><code>颜色资源</code>定义在<code>res/values/colors.xml</code>中；可以应用在视图组件的textColor、backgroundColor等属性上（<code>@color/xxx</code>），也可以被样式资源引用；</strong></p>

<pre><code>&lt;resources&gt;
    &lt;color name=&quot;colorPrimary&quot;&gt;#3F51B5&lt;/color&gt;
    &lt;color name=&quot;dark_blue&quot;&gt;#005A8A&lt;/color&gt;
&lt;/resources&gt;
</code></pre></li>
</ul>

<h4 id="toc_23">22.2 样式</h4>

<ul>
<li><p><strong><code>样式资源</code>定义在<code>res/values/styles.xml</code>中，可以应用在视图组件的style属性，其是一套属性集合；</strong></p>

<pre><code>&lt;style name=&quot;BeatBoxButton&quot;&gt;
    &lt;item name=&quot;android:background&quot;&gt;@color/dark_blue&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<pre><code>&lt;Button style=&quot;@style/BeatBoxButton&quot;/&gt;
</code></pre></li>
<li><p>样式支持继承；一个样式能继承并覆盖其他样式的属性；有两种继承方式，一种是NAME加样式名前缀点（表示继承该样式），另一种是使用parent属性指明；</p>

<pre><code>&lt;style name=&quot;BeatBoxButton.Strong&quot;&gt;
    &lt;item name=&quot;android:textStyle&quot;&gt;bold&lt;/item&gt; 
&lt;/style&gt;
</code></pre>

<pre><code>&lt;style name=&quot;StrongBeatBoxButton&quot; parent=&quot;@style/BeatBoxButton&quot;&gt;
    &lt;item name=&quot;android:textStyle&quot;&gt;bold&lt;/item&gt;
&lt;/style&gt;
</code></pre></li>
</ul>

<h4 id="toc_24">22.3 主题</h4>

<ul>
<li><p><strong>主题可看作样式的进化加强版；同样是定义一套属性，<br/>
样式属性需要逐个添加，而主题属性则会自动应用于整个应用；</strong></p></li>
<li><p><strong>定义时的方式和样式一模一样，只是使用时应用在AndroidManifest.xml的application标签的<code>theme</code>属性上；主题属性能引用颜色这样的外部资源，也能引用其他样式；</strong></p>

<pre><code>&lt;application android:theme=&quot;@style/AppTheme&quot;&gt;
</code></pre></li>
<li><p><strong>主题实际就是一种样式，但是主题指定的属性有别于样式，样式指定的属性仅适用于单个组件</strong></p></li>
<li><p>AppCompat库自带三大主题：Theme.AppCompat（深色主题）、Theme.AppCompat.Light（浅色主题）、Theme.AppCompat.Light.DarkActionBar（带深色工具栏的浅色主题）</p></li>
</ul>

<h4 id="toc_25">22.4 添加主题颜色</h4>

<ul>
<li><p>虽然这主题属性看上去和前面的样式属性差不多，但它们的应用范围不一样；样式属性仅适用于单个组件，主题属性则适用所有使用同一主题的组件；</p>

<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/red&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/dark_red&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/gray&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<ul>
<li>colorPrimary：用于设置工具栏的背景色，该颜色也被称为应用品牌色；</li>
<li>colorPrimaryDark：用于设置屏幕顶部状态栏的背景色，其是深色版colorPrimary；注意，只有Lollipop之后的系统支持状态栏颜色，对于之前的系统，状态栏都是不变的黑底色；</li>
<li>colorAccent：该颜色应该和colorPrimary形成反差效果，主要给EditTextView这样的组件着色；按钮组件不支持着色；</li>
<li>建议这三个主题颜色都一起设置，因为继承自父主题的默认值可能与自己设置的其他主题颜色不搭；</li>
</ul></li>
</ul>

<h4 id="toc_26">22.5 覆盖主题属性</h4>

<ul>
<li><p>寻找主题中可以覆盖的属性，需要根据主题的继承关系，一层层向上查询研究该属性的定义，直找到目标为止，没有其他办法；</p></li>
<li><p><strong>有些主题有不同的版本（比如v4、v7、v21版本），对应版本有不同的主题属性；且相同的版本在不同的SDK中的定义可能有差异；</strong></p></li>
<li><p><strong>有些主题的名称带android:前缀，该前缀不可忽略，这说明该主题包含在Android操作系统中，引用时必须加上命名空间；而不带前缀则说明该资源是应用的一部分，编译项目时工具会引入相关的Java和XML文件；</strong></p>

<ul>
<li><p>比如，主题的背景色属性，定义为<code>&lt;item name=&quot;android:colorBackground&quot;&gt;@color/background_material_dark&lt;/item&gt;</code>，在style.xml文件中覆盖该主题属性即可修改；</p>

<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat&quot;&gt;
    &lt;!-- Customize your theme here. --&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;

    &lt;item name=&quot;android:colorBackground&quot;&gt;@color/soothing_blue&lt;/item&gt;
&lt;/style&gt;
</code></pre></li>
</ul></li>
</ul>

<h4 id="toc_27">22.6 修改按钮属性</h4>

<ul>
<li><p><strong>通过查看主题的定义，观察到关于按钮的主题属性为buttonStyle（<code>&lt;item name=&quot;buttonStyle&quot;&gt;@style/Widget.AppCompat.Button&lt;/item&gt;</code>），该属性没有设置值，而是指向了一个样式资源（多个属性）；</strong></p>

<ul>
<li><strong>之前覆盖android:colorBackground属性时直接传入了颜色值（只有一个属性）；</strong></li>
<li><p><strong>现在buttonStyle应该指向另一个样式，且继承于之前的父样式（点击进去之前的样式查看其父样式）并覆盖想要修改的属性；</strong></p>

<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat&quot;&gt;
    &lt;!-- Customize your theme here. --&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;

    &lt;item name=&quot;android:colorBackground&quot;&gt;@color/soothing_blue&lt;/item&gt;

    &lt;item name=&quot;buttonStyle&quot;&gt;@style/BeatBoxBtn&lt;/item&gt;
&lt;/style&gt;

&lt;style name=&quot;BeatBoxBtn&quot; parent=&quot;Widget.AppCompat.Button&quot;&gt;
    &lt;item name=&quot;android:background&quot;&gt;@color/dark_blue&lt;/item&gt;
&lt;/style&gt;
</code></pre></li>
</ul></li>
</ul>

<h4 id="toc_28">22.7 深入学习：样式继承拾遗</h4>

<ul>
<li><p><strong>以主题名的形式指定父主题，父子主题都应处于同一个包中，Android操作系统内部主题间的继承、、AppCompat库内部主题间的继承，都可以直接使用主题名继承表示法；若一旦AppCompat库要跨库继承，就一定要明确使用parent属性；</strong></p></li>
<li><p><strong>在开发自己的应用时应遵守同样的规则；若是继承自己内部的主题使用主题名指定父主题，若是继承Android操作系统中的样式或主题使用parent属性；</strong></p></li>
</ul>

<h4 id="toc_29">22.8 深入学习：引用主题属性</h4>

<ul>
<li><p>在引用资源时使用@符号，比如<code>@color/gray</code>；也可以使用?符号，比如<code>android:background=&quot;?attr/colorAccent&quot;</code>，表示使用colorAccent属性指向的资源；也可以使用相关的代码进行引用；</p>

<pre><code class="language-java">Resources.Theme theme = getActivity().getTheme();
int[] attrsToFetch = { R.attr.colorAccent };
TypedArray a = theme.obtainStyledAttributes(R.style.AppTheme, attrsToFetch);
int accentColor = a.getInt(0, 0);
a.recycle();
</code></pre></li>
</ul>

<h3 id="toc_30">第23章 XML drawable</h3>

<h4 id="toc_31">23.0 概述</h4>

<ul>
<li><p><strong>Android中在屏幕上绘制的东西都可以叫做drawable，比如抽象图形、Drawable类的子类代码、位图图形；</strong></p></li>
<li><p><strong>之前使用的BitmapDrawable就是一种drawable；还有其他类型的drawable，比如<code>state list drawable</code>、<code>shape drawable</code>、<code>layer list drawable</code>，这三种drawable都定义在XML文件中，统称为<code>XML drawable</code>；</strong></p></li>
</ul>

<h4 id="toc_32">23.2 shape drawable</h4>

<ul>
<li><p><strong><code>XML drawable</code>和屏幕像素密度无关，无需创建特定像素密度目录，直接将其放入默认的drawable文件夹中即可；</strong></p></li>
<li><p>可以使用shape drawable将图片变形（比如变为圆形等）、修改颜色等；</p>

<pre><code>// 新建res/drawable/button_beat_box_normal.xml，定义了一个背景为深蓝色的圆形
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
       android:shape=&quot;oval&quot;&gt;
    &lt;solid android:color=&quot;@color/dark_blue&quot;/&gt;
&lt;/shape&gt;
</code></pre>

<pre><code>// 使用
&lt;style name=&quot;BeatBoxBtn&quot; parent=&quot;android:style/Widget.Holo.Button&quot;&gt;
    &lt;item name=&quot;android:background&quot;&gt;@drawable/button_beat_box_normal&lt;/item&gt;
&lt;/style&gt;
</code></pre></li>
</ul>

<h4 id="toc_33">23.3 state list drawable</h4>

<ul>
<li><p><code>state list drawable</code>可以解决按钮的不同状态下（如点击状态）的图形显示需求，其会根据按钮的状态，切换指向不同的drawable；注意，默认状态值必须要声明，或者将默认状态放在最后，否则状态设置无效；</p>

<pre><code>// 新建res/drawable/button_beat_box.xml，每个item都是shape drawable文件
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:drawable=&quot;@drawable/button_beat_box_normal&quot; android:state_pressed=&quot;false&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/button_beat_box_pressed&quot; android:state_pressed=&quot;true&quot;/&gt;
&lt;/selector&gt;
</code></pre>

<pre><code>// 使用时
&lt;style name=&quot;BeatBoxBtn&quot; parent=&quot;android:style/Widget.Holo.Button&quot;&gt;
    &lt;item name=&quot;android:background&quot;&gt;@drawable/button_beat_box&lt;/item&gt;
&lt;/style&gt;
</code></pre></li>
</ul>

<h4 id="toc_34">23.4 layer list drawable</h4>

<ul>
<li><p><code>layer list drawable</code>可以将两个<code>XML drawable</code>合二为一；比如，借助此工具可以再添加一个边框；</p>

<pre><code>// 修改res/drawable/button_beat_box_pressed.xml，
&lt;layer-list xmlns:app=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item&gt;
        &lt;shape app:shape=&quot;oval&quot;&gt;
            &lt;solid app:color=&quot;@color/red&quot;/&gt;
        &lt;/shape&gt;
    &lt;/item&gt;

    &lt;item&gt;
        &lt;shape app:shape=&quot;oval&quot;&gt;
            &lt;stroke app:width=&quot;4dp&quot; app:color=&quot;@color/dark_red&quot;/&gt;
        &lt;/shape&gt;
    &lt;/item&gt;
&lt;/layer-list&gt;
</code></pre></li>
</ul>

<h4 id="toc_35">23.6 深入学习：使用mipmap图像</h4>

<ul>
<li><p>drawable子目录下的drawable-mdpi、drawable-hdpi等目录针对不同屏幕使用不同的图片；对于确定的屏幕来说，其中一些目录下的图片从来就不会被用到；为了解决此问题，可以针对设备定制APK，如mdpi APK、hdpi APK；</p></li>
<li><p>但是针对设备定制APK在某种情况下，需要包含所有分辨率的图片（比如应用启动图标），这时可以将这些图片放在mipmap子目录中，此时mipmap子目录中的资源会被全部打包到APK文件中；建议把应用启动器图标放在mipmap子目录中，其他图片都放在drawable子目录中；</p></li>
</ul>

<h4 id="toc_36">23.7 深入学习：使用9-patch图像</h4>

<ul>
<li><p>9-patch图像是一种特别处理过的文件，其能够让Android知道图像的哪些部分可以拉伸，哪些部分不可以拉伸；</p></li>
<li><p>9-patch图像分成3X3的网格，即有9部分或9 patch组成的网格；网格的角落部分不会被缩放，边缘部分的4个patch只按一个维度缩放，而中间部分则按两个维度缩放；</p></li>
<li><p>9-patch图像和普通PNG图像十分相似，只有两处不同：</p>

<ul>
<li>9-patch图像文件名以.9.png结尾；</li>
<li>图像边缘具有1像素宽度的边框，该边框用以指定9-patch图像的中间位置；</li>
</ul></li>
<li><p>将.png文件重命名为.9.png文件，打开9-patch工具即可创建修改9-patch图像；</p></li>
<li><p>把图像顶部、左边框填充为黑色，分别标记图像的水平方向、竖直方向的可拉伸区域；为让图片更醒目，可勾选上<code>Show patches</code>选项；</p></li>
<li><p>图像底部以及右边框定义了9-patch图像的可选的内容区；</p>

<ul>
<li>内容区是绘制内容（通常是文字）的地方；</li>
<li>若不标记内容区，则默认与可拉伸区域一样；</li>
<li>为让预览器高亮显示图片的文字显示区，可勾选上<code>Show content</code>选项；</li>
</ul></li>
</ul>

<h3 id="toc_37">第23章 深入学习intent和任务</h3>

<h4 id="toc_38">24.2 解析隐式intent</h4>

<ul>
<li><p>可以使用PackageManager获取所有<code>可启动主activity</code>；可启动主activity都带有包含MAIN操作和LAUNCHER类别的intent过滤器；</p>

<pre><code>&lt;intent-filter&gt;
  &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
  &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
&lt;/intent-filter&gt;
</code></pre>

<pre><code class="language-java">Intent startupIntent = new Intent(Intent.ACTION_MAIN);
startupIntent.addCategory(Intent.CATEGORY_LAUNCHER);

PackageManager pm = getActivity().getPackageManager();
List&lt;ResolveInfo&gt; activities = pm.queryIntentActivities(startupIntent, 0);
</code></pre></li>
<li><p><strong><code>MAIN/LAUNCHER intent过滤器</code>可能无法与<code>通过startActivity()方法发送的MAIN/LAUNCHER隐式intent</code>相匹配；</strong></p>

<ul>
<li><strong>startActivity()方法表示启动<code>匹配隐式intent的默认activity</code>，而不是启动<code>匹配隐式intent的activity</code>；</strong></li>
<li><strong>调用startActivity、startActivityForResult方法发送隐式intent时，操作系统会自动给该intent再添加Intent.CATEGORY_DEFAULT类别；</strong></li>
<li><strong>若希望<code>intent过滤器</code>匹配<code>startActivity()方法发送的隐式intent</code>，则必须在该intent过滤器上添加Intent.CATEGORY_DEFAULT类别；</strong></li>
</ul></li>
<li><p><strong>定义了<code>MAIN/LAUNCHER intent过滤器</code>的activity是应用的主要入口点，其只负责作为应用主要入口点要处理的工作，其通常不关心自己是否为默认的主要入口点，所以可以不包含CATEGORY_DEFAULT类别；</strong></p></li>
<li><p>在PackageManager返回的<code>ResolveInfo</code>对象中，可以获取activity标签和其他一些元数据，如resolveInfo.loadLabel()方法；</p>

<pre><code class="language-java">List&lt;ResolveInfo&gt; activities = pm.queryIntentActivities(startupIntent, 0);
Collections.sort(activities, new Comparator&lt;ResolveInfo&gt;() {
    @Override
    public int compare(ResolveInfo o1, ResolveInfo o2) {
        return String.CASE_INSENSITIVE_ORDER.compare(
                o1.loadLabel(pm).toString(),
                o2.loadLabel(pm).toString());
    }
});
</code></pre></li>
</ul>

<h4 id="toc_39">24.3 在运行时创建显式intent</h4>

<ul>
<li><p>要创建启动activity的显示intent，需要从ResolveInfo对象中获取activity的包名与类名，这些可从ResolveInfo对象的<code>ActivityInfo</code>对象中获取；</p></li>
<li><p><strong>之前创建显式Intent，使用<code>public Intent(Context packageContext, Class&lt;?&gt; cls)</code>方法；该方法会根据传入的参数获取Intent所需要的ComponentName（由包名和类名组成）；</strong></p></li>
<li><p><strong>也可以自己通过包名和类名创建ComponentName，然后使用<code>public Intent setComponent(ComponentName component)</code>方法创建显式intent；</strong></p></li>
<li><p><strong>也可以直接通过包名和类名使用<code>public Intent setClassName(String packageName, String className)</code>方法创建显式intent，省略创建ComponentName对象了；</strong></p>

<pre><code class="language-java">ActivityInfo activityInfo = mResolveInfo.activityInfo;

Intent i = new Intent(Intent.ACTION_MAIN)
        .setClassName(activityInfo.applicationInfo.packageName, activityInfo.name);
startActivity(i);
</code></pre></li>
</ul>

<h4 id="toc_40">24.4 任务与回退栈</h4>

<ul>
<li><p><strong>任务是一个activity栈；</strong>栈最底部的activity称为基activity，用户可以看到栈顶的activity；</p></li>
<li><p>点击后退键，栈顶的activity会弹出栈外；若当前屏幕上显示的就是基activity，则系统会回到主屏幕；</p></li>
<li><p><strong>默认情况下，新activity都会被添加到当前任务中，即使启动的activity不属于当前应用；</strong>在当前任务中启动activity的好处是，用户可以在任务内而不是应用层级间进行导航返回；</p></li>
<li><p>overview screen（最近任务列表）可以让我们在任务间切换；每个应用显示项就代表着一个应用任务；移除应用显示项就是清除任务，其会从应用回退栈中清除所有activity；</p></li>
<li><p>为了在启动新activity时启动新任务，需要为intent添加一个标志<code>Intent.FLAG_ACTIVITY_NEW_TASK</code>，该标志控制每个activity仅创建一个任务（若任务不存在则新建，若任务存在则切换到原来的任务）；</p>

<pre><code class="language-java">ActivityInfo activityInfo = mResolveInfo.activityInfo;

Intent i = new Intent(Intent.ACTION_MAIN)
        .setClassName(activityInfo.applicationInfo.packageName, activityInfo.name)
        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
startActivity(i);
</code></pre></li>
</ul>

<h4 id="toc_41">24.5 使用NerdLauncher应用作为设备主屏幕</h4>

<ul>
<li><p><strong>给activity的拦截器添加HOME、DEFAULT类别，可以让该activity成为可选的桌面；</strong>恢复成系统默认桌面，需要打开Settings进行修改；</p>

<pre><code>&lt;intent-filter&gt;
    &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; 

    &lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt;
    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
&lt;/intent-filter&gt;
</code></pre></li>
</ul>

<h4 id="toc_42">24.7 深入学习：进程与任务</h4>

<ul>
<li><p>对象需要内存和虚拟机的支持才能生存；</p></li>
<li><p><code>进程</code>是操作系统创建的、供应用对象生存以及应用运行的地方；</p>

<ul>
<li>进程通常会占用由操作系统管理着的系统资源（如内存等），其还拥有至少一个(可能多个）线程；</li>
<li><strong>在Android系统中，每个应用组件（如activity等）都仅与一个进程相关联；</strong></li>
<li><strong>一般情况下，应用伴随着自己的进程一起完成创建，该进程同时也是应用中所有组件的默认进程；</strong></li>
</ul></li>
<li><p><strong>每个activity实例仅与一个<code>任务</code>关联，这时进程与任务的唯一相似之处；</strong></p></li>
<li><p><strong>进程则包含了应用的全部运行代码和对象；任务只包含activity，这些activity通常来自于<code>不同的应用进程</code>；</strong></p></li>
<li><p><strong>打开CriminalIntent应用选择目标联系人，进程、任务示意图：</strong></p>

<p><img src="media/15237039848080/progress_task_01.png" alt="progress_task_01" style="width:327px;"/></p>

<ul>
<li><strong>此时按后退键在不同activity间切换，其实是在进程间切换；</strong></li>
</ul></li>
<li><p><strong>打开CriminalIntent应用选择目标联系人，按Home键启动联系人应用，进程、任务示意图：</strong></p>

<p><img src="media/15237039848080/progress_task_02.png" alt="progress_task_02" style="width:316px;"/></p></li>
<li><p><strong>那些自称为任务终止器的应用，实际上都是进程终止器；</strong></p></li>
</ul>

<h4 id="toc_43">24.8 深入学习：并发文档</h4>

<ul>
<li><p><strong>在Lollipop设备上，对于以<code>android.intent.action.SEND</code>、<code>action.intent.action.SEND_ MULTIPLE</code>启动的activity，隐式intent选择器会创建独立的新任务（之前的系统不是这样的，将其添加到当前应用的任务栈中）；这是因为Lollipop中有<code>并发文档（concurrent documents）</code>的概念；</strong></p></li>
<li><p><strong>有了并发文档，就可以在应用运行时动态创建任意数目的任务；在Lollipop之前，应用任务只能预先定义好，并且还要在manifest文件中明确指定；</strong></p></li>
<li><p>Google Drive应用就是并发文档的最好实例，用户可以用它打开并编辑多份文档，这些文档编辑activity都处在独立的任务中；</p></li>
<li><p>在Lollipop设备上，若需要启动多个任务，可以采用两种方式：</p>

<ul>
<li><strong>a. 给intent加上<code>Intent. FLAG_ACTIVITY_NEW_DOCUMENT</code>标志，再调用startActivity()方法；</strong></li>
<li><p><strong>b. 在manifest文件中，为activity设置<code>documentLaunchMode</code>为<code>intoExisting</code>；</strong></p>

<pre><code>&lt;activity
    android:name=&quot;.CrimePagerActivity&quot;
    android:label=&quot;@string/app_name&quot;
    android:parentActivityName=&quot;.CrimeListActivity&quot;
    android:documentLaunchMode=&quot;intoExisting&quot; /&gt;
</code></pre></li>
</ul></li>
<li><p>使用上述方法，一份文档只会对应一个任务，若已存（发送带有和已存在任务相同数据的intent）在就不再新建任务；若无论如何都新建任务，就给intent打上<code>Intent.FLAG_ACTIVITY_NEW_DOCUMENT</code>和<code>Intent.FLAG_ACTIVITY_MULTIPLE_TASK</code>标志、或者修改manifest中的<code>documentLaunchMode</code>为<code>always</code>；</p></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android编程权威指南 笔记(13~18)]]></title>
    <link href="http://www.justisit.com/15230916186418.html"/>
    <updated>2018-04-07T17:00:18+08:00</updated>
    <id>http://www.justisit.com/15230916186418.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">第13章 工具栏</a>
<ul>
<li>
<a href="#toc_1">13.1 AppCompat</a>
</li>
<li>
<a href="#toc_2">13.2 工具栏菜单</a>
</li>
<li>
<a href="#toc_3">13.3 实现层级式导航</a>
</li>
<li>
<a href="#toc_4">13.4 可选菜单项</a>
</li>
<li>
<a href="#toc_5">13.5 深入学习：工具栏和操作栏</a>
</li>
<li>
<a href="#toc_6">13.6、13.7 调整练习：删除crime记录、复数字符串资源</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">第14章 SQLite数据库</a>
<ul>
<li>
<a href="#toc_8">14.0 概述</a>
</li>
<li>
<a href="#toc_9">14.1 定义schema</a>
</li>
<li>
<a href="#toc_10">14.2 创建初始数据库</a>
</li>
<li>
<a href="#toc_11">14.4 写入数据库</a>
</li>
<li>
<a href="#toc_12">14.5 读取数据库</a>
</li>
<li>
<a href="#toc_13">14.7 深入学习：应用上下文</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">第15章 隐式Intent</a>
<ul>
<li>
<a href="#toc_15">15.0 概述</a>
</li>
<li>
<a href="#toc_16">15.4 使用隐式intent</a>
</li>
<li>
<a href="#toc_17">15.5 挑战练习：ShareCompat</a>
</li>
</ul>
</li>
<li>
<a href="#toc_18">第16章 使用intent拍照</a>
<ul>
<li>
<a href="#toc_19">16.2 文件存储</a>
</li>
<li>
<a href="#toc_20">16.3 使用相机intent</a>
</li>
<li>
<a href="#toc_21">16.4 缩放和显示位图</a>
</li>
<li>
<a href="#toc_22">16.5 功能声明</a>
</li>
</ul>
</li>
<li>
<a href="#toc_23">第17章 双版面主从用户界面</a>
<ul>
<li>
<a href="#toc_24">17.1 增加布局灵活性</a>
</li>
<li>
<a href="#toc_25">17.2 activity：fragment的托管者</a>
</li>
<li>
<a href="#toc_26">17.3 深入学习：设备屏幕尺寸的确定</a>
</li>
</ul>
</li>
<li>
<a href="#toc_27">第18章 应用本地化</a>
<ul>
<li>
<a href="#toc_28">18.1 资源本地化</a>
</li>
<li>
<a href="#toc_29">18.2 配置修饰符</a>
</li>
</ul>
</li>
</ul>


<span id="more"></span><!-- more -->

<h3 id="toc_0">第13章 工具栏</h3>

<h4 id="toc_1">13.1 AppCompat</h4>

<ul>
<li><p><strong><code>工具栏</code>可以安置菜单选项、提供应用导航；Android 5.0（Lollipop）引入了工具栏，在Lollipop之前用于导航、提供菜单操作的是<code>操作栏</code>， 工具栏和操作栏有些类似，其基于操作栏进化而来，界面更美观，使用更方便；</strong></p></li>
<li><p>为了兼容低版本系统，Google将工具栏集成到AppCompat库中；</p></li>
<li><p><strong>使用AppCompat库需要进行以下三步：添加AppCompat库、使用一种AppCompat主题、确保所有的activity都是AppCompatActivity子类；现在Android Studio新建项目都会默认使用该库；</strong></p></li>
<li><p>AppCompat库自带三种主题：Theme.AppCompat（黑色主题）、Theme.AppCompat.Light（浅色主题）、Theme.AppCompat.Light.DarkActionBar（带黑色工具栏的浅色主题）；</p></li>
<li><p>主题可以给应用配置，也可以给activity配置，都是配置在AndroidManifest.xml文件中；主题定义在res/values/styles.xml文件中，若在多个版本的style.xml文件中定义了相同名称的主题，则是为了适配不同设备系统；</p></li>
<li><p>为了让我们自定义的Activity都继承AppCompatActivity，并且同时支持fragment，Google让AppCompatActivity继承于FragmentActivity；</p></li>
</ul>

<h4 id="toc_2">13.2 工具栏菜单</h4>

<ul>
<li><p>工具栏菜单由菜单项（操作项）组成，位于工具栏的右上方；</p></li>
<li><p><strong>菜单是一种类似于布局的资源文件，定义在res/menu目录下，Android会自动生成相应的资源ID（实例化菜单时使用）；右击res目录，New -&gt; <code>Android resource file</code>，<code>Resource type</code>选择 <code>Menu类型</code> 即定义创建XML菜单文件；</strong></p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
      xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;
    &lt;item
        android:id=&quot;@+id/menu_item_new_crime&quot;
        android:icon=&quot;@android:drawable/ic_menu_add&quot;
        android:title=&quot;@string/new_crime&quot;
        app:showAsAction=&quot;ifRoom|withText&quot;/&gt;
&lt;/menu&gt;
</code></pre>

<ul>
<li><p>app:showAsAction属性指示菜单项是显示在工具栏上，还是隐藏于<code>溢出菜单(overflow menu，三个小点)</code>；该属性取值有：</p>

<ul>
<li>a. always：总是显示在工具栏上；</li>
<li>b. never：总是隐藏于溢出菜单；</li>
<li>c. ifRoom：有空间则显示在工具栏上；</li>
<li>withText：让title和icon一起显示出来（但是不一定）；</li>
</ul></li>
<li><p>组合值<code>ifRoom|withText</code>：a. 若有足够大的空间则菜单项的图标和标题都显示在工具栏上；b. 若有图标大小范围的空间则仅显示图标，标题不显示（若长按图标提示出标题）；c. 若空间不能够显示任何项，则整个菜单隐藏于溢出菜单；</p></li>
<li><p>出于兼容性考虑，AppCompat库需要使用app命名空间；由于早期的AppCompat库使用了该属性用在了操作栏（工具栏的前身）中；</p></li>
</ul></li>
<li><p>应用使用的图标有两种：系统图标（使用@android:drawable/XXX引用）、项目资源图标；建议不要使用系统图标，因为不同的系统的系统图标的显示风格差异比较大；</p></li>
<li><p>项目资源图标的来源有三种方案：定制图标、将系统图标拷贝到项目中、使用Android Studio内置的<code>Android Asset Studio</code>工具定制（右击drawable目录，选择New -&gt; Image Asset，Asset Type选择<code>Action Bar and Tab Icons</code>进行定制）；</p></li>
<li><p>Activity提供了管理菜单的相关回调方法；需要选项菜单时，Android会调用activity的onCreateOptionsMenu(Menu)方法；</p></li>
<li><p><strong>在fragment中使用选项菜单时，有以下管理菜单的相关回调方法：</strong></p>

<ul>
<li><strong><code>public void onCreateOptionsMenu(Menu menu, MenuInflater inflater)</code>：创建菜单，由FragmentManager来调用；在此函数中执行inflater.inflate(R.menu.fragment_crime_list, menu)将定义的XML菜单填充到Menu实例中；</strong></li>
<li><strong><code>public void setHasOptionsMenu(boolean hasMenu)</code>：在fragment的onCreate()方法中调用该方法，指明该fragment是否需要接收管理菜单的相关回调方法（onCreateOptionsMenu方法）；需要菜单则调用setHasOptionsMenu(true);</strong></li>
</ul></li>
<li><p><strong>用户点击菜单中的菜单项时，fragment会收到<code>onOptionsItemSelected(MenuItem)</code>方法的回调请求，传入该方法的参数是一个描述用户选择的MenuItem实例，返回值为布尔值表示相应的响应是否已经完成；在该方法可以通过检查菜单项ID确定被选中的是哪个菜单项，进而做出相应的响应；</strong></p></li>
</ul>

<h4 id="toc_3">13.3 实现层级式导航</h4>

<ul>
<li><p><strong><code>后退键导航</code>又称为临时性导航，只能返回到上一次浏览过的用户界面；而<code>层级式导航</code>（hierarchical navigation，又称为ancestral navigation）可在应用内逐级向上导航；有了层级式导航，用户可点击工具栏左边的向上按钮向上导航；</strong></p></li>
<li><p>从Android 4.1（API 16）开始，在AndroidManifest.xml中，给相关的activity添加parentActivityName属性就开启层级式导航；</p>

<pre><code>&lt;activity android:name=&quot;.CrimePagerActivity&quot; android:parentActivityName=&quot;.CrimeListActivity&quot;&gt;
&lt;/activity&gt;
</code></pre></li>
<li><p>层级式导航的工作原理（和点击后退键不同）：当用户点击工具栏的向上按钮时，会执行以下操作：</p>

<pre><code class="language-java">Intent intent = new Intent(this, CrimeListActivity.class);
intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
startActivity(intent);
finish();
</code></pre>

<ul>
<li><code>FLAG_ACTIVITY_CLEAR_TOP</code>：表示Android在回退栈中寻找指定的activity实例，若存在则弹出栈内所有其他activity，让启动的目标activity出现在栈顶（显示在屏幕上）；</li>
</ul></li>
</ul>

<h4 id="toc_4">13.4 可选菜单项</h4>

<ul>
<li><p><code>getString(int resId, Object...formatArgs)</code>方法接受字符串资源中占位符的替换值；格式<code>%[index]$[type]</code>：index表示替换资源中第index个资源对应的位置，type表示所要替换的资源的类型（d为整型格式，s为字符串格式）；</p>

<pre><code class="language-java">&lt;string name=&quot;subtitle_format&quot;&gt;%1$d crimes&lt;/string&gt;

String subtitle = getString(R.string.subtitle_format, crimeCount);
</code></pre></li>
<li><p><code>((AppCompatActivity) activity).getSupportActionBar().setSubtitle(subtitle)</code>设置工具栏子标题（在工具栏的左侧主标题的下面）；由于兼容性问题，在AppCompat库中工具栏在很多地方仍被称为操作栏；</p></li>
<li><p><strong>调用<code>getActivity().invalidateOptionsMenu();</code>主动重建工具栏；</strong></p></li>
<li><p><strong><code>按向上按钮</code>和<code>按返回键</code>是有区别的；按向上按钮回退到的目标activity会被完全重建，故其中的实例变量值会丢失；解决方案有两种（但都不太理想）：覆盖向上导航的机制、父子控制器传递数据（子activity覆盖getParentActivityIntent()方法，用附带了extra信息的intent重建父activity）；</strong></p></li>
<li><p><strong>设备旋转也会导致重建工具栏，可以通过onSaveInstanceState()方法实例状态保存机制解决工具栏状态的问题；</strong></p></li>
</ul>

<h4 id="toc_5">13.5 深入学习：工具栏和操作栏</h4>

<ul>
<li><p>操作栏的使用限制多，整个应用只能配置一个操作栏且位置及尺寸必须固定（在屏幕顶部）；</p></li>
<li><p>工具栏的左边不再放置图标，右边菜单项的间距也更小；工具栏更灵活，没有上述限制；，其可以在同一屏配置多个，并且可以在任意位置摆放，尺寸可以定制；让每个fragment都有自己的工具栏，这比所有fragment共享一个位于屏幕顶部的工具栏方便多；</p>

<p><img src="media/15230916186418/toolbar.png" alt="toolbar" style="width:370px;"/></p></li>
</ul>

<h4 id="toc_6">13.6、13.7 调整练习：删除crime记录、复数字符串资源</h4>

<ul>
<li><p>添加击删除菜单项，用户点后要调用子fragment的finish()方法回退到前一个activity界面；</p></li>
<li><p>复数字符串资源（又称为量化字符串）：</p>

<pre><code class="language-java">// 在strings.xml文件中定义复数字符串资源
&lt;plurals name=&quot;subtitle_plural&quot;&gt;
    &lt;item quantity=&quot;one&quot;&gt;%1$d crime&lt;/item&gt;
    &lt;item quantity=&quot;other&quot;&gt;%1$d crimes&lt;/item&gt;
&lt;/plurals&gt;

// 使用getQuantityString方法正确处理单复数问题
int crimeSize = crimeLab.getCrimes().size();
String subtitle = getResources()
        .getQuantityString(R.plurals.subtitle_plural, crimeSize, crimeSize);
</code></pre></li>
</ul>

<h3 id="toc_7">第14章 SQLite数据库</h3>

<h4 id="toc_8">14.0 概述</h4>

<ul>
<li>Android设备上的每个应用都有一个独立的沙盒目录；将文件保存在沙盒中可阻止其他应用甚至设备用户的访问；若设备被root就可以随意访问各种目录和文件了；应用的沙盒目录是<code>/data/data/[your package name]/</code>；</li>
</ul>

<h4 id="toc_9">14.1 定义schema</h4>

<ul>
<li><p>为了复用代码和简单（不用书写太多的sql语句），可以使用ORM（对象关系映射）；但在这里先不使用ORM，直接在Java代码中定义database schema（描述表名和数据字段）；</p></li>
<li><p>以内部类的方式定义组织database schema，该类中描述定义表名、字段名的String常量，可用于sql语句的拼接、ContentValue中的键；</p>

<pre><code class="language-java">public class XXDbSchema {
    public static final class YYTable {
        public static final String NAME = &quot;aa&quot;;
        public static final class Cols {
            public static final String UUID = &quot;uuid&quot;;
            public static final String TITLE = &quot;title&quot;;
        }
    }

    public static final class ZZTable {
        public static final String NAME = &quot;bb&quot;;
        public static final class Cols {
            public static final String UUID = &quot;uuid&quot;;
            public static final String TITLE = &quot;name&quot;;
        }
    }
}
</code></pre></li>
</ul>

<h4 id="toc_10">14.2 创建初始数据库</h4>

<ul>
<li><p>有了database schema就可以创建数据库了；<code>openOrCreateDatabase()</code>、<code>databaseList()</code>是Android提供的Context底层方法，用来打开数据库文件并将其转换为<code>SQLiteDatabase</code>实例；</p></li>
<li><p>在实践中，建议使用数据库应遵循以下步骤：</p>

<ul>
<li>1) 确认目标数据库是否存在；</li>
<li>2) 若不存在则先创建数据库，然后创建数据表并初始化数据；</li>
<li>3) 若存在则打开并确认database schema是否为最新的；</li>
<li>4) 若schema是旧版本，则先升级到最新版本；</li>
</ul></li>
<li><p><strong>以上工作可借助Android的<code>SQLiteOpenHelper</code>类处理；使用该类打开SQLiteDatabase的繁杂工作就简单多了；</strong></p></li>
<li><p><strong>具体操作就是创建XXDateBaseHelper类继承于SQLiteOpenHelper，构造方法需要传入context对象、数据库文件名、数据库版本号参数，重写onCreate（首次创建数据库调用）、onUpgrade（XXDateBaseHelper中的版本高时，升级数据库调用），并在这些方法中执行执行相关sql语句操作</strong>；</p></li>
<li><p><strong>调用sqliteOpenHelper的<code>getWritableDatabase()</code>方法获取<code>SQLiteDatabase</code>对象，并且会自动判断是否需要调用自身的onCreate、onUpgrade方法；之后可以使用该对象执行增删改查操作；</strong></p></li>
<li><p>SQLite数据库创建表字段时，可以不指定表字段数据类型；</p></li>
<li><p>数据库文件保存在<code>/data/data/[your package name]/databases/</code>中；</p></li>
</ul>

<h4 id="toc_11">14.4 写入数据库</h4>

<ul>
<li><p><strong>可以调用sqliteDatabase的<code>execSQL()</code>方法直接执行sql语句完成相关操作，需要书写sql语句，也可以使用封装好的insert、update等方法；</strong></p></li>
<li><p>负责处理数据库写入和更新操作的辅助类是<code>ContentValues</code>，其是一个键值存储类，类似于之前的Bundle；ContentValues的键就是数据表的字段名，值为数据表的字段值；</p></li>
<li><p>sqliteDatabase的<code>insert(String, String, ContentValues)</code>方法：</p>

<ul>
<li>用于插入记录，参数依次为数据库表名、nullColumnHack、ContentValues；</li>
<li>nullColumnHack用于处理ContentValues空值的情况；正常情况下，若ContentValues空值则insert()方法调用失败；此时若设置nullColumnHack为某个字段名，则可以插入一条该字段值为null的记录；</li>
<li>一般情况下，nullColumnHack传入null；</li>
</ul></li>
<li><p>sqliteDatabase的<code>update(String, ContentValues, String, String[])</code>方法：</p>

<ul>
<li>用于更新记录，参数与insert的类似；</li>
<li>第三个参数为创建where子句，第四个参数String[]为where子句的参数值；比如<code>update(CrimeTable.NAME, values, &quot;uuid = ?&quot;, new String[]{ uuidString })；</code></li>
<li>使用where参数形式而不是直接拼接where参数到sql语句中：可以防止SQL注入，使用where参数形式，会格式化传入的参数字符串；</li>
</ul></li>
</ul>

<h4 id="toc_12">14.5 读取数据库</h4>

<ul>
<li><p>sqliteDatabase的<code>public Cursor query(String table, String[] columns, tring where, String[] whereArgs, String groupBy, String having, String orderBy, String limit)</code>方法：</p>

<ul>
<li>用于查询记录，不需要的参数传入null即可；</li>
<li>该方法返回一个Cursor对象（游标），可以通过该对象获取某条记录的某个字段的值，比如<code>cursor.getString(cursor.getColumnIndex(CrimeTable.Cols.UUID));</code>；</li>
</ul></li>
<li><p><strong>通过遍历cursor取出需要字段的值构造模型对象；为了复用代码，可以将cursor到模型对象的转换过程封装起来；</strong></p>

<ul>
<li><strong>可以直接定义使用一个转换方法，也可以定义一个Cursor子类，并添加转换方法，使用时直接通过cursor获取模型对象；</strong></li>
<li><strong>Cursor是接口，系统提供实现了默认实现Cursor的CursorWrapper类；创建定义Cursor子类继承CursorWrapper类最简单；</strong></li>
</ul>

<pre><code class="language-java">try {
    cursor.moveToFirst(); // 将游标移到第一条记录位置
    while (!cursor.isAfterLast()) { // 判断当前游标是否是在最后的数据的之后（没有数据）
        crimes.add(cursor.getCrime());
        cursor.moveToNext(); // 将游标移到下一条记录位置
    }
} finally {
    cursor.close(); // 关闭游标（一定）
}
</code></pre></li>
<li><p><strong>之前使用单例提供数据，RecyclerView可以直接刷新数据（notifyDataSetChanged()）；现在使用数据库提供数据，RecyclerView的的mAdapter需要<code>重新设置数据</code>才能刷新数据；</strong></p></li>
</ul>

<h4 id="toc_13">14.7 深入学习：应用上下文</h4>

<ul>
<li><strong>在使用单例、数据库时，需要使用context对象的地方需要不能直接传入activity（context），而应该是application（<code>context.getApplicationContext()</code>）；因为在不同页面间进行导航，activity可能会被销毁而application对象不会被销毁；</strong></li>
</ul>

<h3 id="toc_14">第15章 隐式Intent</h3>

<h4 id="toc_15">15.0 概述</h4>

<ul>
<li><p>Intent对象用来向操作系统说明需要处理的任务；</p></li>
<li><p><strong>在Android系统中，可以利用<code>隐式intent</code>启动其他应用的activity；</strong></p>

<ul>
<li><strong>只需要描述要完成的任务，操作系统会找到合适的应用并启动相应的activity；</strong></li>
<li><strong>若找到多个符合的activity，会提供一个可选应用列表供用户选择；</strong></li>
<li><strong>使用隐式intent可以利用其他应用完成常见任务；</strong></li>
</ul></li>
<li><p><strong>在<code>显式intent</code>中，需要指定要启动的activity类，之后操作系统会负责启动它；</strong></p></li>
</ul>

<h4 id="toc_16">15.4 使用隐式intent</h4>

<ul>
<li><p>隐式intent的主要组成部分：</p>

<ul>
<li><strong>a. 要执行的操作</strong>

<ul>
<li>通常以Intent类中的常量表示；比如，要访问URL使用Intent.ACTION_VIEW，要发邮件使用Intent.ACTION_SEND；</li>
</ul></li>
<li><strong>b. 要访问数据的位置</strong>

<ul>
<li>可能是设备之外的资源，比如网页URL、某个文件URI，或ContentProvider中某条记录的某个内容URI（content URI）；</li>
</ul></li>
<li><strong>c. 操作涉及的数据的类型（MIME形式）</strong>

<ul>
<li>比如text/html、audio/mpeg3；</li>
<li>若一个intent包含数据的位置，通常可以从中推测出数据的类型；</li>
</ul></li>
<li><strong>d. 可选的类别</strong>

<ul>
<li><strong><code>操作</code>用于描述具体做什么，而<code>类别</code>通常用来描述何时何地或者如何使用某个activity；</strong></li>
<li>比如，Android的<code>android.intent.category.LAUNCHER类别</code>表明activity应该显示在顶级应用启动器中，<code>android.intent.category.INFO类别</code>表明activity向用户显示了包信息，但其不应该出现在启动器中；</li>
</ul></li>
</ul></li>
<li><p><strong>一个查看某个网址的简单隐式intent会包括一个Intent.ACTION_VIEW操作，以及某个具体URL网址；</strong></p></li>
<li><p><strong>让某个activity对外宣称可以处理某些操作，需要在AndroidManifest.xml文件中给该activity配置intent-filter子标签；</strong>比如，处理打开URL的操作：</p>

<pre><code>&lt;activityandroid:name=&quot;.BrowserActivity&quot; &gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
        &lt;data android:scheme=&quot;http&quot; android:host=&quot;www.bignerdranch.com&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>

<ul>
<li><strong>action：告诉操作系统，该activity能够胜任指定任务；</strong></li>
<li><strong>category：可选的类别；但必须明确声明一下<code>DEFAULT类别</code>告诉操作系统，该activity愿意处理该任务；绝大多数的隐式intent都隐含有DEFAULT类别；</strong></li>
</ul></li>
<li><p><strong>隐式intent也可以包含extra信息，但是操作系统在寻找合适的activity时是不会使用该信息的；</strong></p></li>
<li><p><strong>显式intent也可以使用<code>隐式intent的操作和数据部分</code>，这相当于要求特定activity去处理特定任务；</strong></p></li>
<li><p>隐式intent（发送消息）：</p>

<pre><code class="language-java">Intent i = new Intent(Intent.ACTION_SEND);
i.setType(&quot;text/plain&quot;);
i.putExtra(Intent.EXTRA_TEXT, getCrimeReport());
i.putExtra(Intent.EXTRA_SUBJECT, getString(R.string.crime_report_subject));
startActivity(i);
</code></pre>

<ul>
<li><strong>传入的是一个定义操作的常量创建的隐式intent类别；还有一些其他形式的构造方法可用，这取决于要创建的隐式intent的类别；</strong></li>
<li><strong><code>Intent.EXTRA_TEXT</code>、<code>Intent.EXTRA_SUBJECT</code>指定附加在intent的extra上的消息的内容、主题；这些key是Intent类中定义的常量，因此任何响应该intent的activity都知道如何使用这些常量所对应的值；</strong></li>
</ul></li>
<li><p>若响应隐式intent时没有出现activity列表，可能是该设备上仅有一个activity可以响应，也有可能是用户针对该隐式intent设置了<code>默认响应应用</code>；</p></li>
<li><p><strong>让用户的默认响应应用的设置无效，每次都是显示activity列表，可以调用Intent的<code>public static Intent createChooser(Intent target, String title)</code>方法，传入之前创建的隐式intent、选择器标题，包装返回一个新的隐式intent，之后再调用startActivity()即可；</strong></p></li>
<li><p><strong>从联系人应用中选择获取联系人信息，该隐式intent由操作以及数据获取位置组成，操作为Intent.ACTION_PICK，数据获取位置为ContactsContract.Contacts.CONTENT_URI；</strong></p></li>
<li><p><strong>与显式intent一样，隐式Intent若获取启动activity的返回结果，需要调用startActivityForResult()方法并传入该隐式intent、请求码，之后再在onActivityResult()方法中接收数据；</strong></p></li>
<li><p><strong>很多应用都会共享联系人信息，因此Android提供了一个深度定制的ContentProvider类用于处理联系人信息，该类实际上是对联系人的数据库的操作封装，屏蔽了数据库的内部结构，但是其也有query、Cursor等概念操作；</strong></p></li>
<li><p><strong>上面以ACTION_PICK操作启动activity并要求返回结果，会在调onActivityResult()方法中接收到一个intent；该intent包括了数据URI（一个数据定位符，指向用户所选的联系人），可以使用ContentProvider类完成对联系人URI的访问，从而获取到实际的联系人数据；</strong></p>

<pre><code class="language-java">Uri contactUri = data.getData();
String[] queryFields = new String[]{ ContactsContract.Contacts.DISPLAY_NAME };
Cursor c = getActivity().getContentResolver().query(contactUri, queryFields, null, null, null);

try {
    if (c.getCount() == 0) {
        return;
    }
    c.moveToFirst();
    String suspect = c.getString(0);
    mCrime.setSuspect(suspect);
    mSuspectButton.setText(suspect);
} finally {
    c.close();
}
</code></pre></li>
<li><p><strong>由于使用<code>联系人应用</code>获取联系人的URI，<code>联系人应用</code>又有使用联系人数据库的全部权限，<code>联系人应用</code>会给返回intent中的URI数据添加<code>Intent.FLAG_GRANT_READ_URI_PERMISSION标志</code>（表示原activity可以获取使用联系人数据一次），故原activity不需要主动声明读取联系人数据库的权限；</strong></p></li>
<li><p><strong>操作系统响应隐式intent时，若没有找到匹配的activity则应用会崩溃；解决办法是使用<code>PackageManager</code>类可以自检；</strong></p>

<pre><code>PackageManager packageManager = getActivity().getPackageManager();
if (packageManager.resolveActivity(pickContactIntent, PackageManager.MATCH_DEFAULT_ONLY) == null) {
    // 无合适的activity
}
</code></pre>

<ul>
<li><strong>Android设备上安装了哪些组件以及包括哪些activity，PackageManager类全都知道；</strong></li>
<li><strong>调用resolveActivity(Intent, int)方法，查找匹配给定Intent任务的activity；flag标志MATCH_DEFAULT_ONLY限定只搜索带CATEGORY_DEFAULT标志的activity；</strong></li>
</ul></li>
</ul>

<h4 id="toc_17">15.5 挑战练习：ShareCompat</h4>

<ul>
<li>Android支持库有个ShareCompat的类，其有一个内部类 IntentBuilder，使用该内部类创建发送消息的Intent略微方便一些；</li>
</ul>

<h3 id="toc_18">第16章 使用intent拍照</h3>

<h4 id="toc_19">16.2 文件存储</h4>

<ul>
<li><p><strong>内部存储</strong></p>

<ul>
<li><p><strong>沙盒目录存储在<code>/data/data/&lt;packageName&gt;/</code>，仅供应用内部访问，使用context的以下方法进行访问；</strong></p>

<ul>
<li><p><strong><code>File getDir(String name, int mode)</code>：获取/data/data/<packageName>/中的子目录，需要传入子目录名称，不存在则创建；</strong></p></li>
<li><p><strong><code>File getCacheDir()</code>：获取/data/data/<packageName>/cache目录，注意及时清理该目录；</strong></p></li>
<li><p><strong><code>File getFilesDir()</code>：获取/data/data/<packageName>/files目录；</strong></p></li>
<li><p><strong><code>String[] fileList()</code>：获取/data/data/<packageName>/files目录下的文件列表；之后可与其他方法配合使用，如openFileInput(String)；</strong></p></li>
<li><p><strong><code>FileInputStream openFileInput(String name)</code>： 打开现有文件进行读取；</strong></p></li>
<li><p><strong><code>FileOutputStream openFileOutput(String name, int mode)</code>：打开文件进行写入，若不存在则创建；</strong></p></li>
</ul></li>
</ul></li>
<li><p><strong>若要共享文件给其他应用，或接受其他应用的文件有以下途径：</strong></p>

<ul>
<li><strong>a. openFileOutput(String name, int mode)方法：❎</strong>

<ul>
<li><strong>mode设置为Context.MODE_WORLD_READABLE，但该mode早已废弃，即使强制使用也是无效的；</strong></li>
</ul></li>
<li>b. <strong>外部存储：❎</strong>

<ul>
<li><strong>出于安全考虑，从Android 7.0开始已经禁止方式；</strong></li>
<li><strong>Android 7.0禁止应用间通过<code>file:// URI</code>形式互访应用私有目录（主要是外部存储的；内部存储的默认就是无法访问的）</strong></li>
<li><strong>同时，Android 7.0 SDK的StrictMode禁止在应用外部公开<code>file:// URI</code>，外部存储中的公共目录也不可以；比如，在应用中使用包含 file:// URI的Intent离开当前应用时会发生Crash；</strong></li>
</ul></li>
<li>c. <strong>ContentProvider：✅</strong>

<ul>
<li><strong>ContentProvider允许我们将内容URL暴露给其他应用；</strong></li>
<li><strong>其他应用从内容URL下载或向其中写入文件，我们可以控制读或写；</strong></li>
</ul></li>
</ul></li>
<li><p><strong>外部存储：</strong></p>

<ul>
<li><strong>Android 2时代，手机内置的存储空间有限，可以使用<code>外置SD卡</code>作为存储空间；故此时的外部存储就是外置SD卡，内部存储就是手机内置的存储空间；</strong></li>
<li><strong>Android 4时代，手机厂商将之前<code>外置SD卡</code>内置到手机内部，此时的手机内置的存储空间包含两部分：内部存储和外部存储（更确切称为主外部存储），比如说手机存储空间为8G、16G、32G等都是包含这两部分的；</strong></li>
<li><strong>但是即使是Android 4时代，有些手机在内置了SD卡的同时，还支持<code>外置TF卡</code>，此时该外置存储被Google称为<code>其他各类存储</code>；但是Google对该类型的存储<code>没有提供直接的API支持</code>，而且其也不建议手机支持外置TF卡，也不允许有相关的访问操作；但是系统是开源的，有些系统厂商修改原始API行为进而支持访问外置TF卡；</strong></li>
<li><strong>为了从Android 2平滑过渡到Android 4，Google从Android 2提供访问外部存储的API的接口没有变化，虽然都是外部存储，但实现时访问的位置变了，之前外置SD卡，现在是内置的SD卡；比如<code>Environment.getExternalStorageDirectory()</code>方法这个Android 2时代遗留下的接口，现在返回的是<code>主外部存储</code>目录；</strong></li>
<li><strong>对于开发者来说，API还都是外部存储，只是存储设备的位置的变化，其他没有任何区别；<code>其他各类存储</code>对于文件管理类型的App有意义，但对于其他类型的APP没有太大意义；</strong></li>
</ul></li>
<li><p><strong>内部存储、外部存储比较</strong></p>

<ul>
<li><p><strong>内部存储</strong></p>

<ul>
<li><strong>a. 空间是有限的；</strong></li>
<li><strong>b. 该位置有每个应用的沙盒目录，其中有一些经常被访问到的文件，如Sqlite、SharedPreferences，也可以放置文件、缓存，但不建议存放；</strong></li>
<li><strong>c. 而且APP的安装文件存放于此，内部存储不足将导致无法安装新的APP；</strong></li>
</ul></li>
<li><p><strong>外部存储</strong></p>

<ul>
<li><strong>a. 所有的Android设备至少都有一个外部存储（而且建议就一个）；</strong></li>
<li>b. <strong>其中的文件目录可分为两种类型：一个是公共文件Public files、私有文件Private file；</strong></li>
<li><strong>c. Public file：比如Picturs（Camera应用生成的照片就存放于此）、Movies等常见九大目录；文件可以被自由访问，其他应用共享该文件；若应用被卸载但产生的数据（比如在外部存储的根目录下创建一个文件夹存储数据）不被删除；</strong></li>
<li><strong>d. Private files：位置在/Android/data/packageName&gt;/，就是应用存在于外部存储上的沙盒目录，可以放置应用的文件、缓存，若应用被卸载该目录也是一同被删除；在Android 7.0之前，虽然该目录是沙盒，但是由于是外部存储的原因，其他应用也是能访问的；</strong></li>
</ul></li>
</ul></li>
<li><p><strong>访问外部存储</strong></p>

<ul>
<li><p><strong>context也提供了一些访问外部存储的方法（都是访问特定应用沙盒目录下的）：</strong></p>

<ul>
<li><strong><code>File getExternalCacheDir()</code>：获取主外部存储上的cache目录；</strong></li>
<li><strong><code>File[] getExternalCacheDirs()</code>：获取多个外部存储上的cache目录（一般情况下就一个，可根据该方法判断手机是否有外置TF卡）；</strong></li>
<li><strong><code>File getExternalFilesDir(String)</code>：获取主外部存储上的文件目录；字符串可以可以传入Environment的DIRECTORY_前缀字符串常量，如Environment.DIRECTORY_ PICTURES；</strong></li>
<li><strong><code>File[] getExternalFilesDirs(String)</code>：获取多个外部存储上的文件目录；</strong></li>
<li><strong><code>File[] getExternalMediaDirs()</code>：获取主外部存储上的Android存储图片、视频、音乐文件的所有目录；</strong></li>
</ul></li>
<li><p><strong>注意：外部存储的Public file可以通过调用<code>Environment.getExternalStorageDirectory()</code>后拼接相关路径的方式去访问；</strong></p></li>
<li><p><strong>权限声明</strong></p>

<ul>
<li><p>为了安全控管，Android要求应用申请各类权限；比如读写外部存储需要获取相关权限，在manifest文件中声明uses-permission标签，比如</p>

<pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; android:maxSdkVersion=&quot;18&quot;/&gt;
</code></pre></li>
<li><p><strong>Android4.4(API19）放宽了一些权限管控的限制，比如context.getExternalFilesDir()返回的是该应用专用的文件目录，就没有必要再申请该目录的权限了使用其他的外部存储仍然需要）；</strong></p></li>
<li><p><strong>uses-permission的maxSdkVersion属性，表示适用API级别最大为18，大于该版本时不再声明相关权限（否则在API 19时，应用也能访问其他的外部存储）；</strong></p></li>
<li><p>通过其他应用访问相关目录，本应用不用申请权限；比如调用相机应用拍照存储，就不用再申请READ_EXTERNAL_STORAGE权限；</p></li>
</ul></li>
</ul></li>
<li><p><strong>FileProvider</strong></p>

<ul>
<li><strong>若应用间仅仅共享文件，自己实现ContentProvider比较麻烦，Google提供了FileProvider便利类，只要做做参数配置就成完成一切；</strong></li>
<li><p>使用步骤：</p>

<ul>
<li><p>a. 在AndroidManifes.xml中声明FileProvider为ContentProvider，并给与一个指定权限（这里为文件存储位置）；</p>

<pre><code>&lt;provider
android:name=&quot;android.support.v4.content.FileProvider&quot;
android:authorities=&quot;com.bignerdranch.android.criminalintent.fileprovider&quot;
android:exported=&quot;false&quot;
android:grantUriPermissions=&quot;true&quot;&gt;
&lt;/provider&gt;
</code></pre>

<ul>
<li><strong><code>exported = &quot;false&quot;</code>：表示除了自己以及自己给予授权的人，其他任何人都不允许使用该FileProvider；</strong></li>
<li><strong><code>grantUriPermissions=&quot;true&quot;</code>：给其他应用授权允许它们向你指定位置的URI写入文件；</strong></li>
</ul></li>
<li><p><strong>b. 使用一个XML资源文件配置FileProvider，告诉其应该暴露哪些文件；</strong></p>

<pre><code>&lt;paths&gt;
    &lt;files-path name=&quot;crime_photos&quot; path=&quot;.&quot;/&gt;
&lt;/paths&gt;   
</code></pre>

<ul>
<li>创建方式：右击app/res目录，选择New -&gt; Android resource file -&gt; 资源类型选XML；</li>
<li><strong>上述XML表示把<code>私有存储空间的根路径path=&quot;.&quot;</code>映射为crime_photos，这个名字仅是供FileProvider内部使用，没有意义；</strong></li>
<li><p><strong>在paths节点内部支持以下几个子节点：</strong></p>

<pre><code>&lt;files-path/&gt;：代表context.getFilesDir()
&lt;cache-path/&gt;：代表context.getCacheDir()
&lt;external-files-path/&gt;：代表context.getExternalFilesDirs()
&lt;external-cache-path/&gt;：代表getExternalCacheDirs()
&lt;root-path/&gt;：代表设备的根目录new File(&quot;/&quot;)
&lt;external-path/&gt;：代表Environment.getExternalStorageDirectory()
</code></pre></li>
</ul></li>
<li><p>c. <strong>给AndroidManifes.xml中的FileProvider添加<code>meta-data</code>标签，让FileProvider能找到文件；</strong></p>

<pre><code>&lt;provider
    ......&gt;
    &lt;meta-data
     android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;
     android:resource=&quot;@xml/files&quot;/&gt;
&lt;/provider&gt;
</code></pre></li>
<li><p><strong>d. 通过FileProvider的</strong>getUriForFile()<strong>方法生成ContentProvider形式的URI，之后就能使用了；</strong></p>

<pre><code class="language-java">Uri uri = FileProvider.getUriForFile(getActivity(),
&quot;com.bignerdranch.android.criminalintent.fileprovider&quot;, mPhotoFile);
captureImage.putExtra(MediaStore.EXTRA_OUTPUT, uri);
</code></pre></li>
</ul></li>
</ul></li>
</ul>

<h4 id="toc_20">16.3 使用相机intent</h4>

<ul>
<li><p>相机intent定义在MediaStore类中，该类负责处理所有与多媒体相关的任务，其定义了一些公共接口，可用于处理图像、视频、音乐等多媒体任务；发送一个带<code>MediaStore.ACTION_IMAGE_CAPTURE</code>操作的intent，Android会启动相机activity拍照；</p></li>
<li><p><strong>ACTION_CAPTURE_IMAGE打开相机应用，默认认只能拍摄低分辨率照片，照片会保存在onActivityResult()返回的Intent对象中；</strong></p></li>
<li><p><strong>若要获取全尺寸照片，需要使用文件系统进行存储照片；可以通过给intent设置键为MediaStore.EXTRA_OUTPUT，值为存储路径的uri的extra来完成；为适配Android 7.0，这里存储路径的uri为FileProvider提供的位置；</strong></p></li>
<li><p>拍照之前需要检测是否安装了相机应用，是否有地方存储照片；</p></li>
<li><p><strong>查询是否有activity可以匹配我们指定intent任务的三种方式：</strong></p>

<ul>
<li><strong>a. packageManager的resolveActivity()：返回获得最适合intent的一个activity，没有返回null；</strong></li>
<li><strong>b. intent的resolveActivity()： 同上，其内部调用了packageManager的resolveActivity()；</strong></li>
<li><strong>c. packageManager的queryIntentActivities()：会返回所有成功匹配intent的activity；</strong></li>
</ul></li>
<li><p><strong>调用<code>FileProvider.getUriForFile()</code>会把本地文件路径转换为相机能看见的URI形式（ContentProvider形式的URI）；</strong></p></li>
<li><p><strong>调用<code>context.grantUriPermission()</code>方法，传入<code>相机应用的activity信息</code>及<code>FLAG_GRANT_WRITE_URI_ PERMISSION</code>，给相机应用授予写入文件的权限，以此允许其在指定位置URI写文件（前提：声明FileProvider时要添加android:grantUriPermissions属性）；</strong></p>

<pre><code class="language-java">@Override
public void onClick(View v) {
    Uri uri = FileProvider.getUriForFile(getActivity(), fileProviderAuthorityStr, mPhotoFile);
    Log.e(TAG, &quot;file uri: &quot; + uri);
    captureImageIntent.putExtra(MediaStore.EXTRA_OUTPUT, uri);

    List&lt;ResolveInfo&gt; cameraActivities = packageManager.queryIntentActivities(captureImageIntent,
            PackageManager.MATCH_DEFAULT_ONLY);
    // 对所有的可拍照应用都授权，因为不确定用户选择了哪一个
    for (ResolveInfo activity: cameraActivities) {
        // 写入授权
        getActivity().grantUriPermission(activity.activityInfo.packageName, uri,
                Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
    }
    startActivityForResult(captureImageIntent, REQUEST_PHOTO);
}
</code></pre></li>
<li><p><strong>相机已保存了文件，需要关闭文件写入权限;</strong></p>

<pre><code class="language-java">} else if (requestCode == REQUEST_PHOTO) {
    Uri uri = FileProvider.getUriForFile(getActivity(), fileProviderAuthorityStr, mPhotoFile);
    // 对所有应用取消授权；（也有取消单个应用的授权的方法）
    getActivity().revokeUriPermission(uri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);

    updatePhotoView();
}
</code></pre></li>
</ul>

<h4 id="toc_21">16.4 缩放和显示位图</h4>

<ul>
<li><p><strong>若要从文件生成Bitmap对象需要使用BitmapFactory类；Bitmap是个简单对象，只存储实际像素数据；即使图片被压缩成小的jpg格式的文件，一旦被载入成Bitmap对象就会还原成最原始的空间大小；</strong></p>

<pre><code class="language-java">Bitmap bitmap = BitmapFactory.decodeFile(mPhotoFile.getPath());
</code></pre></li>
<li><p>借助BitmapFactory.Options类获取图片尺寸信息，之后可以手动缩放图片；</p>

<pre><code class="language-java">public static Bitmap getScaleBitmap(String path, int destWidth, int destHeight) {
    BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true; // 只解析图片尺寸信息

    float srcWidth = options.outWidth;
    float srcHeight = options.outHeight;

    // inSampleSize表示表示宽、高的缩放比例
    int inSampleSize = 1;
    if (srcHeight &gt; destHeight || srcWidth &gt; destWidth) {
        float heightScale = srcHeight / destHeight;
        float widthScale = srcWidth / destWidth;

        inSampleSize = Math.round(heightScale &gt; widthScale ? heightScale: widthScale);
    }

    options = new BitmapFactory.Options();
    options.inSampleSize = inSampleSize;

    return BitmapFactory.decodeFile(path, options);
}
</code></pre></li>
<li><p><strong>缩放图片需要根据<code>显示图片控件的尺寸</code>决定缩放比例，而只有显示在屏幕的视图才有大小尺寸；如何确定<code>显示图片控件的尺寸</code>的尺寸，有两种解决方案：等布局实例化完成并显示，或者使用一个保守估计值（极端情况下，<code>显示图片控件的尺寸</code>和屏幕尺寸一样大，可以按照此大小缩放图片）；</strong></p>

<pre><code class="language-java">Point size = new Point();
// 获取屏幕尺寸
activity.getWindowManager().getDefaultDisplay().getSize(size);
</code></pre></li>
</ul>

<h4 id="toc_22">16.5 功能声明</h4>

<ul>
<li><p><strong>若应用要使用诸如相机、NFC、或者其他的随设备相关的功能时，都应该让Android系统知道；这样，若设备缺少这样的功能时，类似Google Play商店的安装程序就会拒绝安装该应用；</strong></p></li>
<li><p><strong>在AndroidManifest.xml文件中声明uses-feature标签进行所需要的功能声明；默认情况下，缺少相关功能就无法使用该应用；添加required属性为false，则表示缺少相关功能也可以使用该应用；</strong></p>

<pre><code>&lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;false&quot;/&gt;
</code></pre></li>
</ul>

<h3 id="toc_23">第17章 双版面主从用户界面</h3>

<h4 id="toc_24">17.1 增加布局灵活性</h4>

<ul>
<li><p>在手机设备上，CrimeListActivity生成的是单版面（single-pane）布局，托管CrimeListFragment；在平板设备上，为了同时显示主从视图需要生成双版面（two-pane）布局，CrimeListActivity将同时托管CrimeListFragment和CrimeFragment；</p></li>
<li><p>要实现双版面布局，需完成如下任务：修改SingleFragmentActivity不再硬编码实例化<code>包含fragment容器的布局</code>、创建<code>包含两个fragment容器的布局</code>、修改CrimeListActivity，实现在手机设备上实例化包含<code>单版面容器的布局</code>，在平板设备上实例化<code>双版面容器的布局</code>；</p></li>
<li><p>在方法上使用<code>@LayoutRes</code>注解，表示告诉Android Studio该方法应该返回有效的布局资源ID，否则编译报错；</p></li>
<li><p><code>别名资源</code>是一种指向其他资源的特殊资源，存放在<code>res/values/</code>目录下，并按照约定定义在refs.xml文件中；</p></li>
<li><p><strong>为了让activity基于不同的设备使用的不同布局文件，可以像之前的使用<code>资源修饰符</code>对竖直、水平（land）布局的选择和控制，使用资源修饰符；但是以下缺点：</strong></p>

<ul>
<li><strong>a. 必须将不同的布局文件分别放置到规定的布局文件夹目录中（如res/layout/、res/layout-sw600dp/）；</strong></li>
<li><strong>b. 同一activity对于不同设备的不同布局文件的文件名必须一样；</strong></li>
</ul></li>
<li><p><strong>也可以使用别名资源，让activity基于不同的设备使用的不同布局文件；</strong></p>

<ul>
<li><strong>此时同一activity对于不同设备的布局文件的名称可以不一样，而且布局文件可以不放置到规定的布局文件夹目录中；</strong></li>
<li><strong>别名资源相当于给其他资源起个别名；为了适配不同的设备，需要新建不同的别名资源放置到不同的value文件夹目录中（比如<code>res/values/</code>、<code>res/values-sw600dp/</code>），这相当于将设备判断后所要加载的不同的文件转移到别名资源文件上了，别名资源起到一个中介作用；</strong></li>
</ul></li>
<li><p>右击res/目录 -&gt; 选择New -&gt; Android resource file -&gt; 选择资源类型为Values，文件命名为refs.xml -&gt; 确认新建的文件不带任何修饰符；</p>

<pre><code>// res/values/refs.xml，别名资源activity_masterdetail指向了activity_fragment布局资源文件
&lt;resources&gt;
    &lt;item name=&quot;activity_masterdetail&quot; type=&quot;layout&quot;&gt;@layout/activity_fragment&lt;/item&gt;
&lt;/resources&gt;
</code></pre>

<ul>
<li><strong>上面的别名资源指向了activity_fragment布局资源文件，别名资源自身也有资源ID（R.layout.activity_masterdetail)；</strong></li>
<li><strong>type属性决定资源ID属于什么内部类，即使别名资源文件自身在res/values/目录中，但是它的资源ID依然属于R.layout内部类；别名资源可以配置多个item，type根据指向的资源而定；</strong></li>
</ul></li>
<li><p><strong>需要创建一个大屏幕设备使用的别名资源，此时创建时将<code>Available qualifiers</code>中<code>Smallest Screen Width</code>选到右边窗口中，并且输入相关数值（如600），这样创建的refs.xml文件会在特定的values-XX目录中（如res/values-sw600dp/）；</strong></p>

<pre><code>// res/values-sw600dp/refs.xml，别名资源activity_masterdetail指向了activity_twopane布局资源文件
&lt;resources&gt;
    &lt;item name=&quot;activity_masterdetail&quot; type=&quot;layout&quot;&gt;@layout/activity_twopane&lt;/item&gt;
&lt;/resources&gt;
</code></pre></li>
<li><p><strong>这样对于不同尺寸的设备，代码都使用activity_masterdetail布局，但是运行时activity_masterdetail指向的资源不一样，进而加载不同类型的布局；类似于之前的<code>不同屏幕方向加载不同布局</code>（不同布局文件夹，相同布局文件名）；</strong></p></li>
<li><p><strong><code>配置修饰符</code>：比如-sw600dp表示smallest width（最小宽度，实际上是最小尺寸，不考虑屏幕方向）大于等于600dp的设备，使用该目录下的资源，若小于则使用默认的资源（没有其他的修饰符的情况下）；</strong></p></li>
</ul>

<h4 id="toc_25">17.2 activity：fragment的托管者</h4>

<ul>
<li><p><strong>一个activity中同时展示两个fragment，若这两个fragment间有关联（比如点击fragmentA不同的内容，fragmentB也需要跟着变化、fragmentA的内容变化了，fragmentB也需要跟着变化），处理这种逻辑有两种方式：</strong></p>

<ul>
<li><p><strong>a. 直接操控fragmentManager：</strong></p>

<ul>
<li><strong>当fragmentA变化时，在fragmentA中获取托管activity的fragmentManager，在fragmentA中直接操控fragmentManager更新fragmentB；</strong></li>
<li><strong>这种方式可行，但是耦合性太强；fragmentA需要知道托管activity的包含fragment容器的布局是什么样的，fragmentA与托管activity耦合在一起；</strong></li>
<li><strong>fragmentA应该是可以作为独立的开发构件使用的；包含fragment容器的布局是什么样的，应该是托管activity所应该单独处理的，fragmentA不应该知道；</strong></li>
</ul></li>
<li><p><strong>b. 定义实现回调接口回调</strong></p>

<ul>
<li><strong>为了保持fragmentA的独立性，可以在fragmentA中定义回调接口方法，让托管activity去实现回调接口方法，处理具体的逻辑（如更新fragmentB）；</strong></li>
<li><strong>接口定义了fragment委托给托管activity处理的工作任务，任何打算托管目标fragment的activity都必须实现它；</strong></li>
<li><strong>当fragmentA变化时，调用activity的具体回调接口方法，进而在activity中完成了对fragmentB的更新操作；</strong></li>
<li><strong>fragmentA需要定义一个变量mCallbacks，用于存放实现Callbacks接口的对象（就是activity）；activity赋值给变量mCallbacks是在fragment的生命周期方法中处理的：在<code>onAttach(Context context)</code>方法中进行赋值（不要在onAttach(Activity activity)方法中，这个方法已废弃），在<code>public void onDetach()</code>中置为null；</strong></li>
</ul></li>
</ul></li>
</ul>

<h4 id="toc_26">17.3 深入学习：设备屏幕尺寸的确定</h4>

<ul>
<li><p>在Android 3.2之前，屏幕大小修饰符是基于设备的屏幕大小来提供可选资源的，分为small（最低屏幕大小320<em>426dp）、normal(320</em>470dp)、large、xlarge；</p></li>
<li><p><strong>在Android 3.2之后，屏幕大小修饰符废弃，使用了独立的屏<code>幕尺寸修饰符</code>，分为wXXXdp（有效宽度：宽度大于或等于XXXdp）、hXXXdp（有效高度：高度大于或等于XXXdp）、swXXXdp（最小宽度：宽度高度两者中最小的那个大于或等于XXXdp）；</strong></p></li>
<li><p><strong>若想指定某个布局仅适用于屏幕宽度至少为300dp的设备，可以使用宽度修饰符，并将布局文件放入res/layout-w300dp/目录下；</strong></p></li>
</ul>

<h3 id="toc_27">第18章 应用本地化</h3>

<h4 id="toc_28">18.1 资源本地化</h4>

<ul>
<li><p><strong>语言设置是<code>设备配置</code>的一部分，和处理屏幕方向、屏幕尺寸以及其他配置因素改变一样，Android也提供了用于不同语言的配置修饰符；只需要创建带目标语言配置修饰符的资源子目录，并放入备选资源，其余工作就交给Android资源系统自动处理；</strong></p></li>
<li><p><strong>右击res/目录 -&gt; New -&gt; Android resource file菜单项，文件名为strings.xml：Source set选择main，Directory name设为values，在<code>Available qualifiers</code>列表选中Locale，使用&gt;&gt;按钮把其移入<code>Chosen qualifiers</code>中，在Language列表中选zh: Chinese，右边的Specific Region Only中选中Any Region；Android Studio会自动设置Directory name为values-zh；</strong></p></li>
<li><p>语言配置修饰符来自于ISO 639-1标准代码，每个修饰符都由两个字符组成，比如中文的修饰符为zh；</p></li>
<li><p>英文语言的配置修饰符为en，英文版字符串资源为values-en/ strings.xml；</p></li>
<li><p>若Android无法找到匹配当前语言设置的资源，则不匹配的字符串资源，用在XML布局文件中应用会显示资源ID数值，用在Java代码中应用就会崩溃；</p></li>
<li><p>没有配置修饰符的资源就是Android的默认资源；提供默认资源非常重要，若无法找到匹配当前配置的资源，Android就会使用默认资源，其能保证应用正常运行；</p></li>
<li><p><strong>Android的默认资源使用规则并不适用于<code>屏幕显示密度</code>；</strong>项目的drawable目录通常按屏幕显示密度，带有-mdpi、-xxhdpi这样的修饰符；Android决定使用哪一类drawable资源并不是简单地匹配设备的屏幕显示密度，也不是在没有匹配的资源时直接使用默认资源，而是综合考虑屏幕尺寸和显示密度；<strong>故不要在res/drawable/目录下放置<code>所谓的默认的drawable资源</code>；</strong></p></li>
<li><p><strong>检查资源本地化完成情况：在Android Studio选择<code>Android窗口</code>查看文件（不是Project窗口），打开res/values/文件夹，右击默认字符串资源strings.xml，选择<code>Open Translations Editor</code>进行查看；若没有改选项将Android窗口的文件目录先收起再展开；</strong></p></li>
<li><p>修饰资源目录还可以使用<code>语言加区域修饰符</code>，这样可以让资源使用更有针对性；比如-es-rMX表示墨西哥地区的西班牙语，r代表区域；配置修饰符对大小写不敏感，但最好遵守Android命名约定：语言代码小写，区域代码大写，前面加个小写的r；</p></li>
<li><p>语言和区域修饰同时匹配用户的locale，若没有匹配上，系统会去除区域修饰仅以语言去匹配；<strong>建议：最好仅用语言的修饰目录，少用区域修饰，这样资源应尽可能通用；</strong></p></li>
</ul>

<h4 id="toc_29">18.2 配置修饰符</h4>

<ul>
<li><p>Android提供配置修饰符以更好地匹配资源，有移动国家码、语言代码、布局方向、最小宽度、可用宽度...API级别等等好多修饰符；</p></li>
<li><p>旧版本Android系统，并非支持所有配置修饰符，故出现了API级别修饰符，如圆形屏幕修饰符自API 23级别引入，若使用它则系统会自动加上v23，这样就不用担心在旧系统会遇到问题；</p></li>
<li><p>考虑到有那么多匹配资源的配置修饰符，有时会出现设备配置与好几个可选资源都匹配的情况，此时Android会根据<code>修饰符的优先级</code>使用；比如，同时有values-w600dp/strings.xml、values-zh/strings.xml；</p></li>
<li><p><strong>可以在同一资源目录上使用多个配置修饰符，各配置修饰符需要按照优先级别顺序排列；新建资源文件对话框中，工具会自动配置正确的目录名；</strong>比如，values-zh-land是一个有效的资源目录名，而values-land-zh则是无效的资源目录名；</p></li>
<li><p><strong>寻找最匹配的资源：Android首先排除不兼容<code>当前设备配置</code>的资源目录，之后按配置修饰符的优先级排除不兼容的目录（有高优先级的目录，低优先级的目录会被排除）；</strong></p></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android编程权威指南 笔记(07~12)]]></title>
    <link href="http://www.justisit.com/15225894269717.html"/>
    <updated>2018-04-01T21:30:26+08:00</updated>
    <id>http://www.justisit.com/15225894269717.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">第7章 UI fragment与fragment管理器</a>
<ul>
<li>
<a href="#toc_1">7.2 引入fragment</a>
</li>
<li>
<a href="#toc_2">7.3 着手开发CriminalIntent</a>
</li>
<li>
<a href="#toc_3">7.4 托管UI fragment</a>
</li>
<li>
<a href="#toc_4">7.5 创建UI fragment</a>
</li>
<li>
<a href="#toc_5">7.6 向FragmentManager添加UI fragment</a>
</li>
<li>
<a href="#toc_6">7.8 深入学习：fragment与支持库</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">第8章 使用RecyclerView显示列表</a>
<ul>
<li>
<a href="#toc_8">8.3 RecyclerView、ViewHolder和Adapter</a>
</li>
<li>
<a href="#toc_9">8.5 响应点击</a>
</li>
<li>
<a href="#toc_10">8.6 深入学习：ListView和GridView</a>
</li>
<li>
<a href="#toc_11">8.7 深入学习：单例</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">第9章 使用布局与组件创建用户界面</a>
<ul>
<li>
<a href="#toc_13">9.2 引入ConstraintLayout</a>
</li>
<li>
<a href="#toc_14">9.3 深入学习布局属性</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">第10章 使用fragment argument</a>
<ul>
<li>
<a href="#toc_16">10.1 从fragment中启动activity</a>
</li>
<li>
<a href="#toc_17">10.2 fragment argument</a>
</li>
<li>
<a href="#toc_18">10.3 刷新显示列表项</a>
</li>
<li>
<a href="#toc_19">10.4 通过fragment获取返回结果</a>
</li>
<li>
<a href="#toc_20">10.5 深入学习：为何要用fragment argument</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">第11章 使用ViewPager</a>
<ul>
<li>
<a href="#toc_22">11.1 创建CrimePagerActivity</a>
</li>
<li>
<a href="#toc_23">11.2 FragmentStatePagerAdapter与FragmentPagerAdapter</a>
</li>
<li>
<a href="#toc_24">11.3 深入学习：ViewPager的工作原理</a>
</li>
<li>
<a href="#toc_25">11.4 深入学习：以代码的方式创建视图</a>
</li>
<li>
<a href="#toc_26">11.5 挑战练习：恢复CrimeFragment的边距</a>
</li>
</ul>
</li>
<li>
<a href="#toc_27">第12章 使用对话框</a>
<ul>
<li>
<a href="#toc_28">12.0 概述</a>
</li>
<li>
<a href="#toc_29">12.1 创建DialogFragment</a>
</li>
<li>
<a href="#toc_30">12.2 fragment间的数据传递</a>
</li>
</ul>
</li>
</ul>


<span id="more"></span><!-- more -->

<h3 id="toc_0">第7章 UI fragment与fragment管理器</h3>

<h4 id="toc_1">7.2 引入fragment</h4>

<ul>
<li><p><strong>采用fragment而不是activity来管理应用UI，可绕开activity使用规则的限制，比如列表明细类应用（明细视图切换时不需要再销毁activity）；其还适用于其他类型的应用，比如可以更方便地构建分页界面、动画侧边栏等定制界面；</strong></p></li>
<li><p><strong>fragment是一种控制器对象，activity可委派其完成一些任务，如管理用户界面（一整屏、整屏的一部分）等；</strong></p>

<ul>
<li><strong>管理用户界面的fragment又称为UI fragment，其包含了用户可以交互的视图UI元素；</strong></li>
<li><strong>activity视图可预留位置供fragment视图插入；若有多个fragment要插入，activity视图也可提供多个位置；</strong></li>
</ul></li>
</ul>

<h4 id="toc_2">7.3 着手开发CriminalIntent</h4>

<ul>
<li><p>首先设计一个名为CrimeFragment的UI fragment来管理用户界面（与activity在GeoQuiz应用中的作用差不多），再设计一个名为CrimeActivity的activity来<strong>托管</strong>CrimeFragment实例；</p>

<ul>
<li><strong>activity在其视图层级里提供一处位置用来放置fragment的视图，fragment本身不具有在屏幕上显示视图的能力；只有将fragment视图放置在activity的视图层级结构中，fragment视图才能显示在屏幕上；</strong></li>
</ul></li>
<li><p>Google在API 11引入了fragment，并有两个版本的fragment实现可以使用：原生版本、支持库版本；</p>

<ul>
<li>原始版本的实现内置在设备系统中，在不同版本设备上运行可能有不同的表现；</li>
<li>支持库版本的实现会打包到应用中，在不同版本设备上运行有着相同的表现；</li>
<li>支持库版fragment来自于AppCompat库（<code>compile &#39;com.android.support:appcompat-v7:25.0.1&#39;</code>）；使用时需要将其加入到项目的依赖关系中；</li>
</ul></li>
<li><p>添加依赖关系的方式：</p>

<ul>
<li>修改应用模块的build.gradle的<code>dependencies</code>；</li>
<li>File -&gt; Project Structure -&gt; 选择应用模块 -&gt; 点击右边的Dependencies选项页 -&gt; 点击+号 -&gt; Library dependency；</li>
</ul></li>
<li><p>对于未复制到项目中的依赖项，应用编译时Gradle会下载依赖包并自动导入到项目中； </p></li>
<li><p>依赖项字符使用了Maven坐标模式：<code>groupId:artifactId:version</code>；</p>

<ul>
<li>groupId通常是类库的包名，Maven仓库中的唯一标识；</li>
<li><strong>artifactId是特定库名，比如support-v4、support-v13、appcompat-v7、gridlayout-v7；-vX标识所支持的最低API级别；</strong></li>
<li>version标识类库的的版本；</li>
</ul></li>
</ul>

<h4 id="toc_3">7.4 托管UI fragment</h4>

<ul>
<li><p><strong>activity托管UI fragment必须做到<code>两件事</code>：</strong></p>

<ul>
<li><strong>a. 在布局中为fragment的视图安排位置；</strong></li>
<li><strong>b. 管理fragment实例的生命周期；</strong></li>
</ul></li>
<li><p>activity托管UI fragment有两种方式：</p>

<ul>
<li>a. 在activity布局文件中添加fragment控件元素：

<ul>
<li>简单但不灵活，activity的视图绑定了fragment及其视图，无法替换fragment视图；</li>
<li>这种方式无需添加别的配置就已经做到上面的<code>两件事</code>；</li>
</ul></li>
<li>b. 在activity代码中添加fragment对象：

<ul>
<li>复杂但灵活，但也是唯一可以动态控制fragment的方式，可随时添加移除替换fragment；一般都使用该方式；</li>
<li>这种方式需要我们自己处理上面的<code>两件事</code>；</li>
</ul></li>
</ul></li>
<li><p>虽然是在托管activity代码中添加UI fragment，但还是要在activity视图层级结构中为fragment视图安排位置；</p>

<ul>
<li><strong>为了在布局中为fragment视图安排位置，需要定义个<code>容器视图</code>（比如FrameLayout控件元素）；这个<code>容器视图</code>是通用的，不局限于托管某一个fragment；</strong></li>
<li>CrimeActivity视图由FrameLayout组件组成，FrameLayout组件为CrimeFragment视图安排了显示位置；</li>
</ul></li>
<li><p><strong>fragment生命周期与activity生命周期类似，覆盖相应的方法完成相应的任务；一个关键区别在于，fragment的生命周期方法（public的，activity需要调用；activity是protected的）由托管activity而不是操作系统调用；操作系统不关心activity用来管理视图的fragment，fragment的使用是activity内部的事情；</strong></p></li>
</ul>

<h4 id="toc_4">7.5 创建UI fragment</h4>

<ul>
<li><p><strong>创建UI fragment和创建activity的步骤是一样的：定义布局文件、创建fragment并设置布局文件，配置布局文件中的组件；</strong></p></li>
<li><p>fragment也有onCreate、onSaveInstanceState等方法，但是fragment的视图并不是在onCreate方法中生成，而是在onCreateView方法中完成的；  </p></li>
<li><p><strong>fragment的<code>public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</code>：</strong></p>

<ul>
<li>该方法由托管activity调用， 实例化fragment视图的布局，然后将实例化的View返回给托管activity；</li>
<li><p>LayoutInflater、ViewGroup是实例化布局的必要参数，Bundle用来存储恢复数据，可供该方法从保存状态下重建视图；</p>

<pre><code class="language-java">@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
View v = inflater.inflate(R.layout.fragment_crime, container, false);
return v; 
}
</code></pre></li>
</ul></li>
<li><p><strong>在onCreateView()方法中，fragment的视图是直接通过用<code>LayoutInflater.inflate(...)</code>方法生成的，之后完成布局中组件的设置（如给组件添加监听等）；</strong></p></li>
<li><p><code>LayoutInflater.inflate(...)</code>方法参数：</p>

<ul>
<li>第一个参数为布局资源ID；</li>
<li>第二个参数为视图的父视图；</li>
<li>第三个参数为是否将生成的视图添加到父视图中；</li>
</ul></li>
<li><p><strong>fragment的onCreateView几乎等同于activity的onCreate；唯一区别只是：在获取内部的组件时，activity中是调用activity的findViewById（本质还是调用view的findViewById），fragment中是调用view的findViewById；</strong></p></li>
</ul>

<h4 id="toc_5">7.6 向FragmentManager添加UI fragment</h4>

<ul>
<li><p><strong>FragmentManager负责管理fragment并将它们的视图添加到activity的视图层级结构中；FragmentManager的具体管理：fragment队列、fragment事务回退栈（之后会学习）；</strong></p>

<ul>
<li><strong>a. 先调用activity的<code>getSupportFragmentManager()</code>获取FragmentManager对象；</strong></li>
<li><strong>b. 通过调用fragmentManager的<code>findFragmentById()</code>方法获取该fragment；</strong></li>
<li><p>c. <strong>若获取失败，则创建一个fragment对象；</strong></p>

<ul>
<li><strong>a). 之后调用fragmentManager.beginTransaction()开启fragment事务，返回FragmentTransaction对象；</strong></li>
<li><strong>b). 将相关操作（比如add()、delete()等）添加到fragment事务（FragmentTransaction对象）中；</strong></li>
<li><strong>c). 提交fragment事务；</strong></li>
</ul>

<pre><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_crime);

    FragmentManager fm = getSupportFragmentManager();
    Fragment fragment = fm.findFragmentById(R.id.fragment_container);

    if (fragment == null) {
        fragment = new CrimeFragment();
        fm.beginTransaction()
            .add(R.id.fragment_container, fragment)
            .commit();
    }
}
</code></pre></li>
</ul></li>
<li><p><strong>fragment事务被用来添加、移除、附加、分离或替换fragment队列中的fragment，这是使用fragment动态组装和重新组装用户界面的关键；而FragmentManager管理着fragment事务回退栈；</strong></p></li>
<li><p>add()方法有两个参数：容器视图资源ID（定义在activity的布局文件中的FrameLayout组件的资源ID）、新建的fragment对象；</p></li>
<li><p>容器视图资源ID有两个作用：</p>

<ul>
<li>a. 告诉FragmentManager对象，fragment的视图应该放置在activity的视图的什么位置；</li>
<li>b. 唯一标识FragmentManager队列中的fragment；可以从fragmentManager中获取相关的fragment；</li>
</ul></li>
<li><p><strong>当设备旋转或回收内存时，Android系统销毁activity，其FragmentManager对象会保存fragment队列；而当activity重建时，新的FragmentManager会首先获取保存的队列，然后重建fragment队列，从而恢复到原来的状态；故需要先判断fragment是否已存在<code>fm.findFragmentById(R.id.fragment_container</code>，若存在则直接返回，否则走添加fragment的流程；</strong></p></li>
<li><p>activity的FragmentManager负责调用队列中fragment的生命周期方法；</p>

<ul>
<li><strong>a. 添加fragment供FragmentManager管理时，onAttach(Context)、onCreate(Bundle)、onCreateView(...)方法被调用；</strong></li>
<li>b. 在托管的activity的onCreate()方法中添加fragment后，fragment的onActivityCreated()方法会被调用；</li>
<li>c. 若在托管的activity处于运行时添加fragment，FragmentManager立即驱赶fragment，调用一系列必要的生命周期方法，与activity的最新状态保持同步；依次调用onAttach(Context)、onCreate(Bundle)、onCreateView(...)、onActivityCreated(Bundle)、onStart()、onResume()；</li>
<li>d. fragment与activity的状态一旦同步完成后，托管activity的FragmentManager就会边接收操作系统的调用指令，边调用fragment的其他生命周期方法，继续保持状态一致；</li>
</ul></li>
</ul>

<h4 id="toc_6">7.8 深入学习：fragment与支持库</h4>

<ul>
<li><p>support-v4库支持实现fragment功能，可以在该库中找到android.support.v4.app.Fragment；support-v4库中也有一个FragmentActivity（android.support.v4.app.FragmentActivity）；<strong>若要使用支持库版fragment，应用的activity必须继承FragmentActivity；</strong></p></li>
<li><p><strong>AppCompatActivity就是FragmentActivity的子类；引入了AppCompat库，就能使用支持库版fragment；若只想用support-v4库也可以，在项目里引入该库后，把各个activity的父类从AppCompatActivity改为FragmentActivity即可；</strong></p></li>
</ul>

<h3 id="toc_7">第8章 使用RecyclerView显示列表</h3>

<h4 id="toc_8">8.3 RecyclerView、ViewHolder和Adapter</h4>

<ul>
<li><p>RecyclerView是ViewGroup的子类，每个列表项都是作为一个独立的View子对象显示的；</p></li>
<li><p>RecyclerView的任务仅限于回收和定位屏幕上的View；列表项View能够显示数据还离不开另外两个类的支持：ViewHolder子类和Adapter子类；</p>

<ul>
<li>ViewHolder是每个列表项的View布局的容器；该view布局（ViewHolder通过itemView属性引用着）可以是系统内置的（比如simple_list_item_1），也可以是自定义的；view布局都会被封装到ViewHolder中，这样对adapter来说统一了接口；</li>
<li>RecyclerView自己不创建ViewHolder，该任务实际是由Adapter来完成的；Adapter从模型层获取数据，绑定到ViewHolder上，然后提供给RecyclerView显示；</li>
</ul></li>
<li><p>Adapter工作流程：</p>

<ul>
<li><p>a. 首先，RecyclerView调用adapter的<code>getItemCount()</code>方法，告诉RecyclerView列表中有多少个列表项；</p></li>
<li><p>b. 接着，RecyclerView调用adapter的<code>createViewHolder(ViewGroup, int)</code>方法创建ViewHolder及其要显示的视图，告诉RecyclerView每个列表项的View的样子；</p></li>
<li><p>c. 最后，RecyclerView调用<code>onBindViewHolder(ViewHolder, int)</code>方法，根据参数信息，将列表位置对应的模型数据<strong>绑定（填充）</strong>到ViewHolder视图上；</p>

<pre><code class="language-java">private class CrimeAdapter extends RecyclerView.Adapter&lt;CrimeHolder&gt; {
    ...
    @Override
    public CrimeHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        LayoutInflater layoutInflater = LayoutInflater.from(getActivity());
        return new CrimeHolder(layoutInflater, parent);
    }

    @Override
    public void onBindViewHolder(CrimeHolder holder, int position) {
        Crime crime = mCrimes.get(position);
        holder.bind(crime); // 自定义bind方法，绑定数据（给子控件设置属性值）
    }

    @Override
    public int getItemCount() {
        return mCrimes.size();
    }
}
</code></pre></li>
</ul></li>
</ul>

<ul>
<li><p><strong>为节约时间和内存，一旦创建了够用的ViewHolder，RecyclerView就会停止调用createViewHolder()方法创建新的ViewHolder，之后使用ViewHolder时（执行onBindViewHolder()时）回收利用旧的ViewHolder；</strong></p></li>
<li><p>RecyclerView类来自于Google支持库（recyclerview-v7）；</p></li>
<li><p>RecyclerView还需要LayoutManager的支持；RecyclerView负责显示视图，LayoutManager负责摆放列表项、定义屏幕滚动行为；</p></li>
<li><p>LayoutManager有系统内置的实现，比如LinearLayoutManager是以竖直列表的形式展示列表项，GridLayoutManager是以网格的形式展示列表项，也可以使用第三方的实现；</p>

<pre><code class="language-java">@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fragment_crime_list, container, false);
    mCrimeRecyclerView = (RecyclerView) view.findViewById(R.id.crime_recycler_view);
    mCrimeRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));
    return view;
}
</code></pre></li>
</ul>

<h4 id="toc_9">8.5 响应点击</h4>

<ul>
<li>每个列表项视图都关联着ViewHolder，可以让ViewHolder监听用户的触摸、点击事件（实现OnClickListener接口）；</li>
</ul>

<h4 id="toc_10">8.6 深入学习：ListView和GridView</h4>

<ul>
<li><p>Android操作系统核心库包含ListView、GridView、Adapter，Android 5.0之前创建列表项或网格项使用这些类；</p></li>
<li><p>ListView、GridView、Adapter这些类的API与RecyclerView非常相似，但是这些类不完善，需要进行额外的定制工作才能完成一些任务；比如ListView不支持创建水平滚动的列表，ListView和GridView不支持删除添加列表项的动画效果；</p>

<pre><code class="language-java">// 将位置0处的列表项移动到位置5处
mRecyclerView.getAdapter().notifyItemMoved(0, 5);
</code></pre></li>
</ul>

<h4 id="toc_11">8.7 深入学习：单例</h4>

<ul>
<li><p>Android开发中常用到单例的一大原因是其生命比fragment、activity久，屏幕旋转单例不受影响；并且单例也能方便地存储控制模型层对象；但是其缺点是无法进行长久持久化、不利于单元测试；</p></li>
<li><p>请确保有充足的理由使用单例模式存储要共享的数据；</p></li>
</ul>

<h3 id="toc_12">第9章 使用布局与组件创建用户界面</h3>

<h4 id="toc_13">9.2 引入ConstraintLayout</h4>

<ul>
<li><p><strong>ConstraintLayout是一种进化版的RelativeLayout，比RelativeLayout功能更强大、性能更好，而且在图形布局工具中操作更方便（不用再手动输入XML布局了）；其使用约束布置组件的位置，而组件的大小尺寸则提供三种选项：手动调整、让组件自己决定(wrap_content)、让组件充满约束布局；</strong></p></li>
<li><p>和RecyclerView类似， ConstraintLayout来自于约束布局依赖库（constraint-layout），使用时需要添加该依赖库；</p></li>
<li><p>布局预览窗口顶部的约束编辑选项工具栏，依次为显示所有约束、自动连接切换开关（当拖拽组件时，Android Studio自动配置约束）、清除全部约束、猜测约束（与自动连接类似）；</p>

<p><img src="media/15225894269717/constraintlayout_tools.png" alt="constraintlayout_tools" style="width:709px;"/></p></li>
<li><p><strong>控件的大小尺寸由宽度、高度的设置值决定，设置值有三种选项，可以通过点击示例图进行切换，也可以设置layout_width(layout_height)；</strong></p>

<ul>
<li><p><strong>固定大小：Xdp，为视图指定固定值；</strong></p></li>
<li><p><strong>包裹内容：wrap_content，设置视图想尺寸根据内容而定；</strong></p></li>
<li><p><strong>动态适应：match_constraint（0dp）， 允许视图缩放以满足指定约束；与match_parent不等价；</strong></p>

<p><img src="media/15225894269717/constraintlayout_size_types.png" alt="constraintlayout_size_types" style="width:444px;"/></p></li>
</ul></li>
<li><p><strong>控件的四边的中心有都有圆点，表示约束柄；</strong></p>

<ul>
<li><strong>圆点为空心则说明没有约束，点击该点（变绿色），拖拽移动箭头到<code>相对控件的某边上</code>即创建约束；</strong></li>
<li><strong>圆点为实心则说明已添加约束，光标移动到该圆点上（变红色），点击即删除该约束；</strong></li>
</ul>

<p><img src="media/15225894269717/constraintlayout_attributes.png" alt="constraintlayout_attributes" style="width:537px;"/></p></li>
<li><p><strong>凡是以layout_开头的属性都属于布局参数（layout parameter）属性；<code>app:layout_constraintTop_toTopOf=&quot;parent&quot;</code>：</strong></p>

<ul>
<li><strong>约束的属性的命名空间为app，而不是android；</strong></li>
<li><strong>属性名以<code>layout_constraint</code>开始；</strong></li>
<li><strong>toTopOf=&quot;parent&quot;表示约束连接到父组件的顶部；</strong></li>
</ul></li>
</ul>

<h4 id="toc_14">9.3 深入学习布局属性</h4>

<ul>
<li><p><strong>对于图片，Android会使用不同像素密度drawable自动适配不同像素密度的屏幕；对于对距离尺寸、文字大小，Android提供了与密度无关的尺寸单位，让其在不同屏幕像素密度的设备上获得同样的尺寸，而在应用运行时，Android会自动将这种单位转换成像素单位；</strong></p>

<p><img src="media/15225894269717/px%E3%80%81dp%E3%80%81sp.png" alt="px、dp、sp" style="width:343px;"/></p>

<ul>
<li>px（pixel，像素）：无论屏幕密度多少，一个像素单位对应一个屏幕像素单位；不推荐使用px，因为它不会根据屏幕密度自动缩放；</li>
<li><strong>dp（dip，density-independent pixel，密度无关像素）：无论屏幕密度如何，总能获得同样的尺寸，1dp在设备屏幕上总是等于1/160英寸；通常用来设置内边距、边距等；</strong></li>
<li><strong>sp（scale-independent pixel，缩放无关像素）：一种与密度无关的像素，会受<code>用户字体偏好设置</code>的影响，通常来设置屏幕上的字体大小；</strong></li>
<li>pt、mm、in：类似于dp的缩放单位，但不建议使用，并非所有设备都能正常缩放配置；</li>
</ul></li>
<li><p>边距属性（android:layout_margin）是布局参数，决定了组件间的距离，Android Studio默认使用的值是16dp或8dp（遵循Material Design原则）；内边距属性（android:padding）不是布局参数，表示的是组件在绘制组件自身时，要比所含内容大多少；</p></li>
<li><p><code>样式</code>资源文件style.xml是用来描述组件行为和外观的属性定义，其位于res/values目录下；在该文件中可以添加创建自己的样式，之后在布局文件中中以<code>@style/STYLE_NAME</code>的形式进行引用（与string类似）；</p>

<pre><code class="language-xml">&lt;style name=&quot;BigTextStyle&quot;&gt;
    &lt;item name=&quot;android:textSize&quot;&gt;20sp&lt;/item&gt;
    &lt;item name=&quot;android:padding&quot;&gt;3dp&lt;/item&gt; 
&lt;/style&gt;
</code></pre></li>
<li><p>主题（theme）是各种样式的集合，其也是一种样式资源，只不过其的属性指向了其他样式资源；<strong>Android自带了一些供应用使用的平台主题，创建应用时Android Studio会自动设置默认主题（在manifest文件的application标签下，<code>android:theme=&quot;@style/AppTheme</code>）；</strong></p></li>
<li><p>使用<code>主题的属性引用</code>：将预定的应用主题样式添加给相应的组件；</p>

<ul>
<li>比如<code>style=&quot;?android:listSeparatorTextViewStyle&quot;</code>，就让Android运行资源管理器在应用主题中找名为listSeparatorTextViewStyle的属性，并将该属性指向的样式资源设置到该组件上；</li>
<li>所有的Android主题都包含名为listSeparatorTextViewStyle的属性，只不过对于不同的主题，其定义不一样；</li>
</ul></li>
<li><p>补充</p>

<ul>
<li><p>以<code>layout_</code>开头的属性则用于组件的父组件，这些属性称为布局参数，其告诉父局部如何在内部安排自己的子元素；不以<code>layout_</code>开头的属性用于组件，组件实例化时会调用方法按照属性及值进行自我配置；如边距（android:layout_margin）、内边距（android:padding）；</p></li>
<li><p>LinearLayout在决定子视图的宽度时，使用的是layout_width（height）与layout_weight参数的混合值；</p>

<ul>
<li>第一步根据layout_width（height）绘制控件大小，第二步根据layout_weight属性值进行额外的空间分配；各个组件的layout_weight值的比例和为1；</li>
<li>若让各个控件的宽度相同，则可以设置layout_width为0dp，layout_weight为均分值；</li>
</ul></li>
<li><p>若一个组件只存在于一个布局上，则应先进行空值检查再进行配置；定义在水平或垂直布局文件中的同一个组件必须有相同的android:id属性，这样代码才能引用到它；</p>

<pre><code class="language-java">Button landscapeOnlyButton = (Button)v.findViewById(R.id.landscapeOnlyButton); 
if (landscapeOnlyButton != null) {
    // Set it up
}
</code></pre></li>
</ul></li>
</ul>

<h3 id="toc_15">第10章 使用fragment argument</h3>

<h4 id="toc_16">10.1 从fragment中启动activity</h4>

<ul>
<li><p><strong>从fragment中启动activity类似于从activity中启动activity；调动fragment的startActivity()，其会在后台再调用对应的activity的方法；</strong></p></li>
<li><p><strong>通过给intent附加extra信息（UUID是Serializable的，也可以被putExtra），子activity是可以获取到intent的extra信息；而子activity中的fragment若要获取该intent的extra信息，则有两种方式：</strong></p>

<ul>
<li><p><strong>a. 直接获取：</strong></p>

<ul>
<li><strong>在fragment的onCreate()方法中先获取其托管的activity，之后通过activity获取相关信息；如<code>getActivity().getIntent().getSerializableExtra(KEY)</code>；</strong></li>
<li><strong>该方式的缺点是破坏fragment的封装性，fragment不可被复用；</strong></li>
<li><strong>所需要的extra数据被保存在activity中；应该将所需要的extra数据保存在fragment中，这个地方就是<code>argument bundle</code>；</strong></li>
</ul></li>
<li><p><strong>b. 使用fragment argument获取；</strong></p></li>
</ul></li>
</ul>

<h4 id="toc_17">10.2 fragment argument</h4>

<ul>
<li><p>每个fragment都可附加一个Bundle对象，该对象含有键值对，一个键值对就是一个argument；使用方式和附加extra到intent中一样；</p>

<pre><code class="language-java">Bundle args = new Bundle();
args.putSerializable(EXTRA_MY_OBJECT, myObject);
args.putInt(EXTRA_MY_INT, myInt);
</code></pre></li>
<li><p><strong>若将argument bundle附加给fragment，可调用fragment的setArguments(Bundle)方法；</strong></p>

<ul>
<li><strong>该方法必须在fragment创建后、添加给activity前完成；</strong> </li>
<li><strong>为了满足此要求，通常在Fragment中添加一个静态方法newInstance，该方法中完成fragment、bundle及setArguments()的操作，参数为需要保存fragment中的数据；</strong></li>
<li><strong>托管activity需要fragment时，调用该静态方法并传入必要的数据；</strong></li>
</ul></li>
<li><p><strong>fragment中获取argument，可调用fragment的getArguments获取Bunlde对象，之后再调用相关get方法（在onCreate()方法中进行调用）进而获取传递过来的数据；</strong></p></li>
</ul>

<h4 id="toc_18">10.3 刷新显示列表项</h4>

<ul>
<li><p>当activity恢复运行时，系统会发出调用onResume()方法的指令，activity收到指令后，它的FragmentManager会调用当前activity托管的fragment的onResume()方法；</p></li>
<li><p><strong>一般在onResume()方法中操作刷新数据；</strong>因为当有其他 activity位于你的activity之上时，无法确定自己的activity是否会被停止，有可能最上面的activity是透明的，此时自己的activity只是暂停，恢复时不会调用onStart()方法；</p></li>
</ul>

<h4 id="toc_19">10.4 通过fragment获取返回结果</h4>

<ul>
<li><p><strong>若fragment需要从被启动的activity中获取返回数据，则和之前的activity的处理方式类似；调用fragment的startActivityForResult()方法，同时重写fragment的onActivityResult()方法（不是activity的）；</strong></p></li>
<li><p><strong>fragment没有setResult()方法，无法设置返回数据，只能通过托管的activity间接进行设置，即<code>getActivity().setResult(Activity.RESULT_OK,intent);</code></strong></p></li>
</ul>

<h4 id="toc_20">10.5 深入学习：为何要用fragment argument</h4>

<ul>
<li><p>使用fragment argument而不是直接在fragment定义变量进行保存数据，可以避免系统重建fragmen时的数据保存问题；</p></li>
<li><p>对上述情况也可以使用onSaveInstanceState(Bundle)进行状态保存，但是维护起来麻烦，还需要再从onCreate(Bundle)的Bundle中获取；</p></li>
</ul>

<h3 id="toc_21">第11章 使用ViewPager</h3>

<h4 id="toc_22">11.1 创建CrimePagerActivity</h4>

<ul>
<li><p>和RecyclerView、ConstraintLayout类似，ViewPager来自于支持库（android.support.v4.view.ViewPager）；在SDK的后续版本，Google没有在标准库中实现ViewPager类；</p></li>
<li><p>ViewPager在某种程度上类似于RecyclerView；ViewPager也需要Adapter（<code>PagerAdapter</code>）的支持提供视图，只不过PagerAdapter的处理比较复杂；</p></li>
<li><p><strong>Google提供了PagerAdapter简易的子类<code>FragmentStatePagerAdapter</code>：</strong></p>

<ul>
<li><strong>提供了有两个方法<code>getCount()</code>、<code>getItem(int)</code>；</strong></li>
<li><p><strong>在getItem(int)方法中可以获取指定位置的数据，并配置到相关的fragment上，并返回该fragment；该fragment会被添加到activity上（现在使用viewpager显示fragment，之前使用的是framelayout）；</strong></p></li>
<li><p>FragmentStatePagerAdapter构造时需要传入FragmentManager对象；</p>

<pre><code class="language-java">mViewPager.setAdapter(new FragmentStatePagerAdapter(fragmentManager) { 
    // ... 
});
</code></pre></li>
</ul></li>
<li><p>ViewPager默认加载当前屏幕上的列表项以及左右相邻的数据，因此响应迅速；调用<code>setOffscreenPageLimit(int)</code>方法定制预加载相邻页面的数目；</p></li>
<li><p>ViewPager默认显示PagerAdapter中的第一个列表项；调用<code>mViewPager.setCurrentItem(i)</code>方法则可以从显示特定位置的page；</p></li>
</ul>

<h4 id="toc_23">11.2 FragmentStatePagerAdapter与FragmentPagerAdapter</h4>

<ul>
<li>FragmentPagerAdapter是另外一种可用的PagerAdapter，其用法与FragmentStatePagerAdapter基本一样；唯一的区别在于，卸载不再需要的fragment时，各自采用的处理方法有所不同；

<ul>
<li>FragmentStatePagerAdapter会销毁不需要的fragment；在销毁fragment时，可在onSaveInstanceState(Bundle)方法中保存fragment的Bundle信息，用户切换回来时，保存的实例状态可用来生成新的fragment；</li>
<li>FragmentPagerAdapter不会销毁不需要的fragment，而是调用事务的detach(Fragment)方法处理，只是销毁了fragment的视图，fragment实例还保留在FragmentManager中，永远不会被销毁；其消耗内存但更安全些；</li>
</ul></li>
</ul>

<h4 id="toc_24">11.3 深入学习：ViewPager的工作原理</h4>

<ul>
<li><p><strong>当ViewPager托管的不是fragment视图时，就需要实现原生的PagerAdapter接口，比如在ViewPager中托管图片这样的常见视图对象；</strong></p></li>
<li><p><strong>使用ViewPager而不是RecyclerView的原因：当RecyclerView要求Adapter提供fragment视图时，我们无法立即创建fragment并提供其视图（决定fragment视图何时创建的是FragmentManager）；</strong></p></li>
<li><p>ViewPager使用的是PagerAdapter，PagerAdapter比原来的Adapter复杂得多，它要处理更多视图工作；其内部原理是不使用可返回视图的<code>onBindViewHolder(...)</code>方法，而是使用下列方法：</p>

<ul>
<li>a. <code>public Object instantiateItem(ViewGroup container, int position)</code>：告诉pager adapter创建指定位置的列表项视图，并将其添加到ViewGroup视图容器中；该方法并不要求<code>立即</code>创建视图，pager adapter可自行决定何时创建；</li>
<li>b. <code>public void destroyItem(ViewGroup container, int position, Object object)</code>：告诉pager adapter销毁已建视图；</li>
<li><p>c. <code>public abstract boolean isViewFromObject(View view, Object object)</code>：视图创建完成后，ViewPager会在某个时间注意到它；为确定视图视图所属于的对象，ViewPager会会调用该方法；参数object是instantiateItem(ViewGroup,int)方法返回的对象；若view对象是object对象的视图则应该返回true，否则返回false；</p>

<pre><code class="language-java">@Override
public boolean isViewFromObject(View view, Object object) {
    return ((Fragment)object).getView() == view;
}
</code></pre></li>
</ul></li>
</ul>

<h4 id="toc_25">11.4 深入学习：以代码的方式创建视图</h4>

<ul>
<li><p>通过布局文件创建视图，也可以在代码里创建视图；以代码的方式创建视图很简单：调用视图类的构造方法，并传入Context参数；但是不建议使用代码创建，不利于控制层和视图层分离、Android的资源系统适配（横竖屏）；</p>

<pre><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState); ViewPager viewPager = new ViewPager(this); setContentView(viewPager);
    ...
}
</code></pre></li>
</ul>

<h4 id="toc_26">11.5 挑战练习：恢复CrimeFragment的边距</h4>

<ul>
<li>ViewPager的布局参数是不支持边距设置<code>android:layout_margin</code>；</li>
</ul>

<h3 id="toc_27">第12章 使用对话框</h3>

<h4 id="toc_28">12.0 概述</h4>

<ul>
<li>AppCompat库就是能将部分最新系统的特色功能移植到旧版本的Android系统中；比如让新旧系统展示风格一致的对话框（AlertDialog），AppCompat库和系统都有该类的实现，为了能兼容旧版本系统可以引入<code>android.support.v7.app.AlertDialog</code>依赖项；</li>
</ul>

<h4 id="toc_29">12.1 创建DialogFragment</h4>

<ul>
<li><p><strong>建议将<code>AlertDialog</code>封装到<code>DialogFragment</code>（Fragment子类）实例中使用，而不是直接使用AlertDialog；因为使用FragmentManager可以更灵活地管理对话框；另外当设备旋转时，单独使用的AlertDialog会消失，而封装到fragment中的AlertDialog会被重建恢复；</strong></p></li>
<li><p>DialogFragment的<code>public Dialog onCreateDialog(Bundle savedInstanceState)</code>方法：需要重写该方法返回一个Dialog对象；</p>

<pre><code class="language-java">public class DatePickerFragment extends DialogFragment { 
    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        // TODO
    }
}
</code></pre></li>
<li><p><strong><code>AlertDialog.Builder</code>类传入context构造一个AlertDialog.Builder实例，之后可以调用以下相关配置方法，最后调用create()方法返回配置完成的AlertDialog实例，完成对话框的创建；</strong></p>

<pre><code class="language-java">View v = LayoutInflater.from(getActivity()).inflate(R.layout.dialog_date, null);
AlertDialog dialog = new AlertDialog.Builder(getActivity())
        .setView(v)
        .setTitle(R.string.date_picker_title)
        .setPositiveButton(android.R.string.ok, null)
        .create();
</code></pre>

<ul>
<li>a. <code>public AlertDialog.Builder setTitle(int titleId)</code>：设置标题；</li>
<li>b. <code>public AlertDialog.Builder setPositiveButton(int textId, DialogInterface.OnClickListener listener)</code>：设置positive按钮，参数为字符串资源（Android的OK常量）和实现DialogInterface. OnClickListener接口的对象；</li>
<li>c. <code>public AlertDialog.Builder setView(View view)</code>：在标题栏与按钮之间显示传入的View对象，比如DatePicker布局；view对象可以直接创建，也可以定义XML布局文件后通过LayoutInflater创建（该方式调整显示内容更灵活）；</li>
</ul></li>
<li><p>Android有3种可用于对话框的按钮：positive按钮、negative按钮、neutral按钮；若同一对话框上放置有多个按钮，按钮的类型与命名决定着它们在对话框上显示的位置；</p></li>
<li><p>和其他fragment一样，DialogFragment实例也是由托管activity的FragmentManager管理的；要将DialogFragment添加给FragmentManager管理并放置到屏幕上，可调用该fragment实例的以下方法：</p>

<pre><code class="language-java">public void show(FragmentManager manager, String tag)
public void show(FragmentTransaction transaction, String tag)

// String参数可唯一识别FragmentManager队列中的DialogFragment
// 若传入manager参数则是系统自动创建提交事务，若传入transaction参数则是手动创建并提交事务
</code></pre></li>
<li><p><strong><code>onSaveInstanceState(...)方</code>法默认情况自动只保存具有ID属性的视图的运行状态；为了应对旋转屏幕导致view销毁重建的问题，必须设置ID属性（即使不调用findViewById方法去获取配置该view）；比如AlertDialog对象中设置的view；</strong></p></li>
</ul>

<h4 id="toc_30">12.2 fragment间的数据传递</h4>

<ul>
<li><p><strong>之前已经实现了activity之间、基于fragment的activity之间的数据传递，现在需要实现在同一activity托管的不同fragment间的数据传递；</strong></p></li>
<li><p><strong>数据的正向传递：</strong></p>

<ul>
<li><strong>处理方式和<code>基于fragment的activity之间的数据传递</code>的一样，使用<code>fragment argument</code>；</strong></li>
<li>在fragment中添加一个静态方法，该方法中完成fragment、bundle及setArguments()的操作，参数为需要保存fragment中的参数；需要该fragment时使用该静态方法进行创建并传入必要的数据；</li>
</ul></li>
<li><p><strong>数据的逆向传递：</strong></p>

<ul>
<li><strong>之前的场景的处理方式是：我们先调用父activity或fragment的startActivityForResult()方法，<code>Activity Manager负责跟踪管理activity父子关系</code>，之后数据逆向传递时子activity被销毁，系统知道接收数据收数据的是哪个activity，<code>主动回调</code>父activity（ActivityManager）和fragment（FragmentManager）的onActivityResult()方法；</strong></li>
<li><p><strong>当前场景下（同一activity托管的不同fragment间）：无法调用startActivityForResult()方法；类似于activity间的关联，可以<code>人为的给不同fragment设置关联关系（目标fragment）</code>，之后数据逆向传递时子fragment被销毁，我们知道接收数据收数据的是哪个fragment，再<code>人为手动调用</code>父fragment（目标fragment）的onActivityResult()方法（参数所需要的信息我们都有）；</strong></p>

<pre><code class="language-java">public void setTargetFragment(Fragment fragment, int requestCode)
// requestCode: 目标fragment（父fragment）用来区分是哪个fragment在回传数据
</code></pre>

<pre><code class="language-java">FragmentManager manager = getFragmentManager();
DatePickerFragment dialog = DatePickerFragment
    .newInstance(mCrime.getDate());
dialog.setTargetFragment(CrimeFragment.this, REQUEST_DATE); // 设置目标fragment，用于回传数据
dialog.show(manager, DIALOG_DATE);
</code></pre></li>
<li><p><strong>目标fragment和requestCode由FragmentManager负责跟踪管理，可调用fragment(子fragment，设置了<code>目标fragment</code>的fragment)的<code>getTargetFragment()</code>方法和<code>getTargetRequestCode()</code>方法获取；</strong></p></li>
</ul></li>
<li><p><strong>使用<code>人为手动调用</code>父fragment（目标fragment）的onActivityResult()方法回传数据的方式视图展示更具灵活性、数据处理更具统一性；不论启动子activity还是显示对话框，fragment的onActivityResult(...)方法总会被调用；</strong></p></li>
<li><p><strong>为了更灵活地展示DialogFragment的视图，比如全屏形式展示，可以覆盖DialogFragment的onCreateView()方法，而不是onCreateDialog()方法来实现；</strong></p></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android编程权威指南 笔记(01~06)]]></title>
    <link href="http://www.justisit.com/15221600755364.html"/>
    <updated>2018-03-27T22:14:35+08:00</updated>
    <id>http://www.justisit.com/15221600755364.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">第1章 Android开发初体验</a>
<ul>
<li>
<a href="#toc_1">1.4 用户界面设计</a>
</li>
<li>
<a href="#toc_2">1.5 从布局XML到视图对象</a>
</li>
<li>
<a href="#toc_3">1.6 组件的实际应用</a>
</li>
<li>
<a href="#toc_4">1.7 创建提示消息</a>
</li>
<li>
<a href="#toc_5">1.9 深入学习：Android编译过程</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">第2章 Android与MVC设计模式</a>
<ul>
<li>
<a href="#toc_7">2.1 创建新类</a>
</li>
<li>
<a href="#toc_8">2.2 Android与MVC设计模式</a>
</li>
<li>
<a href="#toc_9">2.6 添加图标资源</a>
</li>
<li>
<a href="#toc_10">2.9 挑战练习：从按钮到图标按钮</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">第3章 activity的生命周期</a>
<ul>
<li>
<a href="#toc_12">3.0. 概述</a>
</li>
<li>
<a href="#toc_13">3.1 日志跟踪理解activity生命周期</a>
</li>
<li>
<a href="#toc_14">3.2 设备旋转与activity生命周期</a>
</li>
<li>
<a href="#toc_15">3.3 保存数据以应对设备旋转</a>
</li>
<li>
<a href="#toc_16">3.4 再探activity生命周期</a>
</li>
<li>
<a href="#toc_17">3.5 深入学习：activity内存清理现状</a>
</li>
</ul>
</li>
<li>
<a href="#toc_18">第4章 Android应用的调试</a>
<ul>
<li>
<a href="#toc_19">4.1 异常与栈跟踪</a>
</li>
<li>
<a href="#toc_20">4.2 Android特有的调试工具</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">第5章 第二个activity</a>
<ul>
<li>
<a href="#toc_22">5.1 创建第二个activity</a>
</li>
<li>
<a href="#toc_23">5.2 启动activity</a>
</li>
<li>
<a href="#toc_24">5.3 activity间传递数据</a>
</li>
<li>
<a href="#toc_25">5.4 activity的使用与管理</a>
</li>
</ul>
</li>
<li>
<a href="#toc_26">第6章 第Android SDK版本与兼容</a>
<ul>
<li>
<a href="#toc_27">6.1 Android SDK版本</a>
</li>
<li>
<a href="#toc_28">6.2 Android编程与兼容性问题</a>
</li>
<li>
<a href="#toc_29">6.3 使用Android开发者文档</a>
</li>
</ul>
</li>
</ul>


<span id="more"></span><!-- more -->   

<h3 id="toc_0">第1章 Android开发初体验</h3>

<h4 id="toc_1">1.4 用户界面设计</h4>

<ul>
<li><p>布局XML文件的根元素组件必须指定Android XML资源文件的命名空间属性xmlns:android（此处属性值为<code>http://schemas.android.com/apk/res/android</code>）；</p></li>
<li><p>android:layout_width、layout_height属性：</p>

<ul>
<li>match_parent：视图与其父视图大小相同，(之前已废弃的fill_parent等价于此）；</li>
<li>wrap_content：视图根据其显示内容自动调整大小；</li>
</ul></li>
<li><p>字符串资源</p>

<ul>
<li><p>一个默认名称为string.xml（可取其他名称）的XML文件，存放在app/res/valus/目录下；</p>

<pre><code>&lt;/resources&gt;&lt;string name=&quot;true_button&quot;&gt;True&lt;/string&gt;&lt;/resources&gt;
</code></pre></li>
<li><p>一个项目也可以有多个字符串文件，只需将这些文件放app/res/valus/目录下，含有一个resources根元素及多个string子元素即可，应用就能找到并正确使用它们；</p></li>
<li><p>定义好后，引用时使用@string/NAME；</p></li>
</ul></li>
</ul>

<h4 id="toc_2">1.5 从布局XML到视图对象</h4>

<ul>
<li><p>AppCompatActivity是Activity的一个子类，为了Android旧系统提供兼容性支持；</p></li>
<li><p>Activity的<code>public void setContentView(int layoutResID)</code>方法：根据传入的布局资源ID，生成该布局的视图，其包含的组件也随之实例化，并放置在屏幕上；</p></li>
<li><p>资源是应用非代码形式的内容（如图片、音频、XML文件），都放置app/res的子目录下，布局资源文件在app/res/layout下，字符串资源文件在res/values下；</p></li>
<li><p><strong>可以使用资源ID在代码中获取相应的资源，如R.layout.activity_quiz（activity_quiz.xml的资源ID）、R.string.app_name</strong>；</p></li>
<li><p>R.java文件是项目中自动生成的包含所有资源ID；修改相关资源后，R.java会自动更新（有时失效）；</p></li>
<li><p><strong>Android自动为布局文件、各个字符串生成资源ID，但是布局文件中的组件需要手动设置<code>android:id</code>属性后才生成相应的资源ID；</strong></p>

<ul>
<li><strong>在设置该属性值时，需要添加+标示，如android:id=&quot;@+id/true_button&quot;；</strong></li>
<li><strong>布局文件中引用时则不需要添加+，如@id/true_button；</strong></li>
<li><strong>代码中引用时使用<code>R.id.xxx</code>，如R.id.true_button；</strong></li>
</ul></li>
</ul>

<h4 id="toc_3">1.6 组件的实际应用</h4>

<ul>
<li><p>Activity的<code>public View findViewById(int id)</code>：根据资源ID返回已生成的组件视图对象（注意要类型转换）；</p></li>
<li><p>Android应用属于典型的事件驱动类型，应用启动后即开始等待行为事件的发生；为响应某个事件而创建的对象叫作监听器，监听器就是实现特定监听接口的对象，比如监听点击事件，需要实现View.OnClickListenter接口；</p></li>
<li><p><code>btn.setOnClickListener(OnClickListener)</code>就是给btn设置监听对象，建议使用<code>匿名内部类</code>来实现监听对象；</p></li>
</ul>

<h4 id="toc_4">1.7 创建提示消息</h4>

<ul>
<li><p>Toast类的<code>public static Toast makeText(Context context, int resId, int duration)</code>：</p>

<ul>
<li>context参数通常是Activity的一个实例（Activity本身就是Context的子类）；</li>
<li>resId参数是toast要显示字符串消息的资源ID（Toast必须借助context才能找到并使用字符串的资源ID）；</li>
<li>duration参数同时是两个Toast常量的一个，用来指定停留时间；</li>
<li>创建一个toast；之后再调用show()方法在屏幕上显示Toast消息；</li>
</ul></li>
<li><p><strong>在匿名内部类中调用Toast的makeText()方法时，注意传入的context参数不能是this（此时的this是匿名类监听器），应该是XXActivity.this；</strong></p></li>
</ul>

<h4 id="toc_5">1.9 深入学习：Android编译过程</h4>

<ul>
<li><p>在XXActivity类的onCreate()方法中调用setContentView()方法时：XXActivity会使用LayoutInflater类实例化布局文件中定义的每一个View对象（基于反射机制）；</p></li>
<li><p>处理在XML文件中定义视图外，也可以在Activity中使用代码创建视图类（但是建议展现层与逻辑层分离）；</p></li>
</ul>

<h3 id="toc_6">第2章 Android与MVC设计模式</h3>

<h4 id="toc_7">2.1 创建新类</h4>

<ul>
<li>生成getter、setter方法注意事项：

<ul>
<li>Android的命名规范是变量以m前缀、静态量以s前缀；若直接Generate Getter and Setter则生成getter、setter方法时会带相关前缀，如getMText()、setMText()；</li>
<li>Setting-&gt;Editor-&gt;Code Style-&gt;Java-&gt;Code Generation勾选“Prefer longer names”并在相应项输入m、s，取消生成代码时带相关m、s前缀；</li>
</ul></li>
</ul>

<h4 id="toc_8">2.2 Android与MVC设计模式</h4>

<ul>
<li>Android中的MVC

<ul>
<li>M通常是我们创建的定制类，V是Android自带的视图类和我们定制开发的视图类，C是Activity、Fragment、Service子类；</li>
<li>M对象与V对象是不能直接交互的；</li>
</ul></li>
</ul>

<h4 id="toc_9">2.6 添加图标资源</h4>

<ul>
<li><p>图标资源主要分为以下像素密度屏幕：mdpi（约160dpi）、hdpi（约240dpi）、xhdpi（约320dpi）、xxhdpi（约480dpi）；</p></li>
<li><p>所有大小的图片资源都会被安装在设备中，Android系统知道如何为不同设备提供最佳匹配；若应用不包含设备对应的像素密度的图片，Android系统在运行时会自动找可到可用的图片资源，并针对该设备进行适配；</p></li>
<li><p>将不同像素密度的图片资源（文件名必须是小写且无空格，后缀名为png、jpg、gif）放到对应的res/drawable-mdpi、drawable-hdpi、drawable-xhdpi、drawable-xxhdpi目录中，Android会自动为其分配资源ID；图片资源ID不需要按照屏幕密度匹配引用，系统知道如何显示，直接引用即可；</p></li>
<li><p><strong>在XML资源文件中，通过资源类型和资源名称，可引用其他资源；比如，以@string/开头的定义是引用字符串资源，以@drawable/开头的定义是引用drawable资源；</strong></p></li>
</ul>

<h4 id="toc_10">2.9 挑战练习：从按钮到图标按钮</h4>

<ul>
<li>ImageButton继承于ImageView，Button继承于TextView；</li>
</ul>

<h3 id="toc_11">第3章 activity的生命周期</h3>

<h4 id="toc_12">3.0. 概述</h4>

<ul>
<li><p>每个Activity实例都有其生命周期，其在运行（前台可见）、暂停（可见）、停止（不可见）状态间进行转换；</p></li>
<li><p>每次状态转换都会有对应的Activity方法将状态改变的消息通知给activity（onCreate、onStart、onResume、onPause、onStop、onDestroy这些方法由系统调用，不可自己手动调用；覆盖这些方法时需先调用super方法）；</p></li>
<li><p>通常重写onCreate(Bundle)方法，进行实例化组件并将它们放置在屏幕上（调用setContentView(int)方法）、引用已实例化的组件、为组件设置监听器以处理用户交互、访问外部模型数据；</p>

<p><img src="media/15221600755364/activity_life.png" alt="activity_life" style="width:423px;"/></p></li>
</ul>

<h4 id="toc_13">3.1 日志跟踪理解activity生命周期</h4>

<ul>
<li><p>Android的android.util.Log类能够发送日志信息到系统级别的共享日志中心，其有几个日志记录方法，比如<code>public static int d(String tag, String msg)</code></p></li>
<li><p>实例解析</p>

<ul>
<li>a. Activity启动时，依次调用<code>onCreate、onStart、onResume方法</code>；</li>
<li>b. 按Home键后，依次调用<code>onPause、onStop方法</code>；（Activity不销毁，能存活多久无法保证，系统回收内存时会先销毁那些停止的Activity；系统Settings中启用Don’t keep activities选项，此时也会调用onDestroy方法）</li>
<li>c. 从最近应用列表中启动，依次调用<code>onStart、onResume方法</code>；</li>
<li>d. 按退出键，依次调用<code>onPause、onStop、onDestroy方法</code>，Activity被销毁；</li>
<li>e. 关闭屏幕，处理方式和按Home键一样；</li>
</ul></li>
<li><p><strong>若当前Activity界面被完全或部分遮挡（如弹出窗口），那么其会被系统暂停，用户无法同其交互，弹出窗口关闭后会继续运行；</strong></p></li>
</ul>

<h4 id="toc_14">3.2 设备旋转与activity生命周期</h4>

<ul>
<li><p>旋转设备会改变<code>设备配置（Device Configuration）</code>；设备配置是用来描述设备当前状态的一系列特征（屏幕方向、密度、尺寸、键盘类型、底座模式、语言等）；</p></li>
<li><p>为匹配不同的设备配置，应用会提供不同的备选资源，如适配屏幕分辨率添加多套图片资源；</p></li>
<li><p>在运行过程中，设备配置发生改变会触发使用<strong>可能存在的更合适的资源</strong>来匹配新的设备配置，如旋转屏幕会加载新的布局文件，即当前的Activity被销毁并重新创建；注意有些设备配置是固定的，比如屏幕密度；</p></li>
<li><p>创建水平模式布局：</p>

<ul>
<li><strong>a. 右键点击res目录后，选择新建<code>Android resource directory</code>，<code>Resource type</code>选择<code>layout</code>，<code>Source Set</code>保持<code>main</code>不变；</strong></li>
<li><strong>b. 将<code>Available qulifiers</code>中的<code>Orientation</code>移到选择区中，之后<code>Screen Orientation</code>选择<code>Landscape</code>，并确保目录名显示为<code>layout-land</code>；</strong></li>
<li><strong>c. 点击OK即创建了res/layout-land，land后缀名是配置修饰符的一个例子；</strong></li>
<li><strong>d. 之后就可以在res/layout-land创建水平模式的布局文件了（或者从res/layout中复制布局文件再修改）；</strong></li>
</ul></li>
<li><p>当设备处于水平方向时，系统会在res/layout-land目录中寻找布局资源，若没有则使用res/layout目录下的；其他情况在res/layout目录下寻找；</p></li>
<li><p><strong>不同屏幕方向的布局资源文件必须是相同的文件名，这样才能以同一资源ID被引用；</strong></p></li>
<li><p>FrameLayout子视图的位置排列取决于它们各自的android:layout_gravity属性；</p></li>
</ul>

<h4 id="toc_15">3.3 保存数据以应对设备旋转</h4>

<ul>
<li><p>在应用运行中，只要设备配置发生变化，Android就销毁当前activity并再创建新的activity；</p></li>
<li><p><strong>activity的<code>protected void onSaveInstanceState(Bundle outState)</code>方法（注意别重写错了）：</strong></p>

<ul>
<li><strong>在按Home键、设置配置发生变化后两种情况下，activity在调用onStop()方法之前系统都会调用此方法；</strong></li>
<li><strong>按后退键不会，按后退键表示告诉Android该activity完了要将其从内存中抹掉，自然也就没有必要重建保存数据了；</strong></li>
<li><strong>该方法的默认实现就是将所有activity视图的状态数据保存在Bundle对象中；</strong></li>
</ul></li>
<li><p>Bunle是存储字符串键与限定类型（基本数据类型、实现Serializable/Parcelable接口的对象）值之间映射关系（键值对）的一种结构，相关方法如putInt、getInt；</p></li>
<li><p><strong>不建议在Bundle中保存定制类对象，因为取回的对象可能已经过时了</strong>；</p></li>
<li><p><strong>可通过覆盖onSaveInstanceState()方法，将一些数据保存在bundle中，然后在onCreate()方法中取回这些数据；比如处理屏幕旋转的数据保存；</strong></p></li>
</ul>

<h4 id="toc_16">3.4 再探activity生命周期</h4>

<ul>
<li><p><strong>重写onSaveInstanceState()方法不仅仅用于处理与设备旋转相关的问题</strong>，也可以处理以下场景：</p>

<ul>
<li>当用户离开当前activity用户界面，或Android需要回收内存时activity被销毁（如用户按了HOME后播放视频或玩游戏）；</li>
<li>Android从不会为了回收内存去销毁正在运行的activity（处于运行或暂停状态），而是会销毁处于停止状态的activity；</li>
<li><strong>此时不用担心数据丢失，系统会调用onSaveInstanceState()方法将用户数据保存到Bundle对象中，之后系统会将该Bundle对象放入<code>activity记录</code>中；</strong></li>
<li><strong>在需要恢复activity时，操作系统可以使用暂存的<code>activity记录</code>重新激活activity；</strong></li>
</ul></li>
<li><p><strong>注意，activity进入<code>暂存状态</code>并不一定需要调用onDestroy()方法；因此常见的做法是：</strong></p>

<ul>
<li><strong>重写onSaveInstanceState()方法，在Bundle对象中保存当前activity的小的或暂存状态的数据；</strong></li>
<li><strong>重写onStop()方法，保存永久性数据，如用户编辑的文字等；onStop()方法被调用后，activity随时可能会被系统销毁，所以用它保存永久性数据；</strong></li>
</ul></li>
<li><p><strong>当用户按了后退键后，系统会彻底销毁当前的activity，此时暂存的activity记录也被清除；此外系统重启，暂存的activity记录也会被清除；</strong></p></li>
</ul>

<h4 id="toc_17">3.5 深入学习：activity内存清理现状</h4>

<ul>
<li><strong>低内存状态下，Android直接从内存清除整个应用进程（包含所有的activity），目前还做不到只销毁单个activity；</strong></li>
</ul>

<h3 id="toc_18">第4章 Android应用的调试</h3>

<h4 id="toc_19">4.1 异常与栈跟踪</h4>

<ul>
<li>调试方法

<ul>
<li>a. 查看异常调用栈；</li>
<li>b. 使用Log；</li>
<li>c. 使用断点（Run-&gt;View Breakpoints管理断点，
也可以设置异常断点捕获特定类型的异常）;</li>
</ul></li>
</ul>

<h4 id="toc_20">4.2 Android特有的调试工具</h4>

<ul>
<li><p>Android Lint：</p>

<ul>
<li>静态分析器，检查所有潜在的问题，比如使用错误的资源ID导致错误的类型转换， <code>mButton= (Button)findViewById(R.id.a_text_view);</code>；</li>
<li>Anylyze-&gt;Inspect Code手动运行Android Lint；</li>
</ul></li>
<li><p>R文件错误处理方式：</p>

<ul>
<li>a. 检查资源文件XML的有效性；</li>
<li>b. 清理工程；</li>
<li>c. 使用Gradle同步项目；</li>
<li>d. 运行Android Lint检查；</li>
</ul></li>
</ul>

<h3 id="toc_21">第5章 第二个activity</h3>

<h4 id="toc_22">5.1 创建第二个activity</h4>

<ul>
<li><p>创建新的activity至少涉及三个文件：Java类、XML布局和应用的manifest文件；</p></li>
<li><p><code>tools:text属性</code>用于在Android Studio中预览TextView的显示，运行时显示还是使用<code>android:text属性</code>；</p></li>
<li><p>项目的app/manifest目录中的AndroidManifest.xml是用来向Android操作系统描述应用信息，比如声明activity：<code>&lt;activity android:name=&quot;.XXActivity&quot;&gt;&lt;/activity&gt;</code>，name可取完整包路径，也可取.类名；</p></li>
</ul>

<h4 id="toc_23">5.2 启动activity</h4>

<ul>
<li><p>activity的<code>public void startActivity(Intent intent)</code></p>

<ul>
<li>一个activity启动另外一个activity的最简单的方式；</li>
<li>调用请求会发给了操作系统的ActivityManager，ActivityManager负责创建Activity实例并调用其onCreate()方法；</li>
<li>参数intent标示启动哪个Activity；</li>
</ul></li>
<li><p><strong>Intent对象是Component用于与操作系统通信的一种媒介工具；Component有activity、service、broadcast receiver、content provider；</strong></p></li>
<li><p>构造函数<code>public Intent(Context packageContext, Class&lt;?&gt; cls)</code>：</p>

<ul>
<li>Class参数告诉ActivityManager启动哪个activity（其会先检查指定的Class是否在manifest配置文件中声明过，若没有则抛出ActivityNotFoundException异常）；</li>
<li>Context参数告诉ActivityManager在哪里可以找到它；</li>
</ul></li>
<li><p><strong>显式与隐式Intent</strong></p>

<ul>
<li><strong>通过指定Context与Class对象，然后调用intent的构造方法来创建Intent，则创建的是显式Intent；同一应用中使用显式Intent来启动activity；</strong></li>
<li><strong>一个应用的activity若需要启动另一个应用的activity，可以通过创建隐式Intent来处理；</strong></li>
</ul></li>
</ul>

<h4 id="toc_24">5.3 activity间传递数据</h4>

<ul>
<li><p><strong>intent extra（传递数据的媒介）：</strong></p>

<ul>
<li>extra可以是任意数据，其为包含在Intent中的键值结构数据；</li>
<li>可以添加多个extra到同一个intent上；</li>
<li><strong>调用intent的<code>public Intent putExtra(String name, boolean value)</code>给intent添加数据，一个参数是固定的String类型的键，另一个参数值可以是多种数据类型，该方法返回intent自身（可以进行链式编程）；</strong></li>
<li><strong>调用intent的<code>public boolean getBooleanExtra(String name, boolean defaultValue)</code>获取extra中的数据；</strong></li>
</ul></li>
<li><p><strong>子activity从父activity获取信息：</strong></p>

<ul>
<li><strong>调用子activity的<code>getIntent()</code>方法获取由startActivity(Intent)、startActivityForResult(Intent intent, int requestCode)方法转发的Intent对象；之后从中获取信息；</strong></li>
<li><strong>常用场景技巧：在子activity中创建一个生成intent的静态方法，来提供给父activity调用，这样就不用关心父activity的来源及extra中键的定义，也提高了封装性；</strong></li>
</ul></li>
<li><p><strong>父activity从子activity获取返回信息：</strong></p>

<ul>
<li><p><strong>第一步、调用父activity的<code>public void startActivityForResult(Intent intent, int requestCode)</code>方法启动子activity；</strong></p>

<ul>
<li><strong>第一参数Inttent同上述；</strong></li>
<li><strong>第二个参数为<code>请求代码</code>；请求代码是先发送给子 activity，然后再返回给父activity的整数值，由用户定义；在一个activity启动多个不同类型的子activity，且需要判断消息回馈方时就会用请求代码requestCode；</strong></li>
</ul></li>
<li><p><strong>第二步、实现子activity发送返回信息给父activity，有以下两种方法可用：</strong></p>

<ul>
<li><strong>a. 子activity调用<code>public final void setResult(int resultCode)</code>方法；</strong></li>
<li><strong>b. 子activity调用<code>public final void setResult(int resultCode, Intent data)</code>方法；</strong></li>
</ul></li>
<li><p><strong>resultCode</strong></p>

<ul>
<li><strong>用于父activity区分子activity的不同操作（如取消、确定等）；</strong></li>
<li>可以是预定义的常量<code>Activity.RESULT_OK</code>（-1，默认值）、<code>Activity.RESULT_CANCELED</code>（0），也可以是自定义的resultCode（写<code>Activity.RESULT_FIRST_USER</code>（1））；</li>
<li>子activity可以不调用setResult()方法；

<ul>
<li>若没有调用，则操作系统发送默认的resultCode（Activity.RESULT_OK）；</li>
<li>若没有调用且按了后退按钮，则操作系统发送Activity.RESULT_CANCELED；</li>
</ul></li>
</ul></li>
<li><p><strong>第三步、重写onActivityResult()方法来处理返回结果；点击返回键返回时，ActivityManager会调用父activity的<code>protected void onActivityResult(int requestCode, int resultCode, Intent data)</code>方法，参数来自于之前启动子activity设置的requestCode和子activity设置的resultCode、intent；</strong></p></li>
</ul></li>
<li><p><strong>startActivity与startActivityForResult的区别：</strong></p>

<ul>
<li><strong>startActivity：仅仅是启动另一个Activity，不会回退到原来的Activity；若想跳回则必须再次调用startActivity来启动原来的Activity；</strong></li>
<li><strong>startActivityForResult：按返回键可直接回退到原来的Activity，当子Activity执行完finish()方法后，会自动回调<code>父Activity的onActivityResult()</code>方法；</strong></li>
</ul></li>
<li><p>除了点击返回键退出外，还可以调用activity的finish()方法也能将子activity回退（回退栈弹出）；</p></li>
</ul>

<h4 id="toc_25">5.4 activity的使用与管理</h4>

<ul>
<li><p>manifest中，XXActivity声明intent-filter子元素被设置为<code>launcher activity</code>；</p>

<pre><code>&lt;intent-filter&gt; 
    &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; 
    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
&lt;/intent-filter&gt;
</code></pre></li>
<li><p>ActivityManager维护则一个非特定应用独享的<code>回退栈</code>，所有应用的activity都共享该回退栈；这也是ActivityManager被设计成操作系统级的activity管理器来负责启动应用activity的原因之一；</p></li>
<li><p>不局限于单个应用，回退栈作为一个整体共享给操作系统及设备使用；</p></li>
</ul>

<h3 id="toc_26">第6章 第Android SDK版本与兼容</h3>

<h4 id="toc_27">6.1 Android SDK版本</h4>

<ul>
<li>API版本与设备固件版本：

<ul>
<li>API 19：KitKat，Android 4.4；</li>
<li>API 21：Lollipop，Android 5.0；</li>
<li>API 22：Lollipop，Android 5.1；</li>
</ul></li>
</ul>

<h4 id="toc_28">6.2 Android编程与兼容性问题</h4>

<ul>
<li><p>应用模块的build.gradle文件有三个属性值：compileSdkVersion、minSdkVersion、targetSdkVersion；</p>

<ul>
<li>compileSdkVersion：独占该文件；</li>
<li>minSdkVersion、targetSdkVersion虽然也设置在该文件中，但它们的作用是覆盖和设置配置文件AndroidManifest.xml；</li>
</ul></li>
<li><p><strong>SDK最低版本（minSdkVersion）：</strong></p>

<ul>
<li>若设备上的系统版本低于该值，系统将拒绝该应用的安装；</li>
</ul></li>
<li><p><strong>SDK目标版本（targetSdkVersion）：</strong></p>

<ul>
<li>应用是为哪个API级别设计的，多数情况下目标版本就是最新发布的Android版本；</li>
<li>新发布的SDK版本可能会改变应用在设备上的显示方式，甚至连操作系统后台运行行为都会受到影响；</li>
<li><strong>降低SDK目标版本可以保证，即便运行在高于目标版本的设备上，应用的运行行为仍然和SDK目标版本保持一致，新版本的变化会被忽略；</strong></li>
</ul></li>
<li><p><strong>SDK编译版本（compileSdkVersion）：</strong></p>

<ul>
<li>该设置不会出现在AndroidManifest中；</li>
<li>minSdkVersion、targetSdkVersion会通知给操作系统，而compileSdkVersion只是开发者与编译器之间的私有信息，用于使用时、编译时查找SDK中的类和方法；</li>
<li><strong>当Android新版本发布时，更新SDK编译版本，就可以使用新版本引入的方法和类了；</strong></li>
</ul></li>
<li><p>修改build.gradle文件后，需要同步一下Gradle才能生效（Tools -&gt; Android -&gt; Sync Project with Gradle Files），之后项目重新编译；</p></li>
<li><p><strong>若minSdkVersion和compileSdkVersion的差异较大，由此带来兼容问题需要处理；比如，调用了KitKat（API 19）以后的SDK代码的应用，运行在KitKat设备上会崩溃；</strong></p></li>
<li><p>受益用于<code>Android Lint</code>，在低版本系统上调用高版本的API，Android Lint会提示编译错误；Analyze -&gt; Inspect Code手动触发Lint；解决办法：</p>

<ul>
<li>提高minSdkVersion；</li>
<li><p>将高版本API置于检查Android设备版本的条件语句中（运行时检查）；</p>

<pre><code class="language-java">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {
    // TODO
} else {
    // TODO
}
</code></pre></li>
</ul></li>
<li><p><strong>Build.VERSION.SDK_INT为当前运行的设备的版本， Build.VERSION_CODES.LOLLIPOP等常量表示常见的Android版本号；</strong> 版本号清单参看网页<code>http://developer.android.com/reference/android/os/Build. VERSION_CODES.html</code>；</p></li>
</ul>

<h4 id="toc_29">6.3 使用Android开发者文档</h4>

<ul>
<li><p>Android开发文档：分为设计（UI设计规范）、开发（SDK文档）、发布（应用市场发布），<code>http://developer.android.com/</code>；</p></li>
<li><p>开发参考文档左侧，可以选择<code>API level</code>进行高版本API的过滤；</p></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio配置使用]]></title>
    <link href="http://www.justisit.com/15230908846113.html"/>
    <updated>2018-04-07T16:48:04+08:00</updated>
    <id>http://www.justisit.com/15230908846113.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">一、配置</a>
</li>
<li>
<a href="#toc_1">二、使用</a>
</li>
<li>
<a href="#toc_2">三、快捷键</a>
</li>
</ul>


<h4 id="toc_0">一、配置</h4>

<ul>
<li><p>配置文件目录</p>

<ul>
<li>Configuration Path：~/Library/Preferences/<PRODUCT><VERSION>，删除该目录即还原默认配置</li>
<li>Caches Path：~/Library/Caches/<PRODUCT><VERSION></li>
<li>Logs Path：~/Library/Logs/<PRODUCT><VERSION></li>
</ul></li>
<li><p>禁止AS首次启动下载SDK：显示包内容，bin目录下的idea.properties增加<code>disable.android.first.run=true</code></p></li>
</ul>

<span id="more"></span><!-- more -->

<ul>
<li><p>Apperance&amp;Behavior</p>

<ul>
<li>主题（程序外观、文本编辑器）： Appearance --&gt; 修改Themes为Darcula</li>
<li>显示内存使用：Appearance --&gt; 勾选Show memory indicator</li>
<li>关闭打开上次工程：System Settings --&gt; 取消Reopen last...</li>
<li>关闭自动更新：System Settings --&gt; Updates --&gt; 取消Automatically check updates...</li>
</ul></li>
<li><p>Editor</p>

<ul>
<li>API文档悬浮提示：General --&gt; 勾选Show quick documentation...</li>
<li>自动导包：General --&gt; Auto Import --&gt; 勾选Add unambigous...、Optimize...</li>
<li>显示代码行数：General --&gt; Appearance --&gt; 勾选Show line numbers</li>
<li>代码自动提示（新版已默认）：General --&gt; Code Completion --&gt; Autopopup code completion，取消大小写敏感，设置Case sensitive completion为None</li>
<li>禁止代码自动折叠：General --&gt; Code Folding --&gt; 取消One-line methods、Closues...、Generic constructor...</li>
<li>文本编辑器字体：Colors&amp;Fonts --&gt; 修改Font（新版的内置Scheme也可直接修改不需要复制了）</li>
<li>Console字体：Colors&amp;Fonts --&gt;  修改Console Font</li>
<li>主题（文本编辑器）：Colors&amp;Fonts --&gt; 修改Scheme，第三方主题<a href="https://github.com/rainglow/jetbrains">https://github.com/rainglow/jetbrains</a></li>
<li>文件编码：File Endcodings（默认UTF-8）</li>
</ul></li>
</ul>

<h4 id="toc_1">二、使用</h4>

<ul>
<li>工程区别（AS --&gt; Eclipse）：project --&gt; workspace、module --&gt; project</li>
<li>AS 2.1版本开始，新建的Activity默认继承AppCompatActivity</li>
<li>修改grandle配置后，需要进行手动同步</li>
<li>引入第三方库

<ul>
<li>a. 通过将第三方jar包复制到工程的libs目录下，然后选中jar包，之后进行grandle同步</li>
<li>b. 通过配置grandle导入（易于升级）：右键Open Module Settings --&gt; Dependencies，点击 + 后，选择Library dependency，其会自动下载相关的lib</li>
</ul></li>
<li>删除module：需要先Open Module Settings删除对应module，之后右键才有delete选项，之后进行删除</li>
<li>Gradle使用：略</li>
<li>APK签名：略</li>
<li>APK混淆：略</li>
</ul>

<h4 id="toc_2">三、快捷键</h4>

<table>
<thead>
<tr>
<th>KeyMap名称</th>
<th>功能描述</th>
<th>快捷键</th>
</tr>
</thead>

<tbody>
<tr>
<td>Navigate/Class</td>
<td>打开类</td>
<td>CMD(⌘,) + O</td>
</tr>
<tr>
<td>Navigate/File</td>
<td>打开文件</td>
<td>CMD + SHIFT(⇧) + O</td>
</tr>
<tr>
<td>Navigate/File</td>
<td>快捷最近打开</td>
<td>CMD + E</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Recent Files</td>
<td>提示错误解决方案<br>(自动导包、自动生成Override方法)</td>
<td>Option(alt,⌥) + Enter</td>
</tr>
<tr>
<td>Parameter Info</td>
<td>提示参数类型</td>
<td>CMD + P</td>
</tr>
<tr>
<td>Insert Live Template</td>
<td>按照模板生成代码（如TAG）</td>
<td>CMD + J</td>
</tr>
<tr>
<td>Reformat Code</td>
<td>格式化代码</td>
<td>CMD + ⌥ + L</td>
</tr>
<tr>
<td>Optimize Imports</td>
<td>去除无效包引用</td>
<td>Control(⌃) + ⌥ + O</td>
</tr>
<tr>
<td>Code Generate</td>
<td>快速生成代码</td>
<td>CMD + N</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Declaration</td>
<td>查看声明</td>
<td>CMD + B</td>
</tr>
<tr>
<td>Super method</td>
<td>跳转到父类</td>
<td>CMD + U</td>
</tr>
<tr>
<td>Type Hierarchy</td>
<td>显示继承体系</td>
<td>⌃ + H</td>
</tr>
<tr>
<td>Call hierarchy</td>
<td>查找调用位置</td>
<td>⌃ + ⌥ + H</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Edit/Find/Find</td>
<td>文件内查找</td>
<td>CMD + F</td>
</tr>
<tr>
<td>Move To Next Occurrence</td>
<td>代码高亮向下查找</td>
<td>CMD + G</td>
</tr>
<tr>
<td>Move To Previous Occurrence</td>
<td>代码高亮向上查找</td>
<td>CMD + ⇧ + G</td>
</tr>
<tr>
<td>Find in Path</td>
<td>全局查找</td>
<td>CMD + ⇧ + F</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Preferences</td>
<td>AS配置界面</td>
<td>CMD + ,</td>
</tr>
<tr>
<td>Project Structure</td>
<td>工程项目配置界面</td>
<td>CMD + ;</td>
</tr>
</tbody>
</table>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitBook使用教程]]></title>
    <link href="http://www.justisit.com/15219669294797.html"/>
    <updated>2018-03-25T16:35:29+08:00</updated>
    <id>http://www.justisit.com/15219669294797.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">一、简介</a>
</li>
<li>
<a href="#toc_1">二、安装使用</a>
</li>
<li>
<a href="#toc_2">三、补充</a>
</li>
</ul>


<h4 id="toc_0">一、简介</h4>

<ul>
<li>GitBook是一个可以将Markdown文本一键生成为HTML、PDF、EPUB格式图书（需要安装安装calibre）的工具，其也内置使用Git对Markdown文件做版本控制；</li>
<li>可以在本地离线生成各种格式的图书，也可以在GitBook官网在线生成，便于共享；并且其也提供了一键导入GitHub仓库生成图书的便捷功能（一本图书就是一个Git仓库）；</li>
</ul>

<span id="more"></span><!-- more -->

<h4 id="toc_1">二、安装使用</h4>

<ul>
<li><p>1、安装Node.js、Git（可选；若需要版本控制、上传到GitBook则要安装）；</p></li>
<li><p>2、安装GitBook；</p>

<pre><code>npm install -g gitbook-cli

gitbook -V # 查看当前GitBook版本（注意是大写的V）
</code></pre></li>
<li><p>3、创建一本图书（本地）；</p>

<pre><code>gitbook init BOOK_NAME
</code></pre>

<ul>
<li>目录中自动生成README.md、SUMMARY.md两个文件；这两个文件是必须存在的，README.md为对图书的介绍，SUMMARY.md是对书籍目录的描述，之后就是根据该文件生成图书目录结构的；</li>
<li><p>SUMMARY.md格式如如下：</p>

<pre><code># Summary

* [简介](README.md)
* [第一章 基础](chapter1/chapter1_0.md)
    * [第一小节 基础概述](chapter1/chapter1_1.md)
    * [第二小节 基础介绍](chapter1/chapter1_2.md)
* [第二章 进阶](chapter2/chapter2_0.md)
    * [第一小节 进阶概述](chapter2/chapter2_1.md)
    * [第二小节 进阶介绍](chapter2/chapter2_2.md)
</code></pre></li>
<li><p>手动修改SUMMARY.md后，再执行 <code>gitbook init</code> 命令，会自动生成相应的文件及目录；</p></li>
</ul></li>
<li><p>4、书写相关Markdown文本；</p></li>
<li><p>5、编译、预览图书；</p>

<pre><code>gitbook serve # 在图片文件夹目录中执行
</code></pre>

<ul>
<li><code>gitbook serve</code> 会先调用 <code>gitbook build</code> 命令编译图书，之后会打开一个本地WEB服务器，打开网页即可预览图书HTML；</li>
</ul></li>
<li><p>6、安装calibre工具，生成PDF、EPUB格式图书；</p>

<ul>
<li>a. 下载安装Calibre（<code>https://calibre-ebook.com/download</code>）；</li>
<li><p>b. 配置ebook-convert的路径；</p>

<pre><code>// macOS
sudo ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin  
</code></pre></li>
<li><p>c. 执行<code>gitbook pdf</code>、<code>gitbook epub</code>分别生成PDF、EPUB格式图书；</p></li>
</ul></li>
</ul>

<h4 id="toc_2">三、补充</h4>

<ul>
<li>第3、4步操作可以通过 <code>Gitbook Editor</code> 桌面编辑器更便捷地进行文本书写（其会自动更新修改SUMMARY.md文件）；但是生成图书还是需要在终端下通过GitBook完成；</li>
<li>可以使用 <code>book.json</code> 文件定义GitBook在编译图书时的配置信息（如定义图书名称、显示效果等）；</li>
<li>执行 <code>gitbook install</code> 命令可以安装一些第三方的插件，如disqus等；</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS的静态库、动态库]]></title>
    <link href="http://www.justisit.com/15210408337160.html"/>
    <updated>2018-03-14T23:20:33+08:00</updated>
    <id>http://www.justisit.com/15210408337160.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">一、类库分类</a>
</li>
<li>
<a href="#toc_1">二、类库类型支持</a>
</li>
<li>
<a href="#toc_2">三、设备CPU架构</a>
</li>
<li>
<a href="#toc_3">四、资源文件处理</a>
</li>
<li>
<a href="#toc_4">五、补充知识</a>
</li>
</ul>


<h4 id="toc_0">一、类库分类</h4>

<ul>
<li>静态库：

<ul>
<li>.a二进制库：使用时还需要将.h头文件及资源文件（比如图片等）拖入到工程项目中，配置一些header、lib路径之类的；使用起来比较麻烦；</li>
<li>.framework库：Apple平台独有的，其本质是将.a库文件、.h头文件及资源文件打包在一起的包文件；使用时直接将其拖到工程项目中即可（或在 <code>Link Binary With Libraries</code> 中添加即可使用）；</li>
</ul></li>
<li>动态库：

<ul>
<li>.tdb库：Xcode 7（iOS9）开始使用，之前名称为.dylib；在 <code>Link Binary With Libraries</code> 中添加即可使用；</li>
<li>.framework库文件：在 <code>Link Binary With Libraries</code> 中添加即可使用；</li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->

<h4 id="toc_1">二、类库类型支持</h4>

<ul>
<li><p>Xcode 6（iOS8）之前：</p>

<ul>
<li><p>出于安全考虑，Xcode只支持创建.a静态库（注意需要将相关的.h头文件public出来）；不支持创建.framework静态库，但是可以通过第三方工具创建（如iOS-Universal-Framework），这种被称为伪（Fake）Framework；</p></li>
<li><p>一般情况下都使用第三方工具创建.framework静态库，因为这样之后使用起来比.a形式更方便；</p></li>
<li><p>Xcode也不支持创建任何形式的动态库；</p></li>
<li><p>.tdb/.dylib动态库、.framework动态库都是系统内置的（如libz.dylib、UIKit.framework），故开发者只能使用系统内置的动态库；</p>

<p><img src="media/15210408337160/xcode_5.png" alt="xcode_5" style="width:311px;"/></p></li>
</ul></li>
<li><p>Xcode 6（iOS8）开始：</p>

<ul>
<li>Xcode支持创建.a静态库、.framework静态库（修改Mach-O Type，默认为动态库）；</li>
<li><p><strong>Xcode也支持创建.framework动态库了，但这是一种特殊的动态库（使用时需要被添加到 <code>Embedded Binaries</code> 中，并且默认自动添加到Link Binary With Libraries中）；其只支持主程序和扩展程序共用该动态库，其他应用还是无法进行公共，这和系统的（如UIKit.framework）还是有着很大区别的；</strong></p>

<p><img src="media/15210408337160/xcode_6.png" alt="xcode_6" style="width:300px;"/></p></li>
</ul></li>
<li><p><strong>Xcode 6（iOS8）发布了Swift 1.0，但是Swift不支持静态库（.a、.framework），只支持动态库（.tdb/.dylib、.framework）；从Xcode 9开始，Swift 4.0支持静态库；</strong></p></li>
<li><p>CocoaPods在纯ObjC项目中，默认将第三方库源码编译成.a静态库集成到项目中；若含有Swift的类库则必须添加 <code>use_frameworks!</code> 标识（纯ObjC项目中也可以使用的），进而生成.framework动态库；</p></li>
<li><p>Carthage只支持生成.framework动态库（原因：Carthage是通过Swift语言编写而成的），故其支持的项目最低版本为8.0；</p></li>
</ul>

<h4 id="toc_2">三、设备CPU架构</h4>

<ul>
<li><p>CPU架构</p>

<ul>
<li>a. 模拟器：iPhone 4s~5c为i386，iPhone 5s~...为x86_64；</li>
<li>b. 真机：iPhone 3gs~4s为armv7，iPhone 5~5c为armv7s，iPhone 5s~...为arm64；静态库只要支持armv7，就可以运行在armv7s架构上；</li>
</ul></li>
<li><p>生成库类型</p>

<ul>
<li>a. 通过修改Xcode编译的目标设备，可以分别生成模拟器、真机的库；</li>
<li>b. 通过修改Xcode编译的Scheme的config，可以分别生成Debug、Release的库；</li>
<li>c. Xcode在Debug、模拟器情况下，默认只会生成Active平台的CPU架构，比如生成的模拟器的库只有x86_64架构（通过 <code>lipo -info</code> 命令查看）；修改Build Settings的 <code>Build Active Architecture Only</code> 为No，则生成所有的CPU架构；真机情况下为armv7、arm64两种架构(armv7s被Apple舍弃了)；</li>
<li>d. 可以使用 <code>lipo -create</code> 命令合并相关的库文件；</li>
</ul></li>
<li><p>通用（合成）库类型</p>

<ul>
<li><strong>使用Xcode编译一次只会生成一种类型的库，可以使用 <code>Aggregate Target</code> 生成多种类型的合成库；</strong></li>
<li><p>新建 <code>Aggregate Target</code> ，添加 <code>Run Script</code> ，填入以下类似内容（参考<code>http://blog.csdn.net/qq_16706275/article/details/45913269</code>）：</p>

<pre><code># Sets the target folders and the final framework product.
# 如果工程名称和Framework的Target名称不一样的话，要自定义FMKNAME
# 例如: FMK_NAME = &quot;MyFramework&quot;
FMK_NAME=${PROJECT_NAME}

# Install dir will be the final output to the framework.
# The following line create it in the root folder of the current project.
INSTALL_DIR=${SRCROOT}/Products/${FMK_NAME}.framework

# Working dir will be deleted after the framework creation.
WRK_DIR=build
DEVICE_DIR=${WRK_DIR}/Release-iphoneos/${FMK_NAME}.framework
SIMULATOR_DIR=${WRK_DIR}/Release-iphonesimulator/${FMK_NAME}.framework

# -configuration ${CONFIGURATION}
# Clean and Building both architectures.
xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphoneos clean build
xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphonesimulator clean build

# Cleaning the oldest.
if [ -d &quot;${INSTALL_DIR}&quot; ]
then
rm -rf &quot;${INSTALL_DIR}&quot;
fi

mkdir -p &quot;${INSTALL_DIR}&quot;
cp -R &quot;${DEVICE_DIR}/&quot; &quot;${INSTALL_DIR}/&quot;

# Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.
lipo -create &quot;${DEVICE_DIR}/${FMK_NAME}&quot; &quot;${SIMULATOR_DIR}/${FMK_NAME}&quot; -output &quot;${INSTALL_DIR}/${FMK_NAME}&quot;

rm -r &quot;${WRK_DIR}&quot;
open &quot;${INSTALL_DIR}&quot;
</code></pre></li>
</ul></li>
</ul>

<h4 id="toc_3">四、资源文件处理</h4>

<ul>
<li><p>对于.a静态库</p>

<ul>
<li><p>a. 因为无法在.a文件中存放资源文件，需要将资源文件打包放在一个后缀为.bundle的文件夹中；</p></li>
<li><p>b. 使用时需要手动添加.bundle到主项目中，之后通过以下方式使用：</p>

<pre><code class="language-objc">[UIImage iamgeNamed:&quot;A.bundle/test.png&quot;];
</code></pre></li>
</ul></li>
<li><p>对于.framework静、动态库</p>

<ul>
<li><p>a. .framework文件本质上也是一个bundle文件；</p></li>
<li><p>b. 可以将资源文件直接（或打包成bundle后）放在.framework文件中，也可以将资源文件打包成bundle后与.framework文件独立开来；</p></li>
<li><p>c. <strong>需要注意的是：Xcode在添加.framework到项目中的时候，不会添加.framework中的资源文件到项目中（添加bundle会自动添加的），故无法其中的资源无法使用；必须在 <code>Copy Bundle Resources</code> 中添加对应的.framework</strong>，之后通过以下方式使用：</p>

<pre><code class="language-objc">// .framework中直接包含图片
[UIImage iamgeNamed:&quot;A.framework/test.png&quot;]
// .framework中还有bundle，bundle中包含图片
[UIImage iamgeNamed:&quot;A.framework/A.bundle/test.png&quot;]

// 路径
[[NSBundle mainBundle] pathForResource:@&quot;a.framework/a.bundle/test.png&quot; ofType:nil];
</code></pre></li>
<li><p>d. 一般情况下，建议将资源文件和framework分开使用；（参考<code>http://www.cocoachina.com/bbs/read.php?tid-1676834-page-2.html</code> 、<code>http://www.cnblogs.com/mylizh/p/3971428.html</code>）</p></li>
</ul></li>
<li><p>注意： </p>

<ul>
<li><p><strong>a. 对于无xib的资源可以直接新建文件夹后，修改后缀名为.bundle即可手动创建bundle文件；Bundle是静态的，故手动创建bundle文件的内部资源文件无法被编译；</strong></p></li>
<li><p>b. 对于有xib的资源，需要新建Bundle Target（选择macOS的Bundle Target，之后修改Build Setting -&gt; Base SDK为iOS；iOS没有该类型的Target），将xib添加到该Target后，编译运行将xib文本文件编译成nib二进制文件，最终创建bundle文件；</p></li>
<li><p>c. nib与xib的区别：nib是二进制文件，xib是xml文本文件，xib是用来替代nib的；当程序编译时将xib编译序列化（调用encodeWithCoder方法）为nib，使用时将nib反序列化（调用initWithCoder方法）为xib；</p></li>
</ul></li>
</ul>

<h4 id="toc_4">五、补充知识</h4>

<ul>
<li><p><strong>若需要边开发边调试类库：在现有工程中添加一个库Lib Target，设置一些相关配置（默认情况下自动添加，比如主Target的Build Phases的Target Dependencies添加lib Target、Embedded Binaries添加Lib、Link Binary With Libraries添加Lib、Public头文件、Copy Bundle Resources等），之后就可以进行调试；</strong></p></li>
<li><p>若静态库中使用了分类，则在使用时需要在 <code>other linker flags</code> 中增加 <code>-ObjC</code> 配置，否则报<code>selector not recognized</code>运行时错误；</p></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift和ObjC混合编程]]></title>
    <link href="http://www.justisit.com/15206830265209.html"/>
    <updated>2018-03-10T19:57:06+08:00</updated>
    <id>http://www.justisit.com/15206830265209.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">一、Swift调用ObjC</a>
</li>
<li>
<a href="#toc_1">二、ObjC调用Swift</a>
</li>
<li>
<a href="#toc_2">三、Swift项目使用ObjC Pods</a>
</li>
<li>
<a href="#toc_3">四、ObjC项目使用Swift Pods</a>
</li>
<li>
<a href="#toc_4">五、Swift调用C、C++</a>
</li>
</ul>


<h5 id="toc_0">一、Swift调用ObjC</h5>

<ul>
<li>实现步骤：

<ul>
<li>1、新建Swift项目；</li>
<li>2、新建ObjC文件，比如ObjCUtil.h/m；

<ul>
<li>a. 此时Xcode会提示是否自动创建Bridge头文件（文件名称为<code>#ProjectName#-Bridging-Header.h</code>），选择自动创建；</li>
<li>b. 也可以手动创建Bridge头文件，只需修改&quot;Build Setting&quot;中的&quot;Objective-C Briding Header&quot;即可；</li>
</ul></li>
<li>3、在Bridge头文件中，进行<code>#import &quot;ObjC文件.h&quot;</code>，之后即可在Swift调用ObjC了；</li>
<li>4、新建一个Swift文件（不必继承NSObject）用于测试，比如SwiftTest.swift；</li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->       

<ul>
<li><p>示例代码</p>

<pre><code>// ObjCUtil.h
#import &lt;Foundation/Foundation.h&gt;

@interface ObjCUtil : NSObject

+ (void)sayClassMethod;
- (void)sayObjectMethod;

@end

// ObjCUtil.m
#import &quot;ObjCUtil.h&quot;

@implementation ObjCUtil

+ (void)sayClassMethod {
    NSLog(@&quot;%s&quot;, __func__);
}

- (void)sayObjectMethod {
    NSLog(@&quot;%s&quot;, __func__);
}

@end
</code></pre>

<pre><code class="language-Obj-C">// SwiftUseObjC-Bridging-Header.h
#import &quot;ObjCUtil.h&quot;
</code></pre>

<pre><code class="language-swift">// SwiftTest.swift
import Foundation

class SwiftTest { // 不必继承NSObject

    static func test() -&gt; Void {
        ObjCUtil.sayClassMethod()

        let objCUitl = ObjCUtil()
        objCUitl.sayObjectMethod()
    }

}
</code></pre></li>
</ul>

<h5 id="toc_1">二、ObjC调用Swift</h5>

<ul>
<li><p>实现步骤：</p>

<ul>
<li>1、新建ObjC项目；</li>
<li><p>2、新建一个Swift文件（必须继承NSObject），比如SwiftUtil.swift；</p>

<ul>
<li><p>a. 在选择Xcode自动创建Bridge头文件的同时，Xcode还会<strong>自动隐式创建</strong><code>#ProjectName#-Swift.h</code>，用于ObjC调用Swift；该文件中的内容为Xcode动态生成的，不需要编辑；</p>

<p><img src="media/15206830265209/Xcode_config.png" alt="Xcode_config" style="width:676px;"/></p></li>
<li><p>b. 若要将Swift类暴露给ObjC使用，则Swift类必须是NSObject的子类；</p></li>
<li><p><strong>c. 从Swift4.0开始，Swift类中的方法必须显示添加@objc修饰符（Swift3.0不需要），否则ObjC无法识别；可以通过设置&quot;Build Setting&quot;中的&quot;Swift 3 @objc inference&quot;决定是否使用新特性；</strong></p>

<p><img src="media/15206830265209/@objc.png" alt="@obj" style="width:489px;"/></p></li>
</ul></li>
<li><p>3、在需要Swift类的ObjC文件中，进行<code>#ProjectName#-swift.h</code>，即可在ObjC调用Swift了；</p></li>
<li><p>4、新建ObjC文件用于测试，比如ObjCTest.h/m；</p></li>
</ul></li>
<li><p>示例代码</p>

<pre><code class="language-swift">// SwiftUtil.swift
import UIKit

class SwiftUtil: NSObject { // 必须继承NSObject

    @objc func sayObjectMethod() -&gt; Void {
        print(&quot;file: \(#file), func: \(#function), lines: \(#line)&quot;)
    }

    @objc static func sayClassMethod() -&gt; Void {
        print(&quot;file: \(#file), func: \(#function), lines: \(#line)&quot;)
    }

}
</code></pre>

<pre><code>// ObjCTest.h
#import &lt;Foundation/Foundation.h&gt;

@interface ObjCTest : NSObject

+ (void)test;

@end

// ObjCTest.m
#import &quot;ObjCTest.h&quot;
#import &quot;ObjCUseSwift-Swift.h&quot;

@implementation ObjCTest

+ (void)test {
    [SwiftUtil sayClassMethod];

    SwiftUtil *swiftUtil = [[SwiftUtil alloc] init];
    [swiftUtil sayObjectMethod];
}

@end
</code></pre></li>
</ul>

<h5 id="toc_2">三、Swift项目使用ObjC Pods</h5>

<ul>
<li><p>Swift项目中可以直接使用ObjC Pods（不需要在Bridge头文件中进行#import），在使用的地方直接<code>imprort 模块名</code>即可，比如<code>import PureLayout</code>；</p>

<pre><code class="language-ruby"># Podfile
project &#39;SwiftObjCPods.xcodeproj&#39;
platform :ios, &#39;11.0&#39;

target &#39;SwiftObjCPods&#39; do
  use_frameworks!

  # Pods for SwiftObjCPods
  pod &#39;Alamofire&#39;, &#39;~&gt; 4.7&#39;
  pod &#39;PureLayout&#39;

end
</code></pre>

<pre><code class="language-swift">import UIKit
import Alamofire
import PureLayout

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()

        let view = UIView()
        self.view.addSubview(view)
        view.backgroundColor = .red
        view.autoCenterInSuperview()
        view.autoSetDimensions(to: CGSize(width: 100, height: 100))
    }

    override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {
        Alamofire.request(&quot;https://www.baidu.com/&quot;).responseString { (response) in
            debugPrint(response)
        }
    }

}
</code></pre></li>
</ul>

<h5 id="toc_3">四、ObjC项目使用Swift Pods</h5>

<ul>
<li>一般无法直接使用Swift Pods，需要定义一个Swift中介文件；通过中介文件调用Swift Pods，ObjC项目再调用中介文件；</li>
<li><p>ObjC项目的Podfile文件若使用Swift Pods，则必须使用<code>use_frameworks!</code>（Cocoapods 1.4.0还不支持Swift静态库）；</p>

<pre><code class="language-ruby"># Podfile
project &#39;ObjCSwiftPods.xcodeproj&#39;
platform :ios, &#39;11.0&#39;

target &#39;ObjCSwiftPods&#39; do
    use_frameworks! # 必须使用

  # Pods for ObjCSwiftPods
    pod &#39;PureLayout&#39;
    pod &#39;Alamofire&#39;, &#39;~&gt; 4.7&#39;

end
</code></pre>

<pre><code class="language-swift">// Swift中介文件
import Foundation
import Alamofire

class NetworkingUitl : NSObject {

    @objc class func request() -&gt; Void {
        Alamofire.request(&quot;https://www.baidu.com/&quot;).responseString { (response) in
            debugPrint(response)
        }
    }
}
</code></pre>

<pre><code class="language-obj-c">#import &quot;ViewController.h&quot;
#import &lt;PureLayout/PureLayout.h&gt;
#import &quot;ObjCSwiftPods-Swift.h&quot;

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    UIView *view = [[UIView alloc] init];
    [self.view addSubview:view];
    view.backgroundColor = [UIColor redColor];
    [view autoCenterInSuperview];
    [view autoSetDimensionsToSize:CGSizeMake(100, 100)];
}

- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    [NetworkingUitl request];
}

@end
</code></pre></li>
</ul>

<h5 id="toc_4">五、Swift调用C、C++</h5>

<ul>
<li>Swift无法直接调用C、C++，其可以通过Swift调用ObjC，ObjC再调用C、C++，间接完成Swift调用C、C++；</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Carthage使用教程]]></title>
    <link href="http://www.justisit.com/15147939316129.html"/>
    <updated>2018-01-01T16:05:31+08:00</updated>
    <id>http://www.justisit.com/15147939316129.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">一、概述、安装</a>
</li>
<li>
<a href="#toc_1">二、使用</a>
</li>
<li>
<a href="#toc_2">三、其他说明</a>
</li>
</ul>


<h4 id="toc_0">一、概述、安装</h4>

<ul>
<li>Carthage类似于CocoaPods，用于iOS、macOS等平台的第三方框架的管理；其原理为将源代码编译成<strong>Dynamic framework（Xcode 6.0开始支持；Carthage是基于Swift的，Swift只支持Dynamic framework）</strong>，之后手动拖入到项目中；其对项目工程文件的入侵性较小，并且可以与CocoaPods无缝集成，一个项目可以同时拥有CocosPods和Carthage；</li>
<li><p>可以通过Homebrew进行安装Carthage；</p>

<pre><code># 安装carthage（安装升级carthage，注意可能出现多版本共存bug）
brew install carthage

carthage version  # 查看安装的版本
</code></pre></li>
</ul>

<span id="more"></span><!-- more -->

<h4 id="toc_1">二、使用</h4>

<ul>
<li><p>1、在项目根目录更加一个名称为Cartfile的文件，其作用和Podfile一样，描述所需要的第三方框架；</p>

<pre><code>touch Cartfile
open -a Xcode Cartfile  # 使用Xcode打开编辑

# Cartfile内容（可以像Podfile一样指定库的版本）
github &quot;Alamofire/Alamofire&quot; == 4.7.0  
github &quot;PureLayout/PureLayout&quot;
</code></pre></li>
<li><p>2、执行更新命令，生成framework文件；</p>

<pre><code>carthage update --platform iOS # 只生成iOS平台的framework
</code></pre>

<p>执行完成后，会生成以下文件目录结构：</p>

<ul>
<li><p>Carfile.resolved用于版本控制；Build目录为生成的Dynamic framework；Checkouts为从github上clone的源代码；</p>

<p><img src="media/15147939316129/carthage_files.png" alt="carthage_files" style="width:684px;"/></p></li>
</ul></li>
<li><p>3、添加Dynamic framework到项目中；</p>

<ul>
<li><p><strong>方式一：Embedded Binaries（不建议使用）</strong></p>

<p><img src="media/15147939316129/embedded_binaries.png" alt="embedded_binaries" style="width:672px;"/></p>

<ul>
<li><strong>a. 由于是生成的是Dynamic framework，可以手动直接添加framework到General或Build Phase界面的&quot;Embedded Binaries&quot;中，之后就可以直接使用；</strong></li>
<li><strong>b. 添加了&quot;Embedded Binaries&quot;后，&quot;Link Binary With Libraries&quot;中会自动添加上面手动添加的framework；</strong></li>
<li><strong>c. 若只是仅仅手动添加framework到&quot;Link Binary With Libraries&quot;，则该framework只能是Static Framework，不可以为Dynamic framework；</strong></li>
<li><strong>d. 手动拖拽framework，只会添加framework到&quot;Link Binary With Libraries&quot;中；</strong></li>
</ul></li>
<li><p><strong>方式二：Link Binary With Libraries + Run Script；</strong></p>

<ul>
<li><p><strong>a. 添加添加framework到&quot;Link Binary With Libraries&quot;后，在Build Phase界面点击左上角+按钮，添加一个Run Script，并做以下配置；</strong></p>

<p><img src="media/15147939316129/carthage_run_script.png" alt="carthage_run_script" style="width:491px;"/></p>

<ul>
<li><strong>a) 添加命令：<code>usr/local/bin/carthage copy-frameworks</code></strong></li>
<li><p><strong>b) Input Files中添加每一个framework的输入路径（注意避免空格换行符），比如：</strong></p>

<pre><code>$(SRCROOT)/Carthage/Build/iOS/Alamofire.framework
$(SRCROOT)/Carthage/Build/iOS/PureLayout.framework
</code></pre></li>
<li><p><strong>c)（可选，建议配置）Output Files中添加每一个framework的输出路径，比如：</strong></p>

<pre><code>$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/Alamofire.framework
$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/PureLayout.framework
</code></pre></li>
</ul></li>
<li><p><strong>b. <code>carthage copy-frameworks</code>命令的作用</strong></p>

<ul>
<li><strong>a) 拷贝Dynamic framework，进而不需要在手动添加到&quot;Embedded Binaries&quot;中了；</strong></li>
<li><strong>b)（最重要）裁减Dynamic framework；</strong>

<ul>
<li><strong>Carthage生成的Dynamic framework是包含模拟器和真机平台的，而App Store提交的包内不可以有没有用到的平台的代码（模拟器的），使用该脚本就是自动将无用代码去除；（<code>http://ikennd.ac/blog/2015/02/stripping-unwanted-architectures-from-dynamic-libraries-in-xcode/</code>）</strong></li>
<li><strong>为了优化编译速度，添加Output Files路径，这样只有在Input Files中的文件修改了或Output Files中的文件丢失的情况下，才会执行命令，否则每次运行都会去执行；（详情查看<code>https://github.com/Carthage/</code>）</strong></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h4 id="toc_2">三、其他说明</h4>

<ul>
<li>若更新了Cartfile文件（库的版本、增删库），则只需要重新执行 <code>carthage update</code> 命令即可；</li>
<li><strong>注意：不要直接删除Xcode Simulator的文件目录(<code>~/Library/Developer/CoreSimulator/Devices/</code>)</strong>；

<ul>
<li>若需要删除，可以通过<code>Xcode-&gt;Window-&gt;Devices and Simulators</code>进行删除；</li>
<li><strong>直接删除可能导致执行xcodebuild命令失败，报错<code>xcodebuild: error: Unable to find a destination matching the provided destination specifier: { platform:iOS Simulator, id:</code>，进而导致执行 <code>carthage update</code> 命令失败</strong>；</li>
<li>解决出现上面的问题，需要将所有模拟器手动删除后再新建一些模拟器即可；</li>
</ul></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语法概要(07~08)]]></title>
    <link href="http://www.justisit.com/15147467512006.html"/>
    <updated>2018-01-01T02:59:11+08:00</updated>
    <id>http://www.justisit.com/15147467512006.html</id>
    <content type="html"><![CDATA[<h4 id="toc_0">一、扩展(extension)、协议(protocal)</h4>

<h4 id="toc_1">二、泛型(generic)、访问控制</h4>

<span id="more"></span><!-- more -->

<p><img src="media/15147467512006/%E6%A6%82%E8%A6%81-%E4%B8%83-.svg" /></p>

<p><img src="media/15147467512006/%E6%A6%82%E8%A6%81-%E5%85%AB-.svg" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语法概要(05~06)]]></title>
    <link href="http://www.justisit.com/15147467504421.html"/>
    <updated>2018-01-01T02:59:10+08:00</updated>
    <id>http://www.justisit.com/15147467504421.html</id>
    <content type="html"><![CDATA[<h4 id="toc_0">一、继承、构造</h4>

<h4 id="toc_1">二、析构、类型检查及转换、异常</h4>

<span id="more"></span><!-- more -->

<p><img src="media/15147467504421/%E6%A6%82%E8%A6%81-%E4%BA%94-.svg" /></p>

<p><img src="media/15147467504421/%E6%A6%82%E8%A6%81-%E5%85%AD-.svg" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语法概要(03~04)]]></title>
    <link href="http://www.justisit.com/15147467488941.html"/>
    <updated>2018-01-01T02:59:08+08:00</updated>
    <id>http://www.justisit.com/15147467488941.html</id>
    <content type="html"><![CDATA[<h4 id="toc_0">一、结构体(值类型)、类(引用类型)</h4>

<h4 id="toc_1">二、枚举(值类型)、其他</h4>

<span id="more"></span><!-- more -->

<p><img src="media/15147467488941/%E6%A6%82%E8%A6%81-%E4%B8%89-.svg" /></p>

<p><img src="media/15147467488941/%E6%A6%82%E8%A6%81-%E5%9B%9B-.svg" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语法概要(01~02)]]></title>
    <link href="http://www.justisit.com/15142060028487.html"/>
    <updated>2017-12-25T20:46:42+08:00</updated>
    <id>http://www.justisit.com/15142060028487.html</id>
    <content type="html"><![CDATA[<h4 id="toc_0">一、基本概念、基础类型(值类型)、控制流</h4>

<h4 id="toc_1">二、函数、闭包(引用类型)</h4>

<span id="more"></span><!-- more -->

<p><img src="media/15142060028487/%E6%A6%82%E8%A6%81-%E4%B8%80-.svg" /></p>

<p><img src="media/15142060028487/%E6%A6%82%E8%A6%81-%E4%BA%8C-.svg" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3爬虫总结]]></title>
    <link href="http://www.justisit.com/15129255415379.html"/>
    <updated>2017-12-11T01:05:41+08:00</updated>
    <id>http://www.justisit.com/15129255415379.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">一、URI、URL</a>
</li>
<li>
<a href="#toc_1">二、urllib库</a>
</li>
<li>
<a href="#toc_2">三、URLError、HTTPError</a>
</li>
<li>
<a href="#toc_3">四、设置header、timeout</a>
</li>
<li>
<a href="#toc_4">五、Opener、Handler</a>
<ul>
<li>
<a href="#toc_5">5.1 HTTPBasicAuthHandler</a>
</li>
<li>
<a href="#toc_6">5.2 ProxyHandler</a>
</li>
<li>
<a href="#toc_7">5.3 HTTPRedirectHandler</a>
</li>
<li>
<a href="#toc_8">5.4 HTTPCoookieProcessor</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">六、实战</a>
</li>
</ul>


<h4 id="toc_0">一、URI、URL</h4>

<ul>
<li>URI（Universal Resource Identifier）：统一资源标识符，一种语义上的抽象概念；可以是绝对的，也可以是相对的</li>
<li>URL（Uniform Resource Locator）：统一资源定位符，一种具体的绝对的URI，是URI的一个子集；不仅唯一标识资源，而且还提供足够的信息定位该资源的信息</li>
</ul>

<h4 id="toc_1">二、urllib库</h4>

<ul>
<li><p>Python 2.x中有urllib、urllib2两个HTTP请求模块；urllib2是urllib的增强，但urllib中有urllib2中所没有的函数，它们一起搭配使用、不可相互替代</p>

<ul>
<li><p>a). urllib仅仅可以接受url，不可以设置请求的headers，意味着不可以进行伪装“User Agent”等操作</p></li>
<li><p>b). urllib2可以通过接受一个Request实例，来设置HTTP请求的headers</p></li>
<li><p>c). urllib提供urlencode函数用来“拼接”请求参数字符串</p></li>
<li><p>d). urllib2没有“拼接”请求参数字符串功能的函数；</p></li>
<li><p>urlencode函数是将一个dit或一个含有两个元素tuple的list变成一个url查询字符串（如name=Tom&amp;age=12)，并不是进行字符编码</p></li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->

<ul>
<li><p>Python 3.x中urllib和urilib2两个模块统一合并成了urllib模块，其中urllib2被修改为urllib.request</p>

<ul>
<li><p>a). urllib.urlencode()变成了urllib.parse.urlencode()</p></li>
<li><p>b). urllib2.urlopen()变成了urllib.request.urlopen()</p></li>
<li><p>c). urllib2.Request()变成了urllib.request.Request()</p></li>
</ul>

<pre><code class="language-python">from urllib import request, parse

# 方式1: 使用url（GET）
url = &#39;http://www.baidu.com/&#39;
with request.urlopen(url) as f:
    print(f.getheaders())

# 方式2: 使用Request对象(可添加Header)（GET）
url = &#39;http://www.baidu.com/&#39;
req = request.Request(url)
with request.urlopen(req) as f:
    print(f.getheaders())

# 方式3: 使用url、拼接查询字符串（GET）
d = {&#39;name&#39;: &#39;Tom&#39;, &#39;age&#39;: 12}
l = [(&#39;name&#39;, &#39;Tom&#39;), (&#39;age&#39;, 12)]
# urlencode将一个dit或一个含有两个元素tuple的list变成一个url查询字符串
data = parse.urlencode(d)
url = &#39;http://www.baidu.com/&#39; + &#39;?&#39; + data  
with request.urlopen(url) as f:
    print(f.getheaders())

# 方式4: 使用url、设置data参数（POST）
d = {&#39;name&#39;: &#39;Tom&#39;, &#39;age&#39;: 12}
data = parse.urlencode(d)
data = data.encode(&#39;utf-8&#39;)
url = &#39;http://www.baidu.com/&#39;
with request.urlopen(url, data=data) as f:
    print(f.getheaders())

# 方式5: 使用Request对象、设置data参数（POST）
d = {&#39;name&#39;: &#39;Tom&#39;, &#39;age&#39;: 12}
data = parse.urlencode(d)
data = data.encode(&#39;utf-8&#39;)
url = &#39;http://www.baidu.com/&#39;
req = request.Request(url, data=data)
with request.urlopen(req) as f:
    print(f.getheaders())

# mothod参数可以指定请求类型，比如GET/POST/HEAD/DELETE/PUT
req = request.Request(&#39;http://www.baidu.com/&#39;, method=&#39;PUT&#39;)
with request.urlopen(req) as f:
    print(f.getheaders())

# HTTPResponse对象的常见方法
print(f)  # &lt;http.client.HTTPResponse object at 0x101f56940&gt;
print(f.getheaders()) # 响应headers
print(f.info()) # 响应headers（字典形式）
print(f.geturl())  # 最终的url（可能会重定向）
print(f.getcode()) # 响应码 （若请求异常，则需从HTTPError对象中获取code属性）
</code></pre></li>
</ul>

<h4 id="toc_2">三、URLError、HTTPError</h4>

<ul>
<li><p>URLError是HTTPError的父类；URLError有reason属性，HTTPError既有reason属性，也有code属性</p>

<pre><code class="language-python">from urllib import request, error

# Error处理方式1:
try:
    # url = &#39;h://home.baidu.com&#39;
    url = &#39;http://home.baidu.com/x&#39;
    with request.urlopen(url) as f:  # with ... as语句简化写finally语句
        print(f.getheaders())
except error.HTTPError as e:
    print(&quot;【HTTPError】:&quot;, e)
    print(&quot;【HTTPError】, code:&quot;, e.reason)
except error.URLError as e:
    print(&quot;【URLError】:&quot;, e)
    print(&quot;【URLError】, reason:&quot;, e.reason)
else:
    print(&#39;else...&#39;)

# Error处理方式2:
try:
    # url = &#39;h://home.baidu.com&#39;
    url = &#39;http://home.baidu.com/x&#39;
    with request.urlopen(url) as f:
        print(f.getheaders())
except error.URLError as e:
    if hasattr(e, &#39;code&#39;):
        print(&quot;【HTTPError】:&quot;, e)
        print(&quot;【HTTPError】, code:&quot;, e.code)
    elif hasattr(e, &#39;reason&#39;):
        print(&quot;【URLError】:&quot;, e)
        print(&quot;【URLError】, reason:&quot;, e.reason)
else:
    print(&#39;else...&#39;)
</code></pre></li>
</ul>

<h4 id="toc_3">四、设置header、timeout</h4>

<ul>
<li>request的Content-Type（通常用于表单提交）有两种：application/x-www-form-urlencoded（没有附件上传的表单）、multipart/form-data（有附件上传的表单）</li>
<li>response的Content-Type通常是text/html、application/json、application/json</li>
<li><p>某些网站的简单“反盗链”设置，就检查request header的 <code>referer</code> 字段的值是不是该网站自身，若不是则认为“被盗链”了；应对“反盗链”只需将referer的值设置为当前请求的网站即可</p>

<pre><code class="language-python"># timeout设置方式1: 全局timeout(设置socket)
import  socket
socket.setdefaulttimeout(0.25)

# timeout设置方式2: urlopen函数设置timeout参数
from urllib import request, error

req = request.Request(&#39;http://www.google.com/&#39;)
req.add_header(&#39;User-Agent&#39;, &#39;iOS&#39;)  # 浏览器类型

try:
    with request.urlopen(req, timeout=0.25) as f:
        print(f.getheaders())
except error.HTTPError as e:
    print(&quot;【HTTPError】:&quot;, e)
    print(&quot;【HTTPError】, code:&quot;, e.code)
except error.URLError as e:
    print(&quot;【URLError】:&quot;, e)
    print(&quot;【URLError】, reason:&quot;, e.reason)
else:
    print(&#39;else...&#39;)
</code></pre></li>
</ul>

<h4 id="toc_4">五、Opener、Handler</h4>

<ul>
<li><strong>urllib.request.urlopen()本质是使用一个默认创建的Opener对象去发送网络请求，但其不支持验证、cookie、其他HTTP高级功能</strong>

<ul>
<li><strong>若要支持上述高级那些功能，必须使用build_opener()函数创建自定义的Opener对象；build_opener()函数的参数为Handlers，返回为Opener对象；若不传入Handlers参数，则Opener对象会被默认添加一些Hanlder</strong></li>
<li>Opener对象也可通过add_handler()方法手动添加Handler</li>
<li>Opener对象具有open()方法，和request的urlopen()方法的功能一样，也支持通过addHeaders()方法设置headers</li>
<li>可以将某个Opener对象装载变为全局的（调用request.install_opener(opener)方法），之后使用request.urlopen()就是使用该Opener对象去发送请求</li>
</ul></li>
<li>HTTPBasicAuthHandler是处理WWW-Authenticate的Handler，ProxyHandler是处理代理的Handler，HTTPRedirectHandler是处理重定向的Handler（需要子类），HTTPCoookieProcessor是处理Cookies的Handler，等等</li>
</ul>

<h5 id="toc_5">5.1 HTTPBasicAuthHandler</h5>

<ul>
<li>WWW-Authenticate是早期的一种简单身份认证技术，通常用在嵌入式领域（如早期的家用路由器的登录）或者一些需要简单认证的应用（如Tomcat的Application管理的登录）；该认证采用的用户名密码的加密方式为Base64（即明码传输），验证简单容易被破解</li>
<li>WWW-Authenticate认证过程：

<ul>
<li>1). 客户端浏览器向服务端发送HTTP请求（比如192.168.1.1）</li>
<li>2). 服务端收到请求，解析请求的header，判断是否有 <code>Authorization: Basic XXXX</code> 字段；若没有，则服务器的响应的header设置 <code>WWW-Authenticate: Basic realm=&quot;YYYY&quot;</code>（要求客户端发送用户名密码到服务端）</li>
<li>3). 当客户端浏览器收到响应的header中含有 <code>WWW-Authenticate: Basic realm=&quot;YYYY&quot;</code> 时，会弹出对话框要求用户输入相关信息</li>
<li>4). 用户输入相关信息后，客户端将发送含有 <code>Authorization: Basic XXXX</code> 请求给服务器进行认证</li>
</ul></li>
<li><p>验证WWW-Authenticate认证</p>

<pre><code class="language-python">
# 1. 环境准备：安装Tomcat，修改文件权限，修改tomcat-users.xml，启动服务器
    a. 修改文件权限：sudo chmod 755 xxx/bin/*.sh
    b. 修改tomcat-users.xml：增加如下内容
      &lt;role rolename=&quot;manager-gui&quot;/&gt;
      &lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui&quot;/&gt;
</code></pre>

<pre><code class="language-python"># 2. 验证
from urllib import request

# a. 不使用HTTPBasicAuthHandler，访问失败
url = &#39;http://127.0.0.1:8080/manager/html&#39;  
with request.urlopen(url) as f:
    print(f.getheaders())

# b. 使用HTTPBasicAuthHandler，访问成功
top_url = &#39;http://127.0.0.1:8080/&#39;
password_mgr = request.HTTPPasswordMgrWithDefaultRealm()
password_mgr.add_password(None, top_url, &#39;tomcat&#39;, &#39;tomcat&#39;)  # 注意要设置域
# 创建一个handler
handler = request.HTTPBasicAuthHandler(password_mgr=password_mgr) 

# 创建一个opener
# 方式1:
# opener = request.build_opener(handler)  
# 方式2:
opener = request.build_opener()
opener.add_handler(handler)

opener.addheaders = [(&#39;User-Agent&#39;, &#39;Mozilla/5.0&#39;)]  # 设置请求头

url = &#39;http://127.0.0.1:8080/manager/html&#39;
with opener.open(url) as f:
    print(f.getheaders())
</code></pre></li>
</ul>

<h5 id="toc_6">5.2 ProxyHandler</h5>

<ul>
<li><p>设置HTTP代理</p>

<pre><code class="language-python">from urllib import request

# a. 不使用代理
url = &#39;http://ip.chinaz.com/getip.aspx&#39;
with request.urlopen(url) as f:
print(f.read().decode(&#39;utf-&#39;))
# {ip:&#39;111.196.84.186&#39;,address:&#39;北京市 联通&#39;}

# b. 使用代理
handler = request.ProxyHandler({&#39;http&#39;: &#39;124.88.67.21:843&#39;})

opener = request.build_opener(handler)

url = &#39;http://ip.chinaz.com/getip.aspx&#39;
with opener.open(url) as f:
print(f.read().decode(&#39;utf-8&#39;))
# {ip:&#39;124.88.67.21&#39;,address:&#39;新疆乌鲁木齐市 联通&#39;}

# c. 使用代理，并进行认证（两个Handler）
proxy_url = &#39;124.88.67.21:843&#39;
password_mgr = request.HTTPPasswordMgrWithDefaultRealm()
password_mgr.add_password(None, proxy_url, &#39;tomcat&#39;, &#39;tomcat&#39;)
proxy_auth_handler = request.ProxyBasicAuthHandler(password_mgr)

proxy_handler = request.ProxyHandler({&#39;http&#39;: proxy_url})

opener = request.build_opener(proxy_handler, proxy_auth_handler)

url = &#39;http://ip.chinaz.com/getip.aspx&#39;
with opener.open(url) as f:
print(f.read().decode(&#39;utf-8&#39;))
</code></pre></li>
</ul>

<h5 id="toc_7">5.3 HTTPRedirectHandler</h5>

<ul>
<li>重定向类型：

<ul>
<li>301重定向（Moved Permanently）：表示本网页永久性转移到另一个地址，搜索引擎在抓取新内容时，会将旧的网址替换为重定向之后的网址，比如<a href="http://www.360buy.com/">http://www.360buy.com/</a></li>
<li>302重定向（Temporarily Moved）：表示暂时重定向，搜索引擎在抓取新内容时，会保留旧的网址，比如<a href="http://www.baidu.com/haha">http://www.baidu.com/haha</a></li>
</ul></li>
<li><p>处理重定向（需要自定义Handler继承HTTPRedirectHandler，并重写相关处理方法）</p>

<pre><code class="language-python">from urllib import request

# a. 不进行重定向处理
url = &#39;http://www.baidu.com/haha&#39;
with request.urlopen(url) as f:
    print(f.getheaders())
    final_url = f.geturl()
    if url != final_url:
        print(&#39;redirected...&#39;)

# b. 进行重定向处理
# 自定义Handler，重写父类处理302的方法（防止302跳转）
# 若还需要防止301跳转，则重写父类处理301的方法
class NoHTTPRedirectHandler(request.HTTPRedirectHandler):
    def http_error_302(self, req, fp, code, msg, headers):
        print(&#39;http_error_302...&#39;)
        pass

opener = request.build_opener(NoHTTPRedirectHandler)

url = &#39;http://www.baidu.com/haha&#39;
with opener.open(url) as f:
    print(f.getheaders())
    final_url = f.geturl()
    if url != final_url:
        print(&#39;redirected...&#39;)
</code></pre></li>
</ul>

<h5 id="toc_8">5.4 HTTPCoookieProcessor</h5>

<ul>
<li>利用http.cookiejar模块的CookieJar对象可以捕获、保存、在后续请求时加载cookie（这些操作都使用了handler来实现的），以实现模拟登录的功能；在Python 2.x中，CookieJar在cookielib模块下</li>
<li>cookie保存的方式有两大类型：

<ul>
<li>CookieJar（保存到内存中）</li>
<li>FileCookieJar（保存到文件中）：无法直接使用，需要用其子类MozillaCookieJar（保存格式为Mozilla格式）、LWPCookieJar（保存格式为LWP格式）</li>
</ul></li>
<li>一个cookie的大小是有限制的；对于同一个url可以有多个cookie，但发送给服务器时会自动将多个cookie拼接一起设置在request的header的“Cookie”字段中</li>
<li><p>使用cookie的方式：</p>

<ul>
<li>直接从response的header中获取cookie：之后访问同一个域中的其他url，request的header中是默认不会带“Cookie”字段的，需要手动设置cookie</li>
<li><strong>通过CookieJar获取cookie：之后访问同一个域中的其他url，会自动带上之前获取的cookie，不需要手动设置</strong></li>
</ul></li>
<li><p>处理cookie</p>

<pre><code class="language-python">from urllib import request
from http import cookiejar

# a. 直接从response的header中获取cookie
url = &#39;http://www.baidu.com/haha&#39;
req = request.Request(url)
with request.urlopen(req) as f:
    print(f.info())  # header有Set-Cookie字段

# b. 通过CookieJar获取cookie（保存到CookieJar中）
cj = cookiejar.CookieJar()
handler = request.HTTPCookieProcessor(cookiejar=cj)

opener = request.build_opener(handler)

url = &#39;http://www.baidu.com/&#39;
with opener.open(url) as f:
    print(f.info())
    print(&#39;............&#39;)
    for item in cj:  # item为http.cookiejar.Cookie对象
        print(item.name + &#39;, &#39; + item.value + &#39;, &#39; + item.domain + &#39;, &#39; + str(item.expires))
    # 之后，opener.open()访问同一个域中的其他url会自动带上cookie

# c. 通过CookieJar获取cookie（保存到文件中）
# filename = &#39;mozillaCookie.txt&#39;
# fileCJ = cookiejar.MozillaCookieJar(filename)
filename = &#39;lwpCookie.txt&#39;
fileCJ = cookiejar.LWPCookieJar(filename)
handler = request.HTTPCookieProcessor(cookiejar=fileCJ)

opener = request.build_opener(handler)

url = &#39;http://www.baidu.com/&#39;
with opener.open(url) as f:
    # 保存到文件
    # ignore_discard=True：表示即使cookie将被丢弃也将其保存
    # ignore_expires=True：表示即使cookies已过期也将其保存
    fileCJ.save(ignore_discard=True, ignore_expires=True)
    for item in fileCJ:
        print(item.name + &#39;, &#39; + item.value + &#39;, &#39; + item.domain + &#39;, &#39; + str(item.expires))

# d. 加载cookie，并利用cookie模拟登陆
# 登陆失败，则报错HTTP Error 401: Unauthorized
# 登陆成功，则打印header信息
# lwpCookie.txt内容如下:
# #LWP-Cookies-2.0
# Set-Cookie3: JSESSIONID=&quot;D0A8F2D81D533497AC7A7BA22E35A041&quot;; path=&quot;/manager/&quot;; domain=&quot;127.0.0.1&quot;; path_spec; discard; version=0

filename = &#39;lwpCookie.txt&#39;
fileCJ = cookiejar.LWPCookieJar()
# 从文件中加载cookie
fileCJ.load(filename, ignore_discard=True, ignore_expires=True)
handler = request.HTTPCookieProcessor(cookiejar=fileCJ)

opener = request.build_opener(handler)

url = &#39;http://127.0.0.1:8080/manager/html&#39;
with opener.open(url) as f:
    print(f.info())
</code></pre></li>
<li><p>调试：输出HTPP Debug Log</p>

<pre><code class="language-python"># 输出Log方式1：
from urllib import request
from http.client import HTTPConnection, HTTPSConnection

HTTPConnection.debuglevel = 1
HTTPSConnection.debuglevel = 1

request.urlopen(&#39;http://www.baidu.com/&#39;)
print(&#39;.....&#39;)

# 输出Log方式2：（通过Handler；未验证通过）
from urllib import request

httpHandler = request.HTTPHandler(debuglevel=1)
httpsHandler = request.HTTPSHandler(debuglevel=1)

opener = request.build_opener(httpHandler, httpsHandler)

opener.open(&#39;http://www.baidu.com/&#39;)
print(&#39;.....&#39;)
</code></pre></li>
</ul>

<h4 id="toc_9">六、实战</h4>

<ul>
<li><p>抓取糗事百科</p>

<pre><code class="language-python"># http://www.qiushibaike.com/hot/page/1/
# 匹配的文字内容格式：&lt;div class=&quot;content&quot;&gt;这个一定能过&lt;/div&gt;
from urllib import request
import re
from threading import Thread
import time

def get_contents_by_page(page):
    url = &#39;http://www.qiushibaike.com/hot/page/%d/&#39; % page
    req = request.Request(url)
    req.add_header(&#39;User-Agent&#39;, &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:45.0) Gecko/20100101 Firefox/45.0&#39;)

    with request.urlopen(req) as f:
        html = f.read().decode(&#39;utf-8&#39;, errors=&#39;ignore&#39;)
        # 方式1:
        # 使用非贪婪匹配：&lt;div class=&quot;content&quot;&gt;([.|\n]*?)&lt;/div&gt;或者&lt;div class=&quot;content&quot;&gt;([\s\S]*?)&lt;/div&gt;
        # .默认匹配除换行之外的任意字符
        # pattern = r&#39;&lt;div class=&quot;content&quot;&gt;([\s\S]*?)&lt;/div&gt;&#39;
        # contents = re.findall(pattern, html)

        # 方式2:
        pattern = r&#39;&lt;div class=&quot;content&quot;&gt;(.*?)&lt;/div&gt;&#39;
        # 设置re.S标志位，让.也可以匹配换行符
        contents = re.findall(pattern, html, re.S)

        pageContents = []
        for content in contents:
            pageContents.append(content.replace(&#39;\n&#39;, &#39;&#39;))
        return pageContents
</code></pre>

<pre><code class="language-python">totalPageContents = []

def get_pages_contents():
    page = 1
    while True:
        # totalPageContents最多只能存放两页的数据，超过就暂停抓取
        if len(totalPageContents) &lt; 2:
            page_contents = get_contents_by_page(page)
            page += 1
            totalPageContents.append(page_contents)
        else:
            time.sleep(1.0)

def print_pages_contents():
    page = 1
    while True:
        if len(totalPageContents):  # 有数据
            page_contents = totalPageContents.pop(0)
            print(&#39;------------第%d页数据------------&#39; % page)
            for content in page_contents:
                print(&quot;&gt;&gt;&quot; + content)
                page += 1
        else:
            time.sleep(1.0)
</code></pre>

<pre><code class="language-python">def start():
    print(&#39;------------开始爬虫------------&#39;)
    Thread(target=get_pages_contents).start()
    print_pages_contents()

if __name__ == &#39;__main__&#39;:
    start()
</code></pre></li>
<li><p>抓取百度贴吧连载小说</p>

<pre><code class="language-python"># http://tieba.baidu.com/p/3829840554?see_lz=1&amp;pn=1
from urllib import request
import re

allData = []

def get_pages_contents(url, page_count):
    for i in range(1, int(page_count) + 1):
        print(&#39;正在抓取第%s页的数据...&#39; % i)
        req = request.Request(&#39;%s&amp;pn=%d&#39; % (url, i))
        req.add_header(&#39;User-Agent&#39;,&#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:45.0) Gecko/20100101 Firefox/45.0&#39;)

        with request.urlopen(req) f:
          html = f.read().decode(&#39;utf-8&#39;)
          pattern = r&#39;&lt;div id=&quot;post_content_\d+?&quot; class=&quot;d_post_content j_d_post_content &quot;&gt;(.+?)&lt;/div&gt;&#39;
          contents = re.findall(pattern, html)
          print(&#39;正在处理第%s页的数据...&#39; % i)
          for co in contents:  # 处理每一楼层内容；sub方法为进行字符串替换
              co = re.sub(r&#39;^\s*&#39;, r&#39;&#39;, co)  # 处理最前面的空格
              co = re.sub(r&#39;&lt;br&gt;&#39;, r&#39;\n&#39;, co)  # 处理换行
              co = re.sub(r&#39;&lt;a .+?&gt;(.+?)&lt;/a&gt;&#39;, r&#39;\1&#39;, co)  # 处理超链接
              allData.append(co) # 注：不严谨，无法保证每页的顺序正确
</code></pre>

<pre><code class="language-python">url = &#39;http://tieba.baidu.com/p/3829840554?see_lz=1&#39;
req = request.Request(url)
req.add_header(&#39;User-Agent&#39;, &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:45.0) Gecko/20100101 Firefox/45.0&#39;)

with request.urlopen(req) as f:
    html = f.read().decode(&#39;utf-8&#39;)
    title = re.search(r&#39;&lt;h3 class=&quot;core_title_txt.*?&gt;(.+?)&lt;/h3&gt;&#39;, html).group(1)
    print(&#39;标题为: %s&#39; % title)
    page_count = re.search(r&#39;&lt;span class=&quot;red\&quot;&gt;(\d+?)&lt;/span&gt;&#39;, html).group(1)
    print(&#39;一共有%s页数据&#39; % page_count)

    get_pages_contents(url, page_count)

    with open(title + &#39;.txt&#39;, &#39;w&#39;) as ff:
        ff.writelines(allData)
        print(&#39;数据保存完毕...&#39;)
</code></pre></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(17Web开发、18异步IO)]]></title>
    <link href="http://www.justisit.com/15125773962376.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773962376.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">17. Web开发</a>
<ul>
<li>
<a href="#toc_1">17.1 HTTP协议</a>
</li>
<li>
<a href="#toc_2">17.2 HTML</a>
</li>
<li>
<a href="#toc_3">17.3 WSGI接口</a>
</li>
<li>
<a href="#toc_4">17.4 使用Web框架</a>
</li>
<li>
<a href="#toc_5">17.5 使用模板</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">18. 异步IO</a>
<ul>
<li>
<a href="#toc_7">18.1 概述</a>
</li>
<li>
<a href="#toc_8">18.2 协程（Coroutine）</a>
</li>
<li>
<a href="#toc_9">18.3 asyncio</a>
</li>
<li>
<a href="#toc_10">18.4 async/await</a>
</li>
<li>
<a href="#toc_11">18.5 aiohttp</a>
</li>
</ul>
</li>
</ul>


<h4 id="toc_0">17. Web开发</h4>

<h5 id="toc_1">17.1 HTTP协议</h5>

<ul>
<li>在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来；浏览器和服务器之间的传输协议是HTTP</li>
<li>HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信；HTML是一种用来定义网页的文本</li>
<li><p>每个HTTP请求和响应报文都遵循相同的格式，包含Header、Body（可选的）</p>

<pre><code class="language-python"># 1. HTTP GET请求格式
GET /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3
</code></pre>

<ul>
<li>a. GET为请求方法，类似的有POST、HEADER等</li>
<li>b. /path表示URL的路径（总是以/开头），/就表示首页</li>
<li>c. HTTP/1.1表示采用HTTP协议版本为1.1；HTTP/1.1允许多个HTTP请求复用同一个TCP连接，加快传输速度，HTTP/1.0不可以</li>
<li>d. 每个Header一行一个，换行符为\r\n</li>
</ul>

<pre><code class="language-python"># 2. HTTP POST请求格式
POST /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
</code></pre>

<ul>
<li>a. 当遇到连续两个\r\n，表示Header部分结束，后面的数据全部是Body</li>
</ul>

<pre><code class="language-python"># 3. HTTP 响应格式
200 OK
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
</code></pre>

<ul>
<li>a. 200表示成功响应，后面的OK为说明；类似的，“404 Not Found”表示网页不存在，“500 Internal Server Error”表示服务器内部出错，等等</li>
<li>b. Content-Type表示body的数据类型，比如，“text/html”表示HTML网页；浏览器依靠Content-Type来判断响应的内容类型，而不是依靠URL，故即使URL是<a href="http://abc.com/a.jpg%E4%B9%9F%E4%B8%8D%E4%B8%80%E5%AE%9A%E5%B0%B1%E6%98%AF%E5%9B%BE%E7%89%87">http://abc.com/a.jpg也不一定就是图片</a></li>
<li>c. 当存在Content-Encoding时，说明Body数据被压缩了，需要将Body数据先解压才能使用；最常见的压缩方式是gzip；压缩的目的在于减小Body的大小，加速网络传输</li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->   

<h5 id="toc_2">17.2 HTML</h5>

<ul>
<li>HTML定义了网页的内容，CSS控制网页的内容，JavaScript负责页面的交互逻辑</li>
<li>当我们用Python或者其他语言开发Web应用时，就是要在服务器端动态创建出HTML；这样，浏览器就会向不同的用户显示不同的Web页面</li>
</ul>

<h5 id="toc_3">17.3 WSGI接口</h5>

<ul>
<li><p>一个Web应用的本质：</p>

<ul>
<li>1). 浏览器发送一个HTTP请求</li>
<li>2). 服务器收到请求，生成一个HTML文档</li>
<li>3). 服务器把HTML文档作为HTTP响应的Body发送给浏览器</li>
<li>4). 浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示</li>
</ul></li>
<li><p>最简单的Web应用：先把HTML用文件保存好，使用一个HTTP服务器接收用户请求，从文件中直接读取HTML并返回；Apache、Nginx、Lighttpd等这些常见的静态服务器就是这样做的</p></li>
<li><p>若要显示动态的HTML，可以由专门的服务器软件实现接收HTTP请求、解析HTTP请求、发送HTTP响应等底层功能，而我们使用Python或者其他语言专注于生成HTML文档；</p></li>
<li><p>这种让我们专注于编写Web业务的代码，而不必关心TCP连接、HTTP请求响应格式等底层代码的编程接口，称为WSGI（Web Server Gateway Interface）</p></li>
<li><p>WSGI接口定义非常简单，只需要实现一个HTTP处理函数（名称无所谓）就可以响应HTTP请求</p>

<pre><code class="language-python">def app(environ, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])
    # 必须返回一个数组（元素必须为字节类型）
    return [b&#39;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#39;]
</code></pre>

<ul>
<li>上面的app()函数就是符合WSGI标准的一个HTTP处理函数，接收两个参数：

<ul>
<li>environ（包含所有HTTP请求信息的dict对象）</li>
<li>start_response（发送HTTP响应的函数；接收两个参数：HTTP响应状态字符串、HTTP Header的list，元素为tuple）</li>
</ul></li>
<li>在app()函数中，调用start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])就是发送HTTP响应的Header；Header只能发送一次，也就是只能调用一次start_response()函数</li>
<li>app()函数的返回值将作为HTTP响应的Body发送给浏览器</li>
</ul></li>
<li><p>有了WSGI，就只需要从environ中获取到HTTP请求信息，然后构造HTML，调用start_reponse()类似函数发送Header，最后返回Body</p></li>
<li><p>HTTP处理函数必须由WSGI服务器来调用，若手动调用则无法提供所需要的参数，且返回的bytes无法发送给浏览器</p></li>
<li><p>有很多符合WSGI规范的服务器可以使用，Python内置的wsgiref模块就是一个WSGI服务器的参考实现；所谓“参考实现”就是指实现完全符合WSGI标准，但不考虑运行效率，仅供开发测试使用</p>

<pre><code class="language-python"># hello.py，实现Web应用程序的WSGI处理函数
def app(environ, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])
    return [b&#39;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#39;]

# server.py，负责启动WSGI服务器
from wsgiref.simple_server import make_server
from hello import app

def start_myServer():
    # 创建一个服务器（IP为空、端口为8000、处理函数为app）
    httpd = make_server(&#39;&#39;, 8000, app)  
    print(&#39;Serving HTTP on port 8000...&#39;)
    # 开始监听HTTP请求
    httpd.serve_forever()

if __name__ == &#39;__main__&#39;:
    start_myServer()

# 浏览器输入“http://127.0.0.1:8000”进行访问
</code></pre>

<pre><code class="language-python"># 从environ中读取PATH_INFO，显示动态内容
def app(environ, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])
    # print(environ)
    body = &#39;&lt;h1&gt;Hello, %s!&lt;/h1&gt;&#39; % (environ[&#39;PATH_INFO&#39;][1:] or &#39;web&#39;)
    print(body)
    return [body.encode(&#39;utf-8&#39;), b&#39;appendTest&#39;] 

# 浏览器输入“http://127.0.0.1:8000/Tom”进行访问
</code></pre></li>
<li><p>多么复杂的Web应用程序，入口都是WSGI处理函数；但是直接在WSGI处理函数处理太底层了，需要在WSGI之上再抽象出Web框架，进一步简化Web开发</p></li>
<li><p>补充：</p>

<ul>
<li>CGI是一种为用户动态提供所需数据的设计思想，不同语言有着各种不同的实现</li>
<li>WSGI是Python对CGI进行的一种包装，核心使用Python实现</li>
<li>Django、Google webapp等则是在WSGI基础上抽象出的Web框架</li>
</ul></li>
</ul>

<h5 id="toc_4">17.4 使用Web框架</h5>

<ul>
<li>若直接在WSGI处理函数做判断分别处理多个不同的URL请求，这种处理方式比较低级，且代码无法很好维护</li>
<li><p>可以在WSGI接口之上进行抽象，专注于用一个函数处理一个URL，URL到函数自动映射</p>

<ul>
<li>Flask就是这样的Web框架，其通过Python的装饰器在内部把URL和函数给关联起来，简化Web开发</li>
<li>除了Flask，常见的Python Web框架还有Django、web. py、Bottle、Tornado（异步）</li>
</ul>

<pre><code class="language-python"># Flask使用，处理3个URL：
# a. GET /（首页，返回Home）、
# b. GET /signin（登录页，显示登录表单）、
# c. POST /signin（处理登录表单，显示登录结果）
from flask import Flask, request

app = Flask(__name__)

@app.route(&quot;/&quot;, methods=[&#39;GET&#39;, &#39;POST&#39;])
def home():
    return &#39;&lt;h1&gt;Home&lt;/h1&gt;&#39;

@app.route(&#39;/signin&#39;, methods=[&#39;GET&#39;]) # /signin的GET
def signin_form():
    return &#39;&#39;&#39;&lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;
              &lt;p&gt;&lt;input name=&quot;username&quot;&gt;&lt;/p&gt;
              &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;
              &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Sign In&lt;/button&gt;&lt;/p&gt;
              &lt;/form&gt;&#39;&#39;&#39;

@app.route(&#39;/signin&#39;, methods=[&#39;POST&#39;]) # /signin的POST
def signin():
    # 从request对象读取表单内容
    if request.form[&#39;username&#39;] == &#39;admin&#39; and request.form[&#39;password&#39;] ==&#39;password&#39;:
        return &#39;&lt;h3&gt;Hello, admin!&lt;/h3&gt;&#39;
    return &#39;&lt;h3&gt;Bad username or password.&lt;/h3&gt;&#39;

if __name__ == &#39;__main__&#39;:
    app.run()  # 默认值端口5000，app.run(debug=Ture)则以调试模式启动

# 浏览器输入“http://127.0.0.1:5000/”进行访问首页
</code></pre></li>
</ul>

<h5 id="toc_5">17.5 使用模板</h5>

<ul>
<li>使用拼接字符串来生成HTML页面不合理，所以出现了模板技术</li>
<li>使用模板，需要预先准备一个特殊的HTML文档，其嵌入一些变量和指令（比如模板HTML中的<code>{{ NAME }}</code>），然后根据我们传入的数据，替换后得到最终的HTML</li>
<li>Flask默认支持的模板是Jinja2，通过rander_template()函数来实现模板的渲染；<strong>模板HTML一定要放到正确的templates目录，templates和app.py在同级目录下</strong></li>
<li><p>在Jinja2模板中，用 <code>{{ NAME }}</code> 表示一个需要替换的变量，循环、条件判断等指令语句用 <code>{% ... %}</code> 表示</p>

<pre><code># 循环输出页码
{% if i in page_list %}
    &lt;a href=&quot;/page/{{ i }}&quot;&gt;{{ i }}&lt;/a&gt;
{% endfor %}
</code></pre></li>
<li><p>除了Jinja2，常见的Python模板还有Mako、Cheetah、Django</p>

<pre><code class="language-python">from flask import Flask, request, render_template

app = Flask(__name__)

@app.route(&quot;/&quot;, methods=[&#39;GET&#39;, &#39;POST&#39;])
def home():
    return render_template(&#39;home.html&#39;)

@app.route(&#39;/signin&#39;, methods=[&#39;GET&#39;])
def signin_form():
    return render_template(&#39;form.html&#39;);

@app.route(&#39;/signin&#39;, methods=[&#39;POST&#39;])
def signin():
    username = request.form[&#39;username&#39;];
    password = request.form[&#39;password&#39;];
    if username == &#39;admin&#39; and password ==&#39;password&#39;:
        return render_template(&#39;signin-ok.html&#39;, username = username)
    return render_template(&#39;form.html&#39;, message = &#39;Bad username or password&#39;, username = username)

if __name__ == &#39;__main__&#39;:
    app.run()   
</code></pre>

<pre><code class="language-html"># home.html
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Home&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1 style=&quot;font-style:italic&quot;&gt;Home&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<pre><code class="language-html"># form.html
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Please Sign In&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  {% if message %}
  &lt;p style=&quot;color:red&quot;&gt;{{ message }}&lt;/p&gt;
  {% endif %}
  &lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;
    &lt;legend&gt;Please sign in:&lt;/legend&gt;
    &lt;p&gt;&lt;input name=&quot;username&quot; placeholder=&quot;Username&quot; value=&quot;{{ username }}&quot;&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input name=&quot;password&quot; placeholder=&quot;Password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;
    &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Sign In&lt;/button&gt;&lt;/p&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<pre><code class="language-html"># signin-ok.html
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Welcome, {{ username }}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Welcome, {{ username }}!&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p>MVC（Model-View-Controller，模型-视图-控制器）</p>

<ul>
<li>a. Python处理URL的函数就是C（Controller），负责业务逻辑，比如检查用户名是否存在，取出用户信息等</li>
<li>b. 包含变量 <code>{{ NAME }}</code> 的模板就是V（View），负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML</li>
<li>c. Mode是用来传给View的，View在替换变量的时候，从Model中取出相应的数据</li>
<li>d. 因为Python支持关键字参数，很多Web框架允许传入关键字参数，然后在框架内部组装出一个dict作为Model</li>
</ul></li>
<li><p>在Python代码中处理M（Model）和C（Controller），而V（View）通过模板处理，这样就成功地把Python代码和HTML代码最大限度地分离</p></li>
<li><p>使用模板的另一大好处是，模板改起来很方便，而且改完保存后，刷新浏览器就能看到最新的效果</p></li>
</ul>

<h4 id="toc_6">18. 异步IO</h4>

<h5 id="toc_7">18.1 概述</h5>

<ul>
<li>CPU和IO设备的速度严重不匹配，多进程、多线程是解决这一问题的常用办法；而当进程、线程的数量过多时，效率性能也会严重下降</li>
<li><p>异步IO也是一种解决该问题的办法；当代码执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后去执行其他代码，一段时间后，当IO操作返回结果时，再通知CPU进行处理</p>

<ul>
<li><p>异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程</p>

<pre><code class="language-python">loop = get_event_loop()
while True:
    event = loop.get_event()
    process_event(event)
</code></pre></li>
<li><p>消息模型早就出现在桌面应用程序中了；所有的键盘、鼠标等消息都被发送到程序的消息队列中，主线程负责不停地读取消息并处理消息</p></li>
<li><p>在“发出IO请求”到“IO完成”的这段时间里，同步IO模型下主线程只能挂起，在异步IO模型下主线程并没有休息，而是在消息循环中继续处理其他消息</p></li>
<li><p>在异步IO模型中，一个线程可以同时处理多个IO请求却没有切换线程，大大提升多任务处理能力</p></li>
</ul></li>
</ul>

<h5 id="toc_8">18.2 协程（Coroutine）</h5>

<ul>
<li>Python中的<strong>单进程</strong>的<strong>异步编程模型</strong>称为<strong>协程（Coroutine）</strong>，又称为微线程</li>
<li>函数与协程区别：

<ul>
<li>函数（子程序）在所有语言中都是层级调用，通过栈来实现，并且调用总是一个入口一次返回，调用顺序明确；比如A调用B，B在执行过程中又调用C，C执行完毕返回，B执行完毕返回，最后A执行完毕</li>
<li>协程看上去像函数，但是其在执行过程中是可以内部中断（类似于CPU的中断）；然后转而执行别的协程（并不是函数调用），之后在适当的时候再返回来接着执行之前的协程；<strong>协程的执行有点类似多线程执行，但实际上是在一个线程上执行</strong></li>
</ul></li>
<li>协程的优点：

<ul>
<li>执行效率高（协程间的切换不是线程切换，而是由程序自身控制）</li>
<li>不需要多线程的锁机制（一个线程中不存在写变量冲突；共享资源不用加锁，只需判断状态即可）</li>
</ul></li>
<li>在多核CPU情况下，使用“多进程+协程”可以获得极高的性能</li>
<li><strong>Python通过特性generator实现对协程的支持</strong></li>
<li><strong>yield不仅可以返回一个值，还可以接收调用者发出的参数（通过send()方法发送的，即send()方法可调用协程）</strong></li>
<li><strong>仅仅只有协程是不够的，还不足以实现异步IO，还需要消息循环和状态的控制</strong></li>
<li><p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但是一不小心可能产生死锁；可以通过generator，生产者生产消息后，直接通过send跳转到消费者开始执行，待消费者执行完毕后，yield返回到生产者继续生产</p>

<pre><code class="language-python"># 生产者-消费者模型（注意：这里还不是协程，只是generator）
def consumer():
    r = &#39;&#39;
    while True:
        # 为了让n接收数据，先yield一下
        # r将消费结果返回，n记录下一次调用send()方法传递的参数
        n = yield r
        if not n:
            return
        print(&#39;Consumer consuming %s ...&#39; % n)
        r = &#39;OK %s&#39; % n

def producer(c):
    c.send(None)
    for i in range(1, 4):
        print(&#39;Producer producing %s ...&#39; % i)
        r = c.send(i)  # i从1开始
        print(&#39;Producer, Consumer return: %s&#39; % r)
    c.close()

c = consumer()
producer(c)

# 执行结果
Producer producing 1 ...
Consumer consuming 1 ...
Producer, Consumer return: OK 1
Producer producing 2 ...
Consumer consuming 2 ...
Producer, Consumer return: OK 2
Producer producing 3 ...
Consumer consuming 3 ...
Producer, Consumer return: OK 3
</code></pre></li>
</ul>

<h5 id="toc_9">18.3 asyncio</h5>

<ul>
<li>asyncio是Python 3.4引入的标准库，直接内置了对异步IO的支持</li>
<li><p>asyncio的编程模型就是一个消息循环，从asyncio中直接获取EventLoop，然后把需要执行的协程放到EventLoop中执行，就实现异步IO</p>

<pre><code class="language-python">import asyncio
import threading

# 这才是一个协程
@asyncio.coroutine
def hello():
    print(&#39;Hello World: (%s)...&#39; % threading.current_thread())
    # 执行EventLoop中其他可执行的协程
    r = yield from asyncio.sleep(3) 
    print(r)
    print(&#39;Hello Again: (%s)...&#39; % threading.current_thread())

# 获取EventLoop
loop = asyncio.get_event_loop()

# 将coroutine加入到EventLoop，并
loop.run_until_complete(asyncio.wait([hello(), hello()]))
loop.close()

# 执行结果
Hello World: (&lt;_MainThread(MainThread, started 140735154606080)&gt;)...
Hello World: (&lt;_MainThread(MainThread, started 140735154606080)&gt;)...
（暂停了3秒）
None
Hello Again: (&lt;_MainThread(MainThread, started 140735154606080)&gt;)...
None
Hello Again: (&lt;_MainThread(MainThread, started 140735154606080)&gt;)...
</code></pre></li>
<li><p><strong>@asyncio.coroutine: 把一个generator标记为coroutine（协程）类型</strong></p>

<ul>
<li><strong>协程不能直接运行，需要把协程加入到EventLoop，由其在适当的时候调用</strong></li>
</ul></li>
<li><p><strong>yield from asyncio.sleep(3)：中断当前协程并执行下一个消息循环（即去执行EventLoop中其他可执行的协程），当asyncio.sleep(3)返回后，才接着执行之后的代码</strong></p>

<ul>
<li>yield from XX: XX必须为Iterable，本质是遍历XX并分别yield</li>
<li>asyncio.sleep(3)也是一个协程（协程也是generator）</li>
<li>不能使用time模块的sleep，其会阻塞整个线程</li>
<li><strong>asyncio模块的sleep的内部实现是注册一个定时器在EventLoop中，把CPU的控制权交给其他协程</strong></li>
<li><strong>在此例中，让出时间为3秒给其他协程执行，3秒后asyncio.sleep(3)执行完，执行结果被yield给EventLoop，EventLoop再调用返回到当前协程中（这里调用参数为None，由r来接收），这里先不关心其他协程有没有执行完；可以把asyncio.sleep(3)看成一个耗时3秒的IO操作</strong></li>
</ul></li>
<li><p>asyncio.wait()：多个协程需要使用其包装一下</p></li>
<li><p>run_until_complete()：将协程加入到EventLoop（本质将协程包装成为了一个任务task），并启动EventLoop</p></li>
<li><p><strong>异步操作需要在coroutine中通过yield from完成，多个coroutine封装一起然后并发执行</strong></p>

<pre><code class="language-python"># 异步网络连接来获取sina、sohu、163的首页
import asyncio

@asyncio.coroutine
def wget(host):
    print(&#39;wget %s...&#39; % host)
    # 获取输入、输出流，连接耗时
    reader, writer = yield from asyncio.open_connection(host, 80)

    # 只请求头部信息
    header = &#39;HEAD / HTTP/1.0\r\nHost: %s\r\n\r\n&#39; % host  
    writer.write(header.encode(&#39;utf-8&#39;))
    # 完全写入耗时（drain:排水、流干）
    yield from writer.drain() 

    while True:
        # 读取耗时
        line = yield from reader.readline()
        if line == b&#39;\r\n&#39;:
            break

        # rstrip()删除str末尾的指定字符(默认为空格)
        print(&#39;%s header &gt; %s&#39; % (host, line.decode(&#39;utf-8&#39;).rstrip()))
    writer.close()  # close the socket

loop = asyncio.get_event_loop()
wgetList = [wget(host) for host in [&#39;www.sina.com.cn&#39;, &#39;www.sohu.com&#39;, &#39;www.163.com&#39;]]
loop.run_until_complete(asyncio.wait(wgetList))
loop.close()
</code></pre></li>
</ul>

<h5 id="toc_10">18.4 async/await</h5>

<ul>
<li>使用asyncio的@asyncio.coroutine把一个generator标记为coroutline类型，然后在coroutline内部使用yield from调用另一个coroutine实现异步操作</li>
<li><p>为了简化使用和代码简洁，Python 3.5引入新的语法 <code>async（代替@asyncio.coroutine）</code> 和 <code>await（代替yield from）</code></p>

<pre><code class="language-python">import asyncio
import threading

async def hello():
    print(&#39;Hello World: (%s)...&#39; % threading.current_thread())
    r = await asyncio.sleep(3)
    print(r)
    print(&#39;Hello Again: (%s)...&#39; % threading.current_thread())
</code></pre></li>
</ul>

<h5 id="toc_11">18.5 aiohttp</h5>

<ul>
<li>把asyncio（实现单线程并发IO操作）应用在Web服务器，可以实现多用户的高并发支持（HTTP连接就是IO操作）</li>
<li><p>aiohttp是基于asyncio实现的HTTP框架；asyncio实现了TCP、UDP、SSL等协议，loop_create_server()则利用asyncio创建TCP服务</p>

<pre><code class="language-python"># 编写Web应用：
# /（首页返回b&#39;&lt;h1&gt;Index&lt;/h1&gt;&#39;）、
# /hello/{name}（根据URL参数返回文本hello, %s!）
import asyncio
from aiohttp import web

async def index(request):
    await  asyncio.sleep(0.5)
    return web.Response(body=b&#39;&lt;h1&gt;Index&lt;/h1&gt;&#39;)

async def hello(request):
    await asyncio.sleep(0.5)
    text = &#39;&lt;h1&gt;hello, %s!&lt;/h1&gt;&#39; % request.match_info[&#39;name&#39;]
    return web.Response(body=text.encode(&#39;utf-8&#39;))

async def init(loop):
    app = web.Application(loop=loop)
    app.router.add_route(&#39;GET&#39;, &#39;/&#39;, index)
    app.router.add_route(&#39;GET&#39;, &#39;/hello/{name}&#39;, hello)
    # 若需要其他设备访问，ip设为0.0.0.0
    svr = await loop.create_server(app.make_handler(), &#39;127.0.0.1&#39;, 8000)
    return srv

loop = asyncio.get_event_loop()
loop.run_until_complete(init(loop))
loop.run_forever()
</code></pre></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(15网络编程、16访问数据库)]]></title>
    <link href="http://www.justisit.com/15125773962317.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773962317.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">15. 网络编程</a>
<ul>
<li>
<a href="#toc_1">15.1 TCP/IP简介</a>
</li>
<li>
<a href="#toc_2">15.2 TCP编程</a>
</li>
<li>
<a href="#toc_3">15.3 UDP编程</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">16. 访问数据库</a>
<ul>
<li>
<a href="#toc_5">16.1 概述</a>
</li>
<li>
<a href="#toc_6">16.2 SQLite</a>
</li>
<li>
<a href="#toc_7">16.3 MySQL</a>
</li>
<li>
<a href="#toc_8">16.4 使用SQLAlchemy</a>
</li>
</ul>
</li>
</ul>


<h4 id="toc_0">15. 网络编程</h4>

<h5 id="toc_1">15.1 TCP/IP简介</h5>

<ul>
<li>为了实现把全世界的所有不同类型的计算机都连接起来，规定了一套全球通用的协议（互联网协议簇，Internet Protocol Suite）</li>
<li>互联网协议簇包含了上百种协议标准，但最重要的两个协议是TCP和IP协议，故把互联网协议簇简称TCP/IP协议</li>
<li>IP协议负责把包数据从一台计算机通过网络发送到另一台计算机

<ul>
<li>IP包数据会被按块发送，途径多个路由，但不保证能到达，也不保证顺序到达</li>
<li>传输数据时，双方必须知道对方的互联网上的唯一标识IP地址</li>
<li>IPv4地址为32bit位数字，通常使用点分十进制表示（192.168.0.1）</li>
<li>IPv6地址为128bit为数字，通常使用冒号分十六进制表示（2001:0db8:85a3:0042:1000:8a2e:0370:7334）</li>
</ul></li>
<li>TCP协议负责两台计算机之间建立可靠连接，保证数据包按顺序到达

<ul>
<li>TCP协议是建立在IP协议之上的</li>
<li>TCP协议通过握手建立连接，然后对每个IP包编号，确保对方按顺序收到，若IP包丢失则自动重发</li>
<li>许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等</li>
</ul></li>
<li>端口是用来区分同一台计算机上运行的不同网络程序，每个网络程序都会向系统申请可用的端口号

<ul>
<li>一个IP包除了包含要传输的数据外，还包含源IP和目标IP，源端口和目标端口</li>
<li>计算机之间的两个进程在建立网络连接，就需要各自的的IP及端口</li>
<li>一个进程也可能同时与其他多个计算机建立链接，因此可以同时申请多个端口</li>
<li>一个端口被占用了，就不可以再被使用了；TCP的端口和UDP的端口之间是独立的，可以使用相同的端口号</li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->

<h5 id="toc_2">15.2 TCP编程</h5>

<ul>
<li>Socket是网络编程的一个抽象概念，通常用一个Socket表示“打开了一个网络链接”

<ul>
<li>创建Socket时，指定IPv4协议使用 <code>AF_INET</code>，指定IPv6协议使用 <code>AF_INET6</code>；指定使用TCP协议使用 <code>SOCK_STREAM</code>，指定使用UDP协议使用<code>SOCK_DGRAM</code></li>
<li>创建成功Socket后，还需要手动建立连接</li>
<li>多数连接都是使用可靠的TCP连接；创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器</li>
<li>作为服务器提供什么样的服务，端口就必须固定下来；比如，常用的HTTP的端口为80，FTP的端口为21</li>
<li>端口号小于1024的是Internet标准服务端口，端口号大于1024的可以任意使用</li>
</ul></li>
<li><p>TCP连接创建的是双向通道，双方都可以同时给对方发送数据</p>

<ul>
<li>但是谁先发送谁后发，怎么协调，要根据具体的协议来决定；比如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发送数据给客户端</li>
<li>调用recv(max)方法接收数据，一次最多接收指定数量的字节数据；因此，需要在一个while循环中反复进行接收数据，直到recv()返回空数据表示接收完毕，退出循环</li>
<li>接收完毕数据后，调用close()方法关闭Socket，这样一次完整的网络通信就结束了</li>
</ul>

<pre><code class="language-python"># 创建一个基于TCP连接的Socket
import socket  # 导入socket库

# 创建一个socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
# 建立连接, 注意参数是个tuple
s.connect((&#39;www.sina.com.cn&#39;, 80))
# 发送符合HTTP标准格式的数据（进行GET请求）
s.send(b&#39;GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n&#39;)  

# 接收数据
buffer = []
while True:
    # 每次最多接收1k数据
    d = s.recv(1024)
    if d:
        buffer.append(d)
    else:
        break
data = b&#39;&#39;.join(buffer)
# 关闭连接
s.close() 

# 处理接收到的数据
header, html = data.split(b&#39;\r\n\r\n&#39;, 1)
print(header.decode(&#39;utf-8&#39;))
with open(&#39;sina.html&#39;, &#39;wb&#39;) as f:
    f.write(html)
</code></pre></li>
<li><p>服务器端的进程需要先开启一个端口，并监听来自其他客户端的连接</p>

<ul>
<li>若某个客户端连接过来，服务器就与该客户端建立一个Socket连接，随后的通信就靠这个Socket连接</li>
<li>服务器可以区分不同的客户端，一个Socket连接唯一确定一个客户端</li>
<li>一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口</li>
<li>服务器需要同时响应多个客户端的请求；所以，每个连接都需要一个新的进程或新的线程来处理，否则，服务器在处理连接的过程中，无法接受其他客户端的连接</li>
</ul>

<pre><code class="language-python"># 案例：服务器将客户端发的字符串加上Hello再发回去
# tcp_server.py
import socket, threading, time

def tcplink(sock, addr):
    print(&#39;Accept new connection from %s:%s&#39; % addr)
    sock.send(b&#39;Welcome!&#39;)
    while True:
        d = sock.recv(1024)
        time.sleep(1)
        if not d or d.decode(&#39;utf-8&#39;) == &#39;exit&#39;:
            break
        d = (&#39;Hello, %s!&#39; % d.decode(&#39;utf-8&#39;)).encode(&#39;utf-8&#39;)
        sock.send(d)
    sock.close()
    print(&#39;Connection from %s:%s closed.&#39; % addr)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 绑定端口
s.bind((&#39;127.0.0.1&#39;, 9999))
# 调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量
s.listen(5)
print(&#39;Waiting for connection...&#39;)

# 服务器通过一个永久循环来接受客户端的连接，
# accept()会等待连接（阻塞线程）并返回一个客户端的连接
while True:
    sock, addr = s.accept()  # 接受一个新的TCP连接
    # 创建新线程来处理TCP连接
    t = threading.Thread(target=tcplink, args=(sock, addr))
    t.start()
</code></pre>

<pre><code class="language-python"># tcp_client.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((&#39;127.0.0.1&#39;, 9999))
print(s.recv(1024).decode(&#39;utf-8&#39;))
for data in [b&#39;Tom&#39;, b&#39;Jack&#39;, b&#39;HaHa&#39;]:
    s.send(data)
    print(s.recv(1024).decode(&#39;utf-8&#39;))
s.send(b&#39;exit&#39;)
s.close()
</code></pre></li>
</ul>

<h5 id="toc_3">15.3 UDP编程</h5>

<ul>
<li>TCP协议是建立可靠连接，并且通信双方都可以以流的形式发送数据；而UDP协议则是面向无连接的协议

<ul>
<li>使用UDP协议不需要建立连接，只需要知道对方的IP及端口，就可以直接发送数据包，但是不能确定数据包师傅到达</li>
<li>虽然使用UDP传输数据不可靠，但它的优点是比TCP速度快；对于不要求可靠到达的数据，就可以使用UDP</li>
</ul></li>
<li><p>和TCP类似，使用UDP的通信双方也分为客户端和服务器，服务器也需要先绑定端口，但不需要监听了</p>

<pre><code class="language-python"># udp_server.py
import socket

# 使用socket.SOCK_DGRAM指明是UDP
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
# 绑定端口（不需要调用listen()方法，而是直接接收任何客户端的数据）
s.bind((&#39;127.0.0.1&#39;, 9999))
print(&#39;Bind UDP on 9999...&#39;)
while True:
    # recvfrom()方法接收数据，返回值为客户端的地址与端口，
    # 这样服务器就能使用sendto()方法返回数据给客户端
    data, addr = s.recvfrom(1024)
    print(&#39;Received from %s:%s&#39; % addr)
    s.sendto(b&#39;Hello, %s!&#39; % data, addr)
</code></pre></li>
<li><p>客户端使用UDP时，首先创建基于UDP的Socket，然后直接通过sendto()给服务器发送数据，不需要调用connect()进行连接</p>

<pre><code class="language-python"># udp_client.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
for data in [b&#39;Tom&#39;, b&#39;Jack&#39;, b&#39;HaHa&#39;]:
    # 发送数据
    s.sendto(data, (&#39;127.0.0.1&#39;, 9999))
    # 接收数据（从服务器端接收数据仍然调用recv()方法）
    print(s.recv(1024).decode(&#39;utf-8&#39;))
s.close()
</code></pre></li>
</ul>

<h4 id="toc_4">16. 访问数据库</h4>

<h5 id="toc_5">16.1 概述</h5>

<ul>
<li>数据库类型：关系型数据库（Oracle、MySQL、SQLite、SQL Server等）、NoSQL（非关系型数据库）</li>
</ul>

<h5 id="toc_6">16.2 SQLite</h5>

<ul>
<li>要操作关系型数据库，首先要连接数据库，一个数据库连接称为Connection</li>
<li>连接到数据库后，打开游标Cursor，通过Cursor执行SQL语句，然后获取执行结果</li>
<li>Python定义了一套操作数据库的API接口；只需要提供符合Python标准的数据库驱动，即可通过Python连接到任何数据库</li>
<li><p>Python标准库内置了SQLite3驱动，可以直接使用</p>

<pre><code class="language-python"># sqlite使用
import sqlite3  # 导入SQLite驱动

# 连接到SQLite数据库，数据库文件test.db若不存在则在当前目录进行创建
conn = sqlite3.connect(&#39;test.db&#39;)
# 创建一个cursor
cursor = conn.cursor()

# 执行创建user表的sql
cursor.execute(&#39;create table user (id varchar(20) primary key, name varchar(20))&#39;)
# 执行插入一条记录的sql
cursor.execute(&#39;insert into user (id, name) values (\&#39;1\&#39;, \&#39;Tom\&#39;)&#39;)
# 通过rowcount获取上面执行sql后影响的行数
cursor.rowcount # 1

# 执行查询sql
cursor.execute(&#39;select * from user where id=?&#39;, (&#39;1&#39;,))
# 获取查询结果集
values = cursor.fetchall() # [(&#39;1&#39;, &#39;Tom&#39;)]
# 再次获取为空
values = cursor.fetchall() # []

# 关闭cursor
cursor.close()
# 提交事务
conn.commit()
# 关闭连接
conn.close()
</code></pre></li>
<li><p>对Cursor执行insert、update、delete语句后，影响的行数由rowcount返回</p></li>
<li><p>对Cursor执行select语句后，通过featchall()获取结果集；结果集是一个list，每一个元素都是一个tuple，对应表中一行记录</p></li>
<li><p>若sql语句带有参数，需要把参数按照位置传递给execute()方法，有几个?占位符就必须对应几个参数，参数以tuple形式提供：<br/>
<code>cursor.execute(&#39;select * from user where name=? and pwd=?&#39;, (&#39;abc&#39;, &#39;password&#39;))</code></p></li>
<li><p>执行产生数据库变化的操作要进行commit()提交事务</p></li>
<li><p>打开的Connection对象、Cursor对象要被正确地关闭，否则就会泄漏资源；可使用 <code>try...except...finally...</code> ，确保在出错的情况也能关闭掉Cursor对象、Connection对象</p>

<pre><code class="language-python"># 练习：根据分数段查找指定的名字
import os, sqlite3

db_file = os.path.join(os.path.dirname(__file__), &#39;test.db&#39;)
if os.path.isfile(db_file):
    os.remove(db_file)

# 初始数据
conn = sqlite3.connect(db_file)
cursor = conn.cursor()
cursor.execute(&#39;create table user(id varchar(20) primary key, name varchar(20), score int)&#39;)
cursor.execute(r&quot;insert into user values (&#39;A-001&#39;, &#39;Adam&#39;, 95)&quot;)
cursor.execute(r&quot;insert into user values (&#39;A-002&#39;, &#39;Bart&#39;, 62)&quot;)
cursor.execute(r&quot;insert into user values (&#39;A-003&#39;, &#39;Lisa&#39;, 78)&quot;)
cursor.close()
conn.commit()
conn.close()

def get_score_in(low, high):
    # 返回指定分数区间的名字，按分数从低到高排序
    try:
        conn = sqlite3.connect(db_file)
        cursor = conn.cursor()
        cursor.execute(&#39;select name from user where score &gt;= ? and score &lt;= ?&#39;, (low, high))
        values = cursor.fetchall()
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()
    return [v[0] for v in values]

# 测试
assert get_score_in(80, 95) == [&#39;Adam&#39;], &quot;%s失败&quot; % get_score_in(80, 95)
assert get_score_in(60, 80) == [&#39;Bart&#39;, &#39;Lisa&#39;], &quot;%s失败&quot; % get_score_in(60, 80)
assert get_score_in(60, 100) == [&#39;Bart&#39;, &#39;Lisa&#39;, &#39;Adam&#39;], &quot;%s失败&quot; % get_score_in(60, 100)
print(&#39;Pass&#39;)
</code></pre></li>
</ul>

<h5 id="toc_7">16.3 MySQL</h5>

<ul>
<li>MysQL数据库默认的编码为UTF-8，执行SQL语句 <code>show variables like &#39;%char%&#39;;</code> 可以查询配置的编码格式</li>
<li>my.cnf为MySQL的配置文件，若要修改编码格式可以修改此文件；修改文件后需要重启MySQL</li>
<li><p>若MySQL的版本&gt;=5.5.3，可以将编码设置为utf8mb4（和utf8完全兼容），该编码支持最新的Unicode标准，可以存储显示emoji字符</p>

<pre><code>[client]
default-character-set = utf8mb4

[mysqld]
character-set-server = utf8mb4
collation-server = utf8mb4_general_ci
</code></pre>

<pre><code class="language-sql"># SQL语句
show databases;  # 查询所有的数据库
use test;  # 使用test数据库
show tables;  # 查询当前数据库下的所有的表
describe 表名;  # 显示表的数据结构
</code></pre></li>
<li><p>MySQL服务器以独立的进程运行，并通过网络对外服务，所以Python需要MySQL驱动来连接MySQL服务器</p></li>
<li><p>MySQL提供了官方驱动mysql-connector-python，但是在安装的时候需要给pip命令添加参数-allow-external，安装命令为<code>pip install mysql-connector-python --allow-external mysql-connector-python</code>，或者手动安装</p></li>
<li><p>Python的DB API定义都是通用的，所以操作MySQL和SQLite类似；不过，MySQL使用的占位符是%s，SQLite使用的是?</p>

<pre><code class="language-python">import mysql.connector

conn = mysql.connector.connect(user=&#39;root&#39;, password=&#39;&#39;, database=&#39;test&#39;)
cursor = conn.cursor()

cursor.execute(&#39;create table user (id varchar(20) primary key, name varchar(20))&#39;)
cursor.execute(&#39;insert into user (id, name) values (%s, %s)&#39;, [&#39;1&#39;, &#39;Tom&#39;])
cursor.rowcount # 1

cursor.close() 
conn.commit()

cursor = conn.cursor()
cursor.execute(&#39;select * from user where id = %s&#39;, (&#39;1&#39;,))
values = cursor.fetchall() # [(&#39;1&#39;, &#39;Tom&#39;)]

cursor.close()
conn.close()
</code></pre></li>
</ul>

<h5 id="toc_8">16.4 使用SQLAlchemy</h5>

<ul>
<li><p>ORM（Object-Relational Mapping）：把关系数据库的表结构映射到对象上；Python中最有名的ORM框架是SQLAlchemy</p>

<pre><code class="language-python">from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, String, create_engine
from sqlalchemy.orm import sessionmaker

# 第1步：创建基类Base
Base = declarative_base()

# 定义User，继承Base
class User(Base):
    # 表的名称
    __tablename__ = &#39;user&#39;

    # 表的结构
    id = Column(String(20), primary_key=True)
    name = Column(String(20))

# 第2步：初始化数据库连接，创建DBSession
engine = create_engine(&#39;mysql+mysqlconnector://root:@localhost:3306/test&#39;)
DBSession = sessionmaker(bind=engine)
</code></pre>

<ul>
<li>上述代码完成了SQLAlchemy的初始化和具体每个表的class定义</li>
<li><strong>create_engine()用于初始化数据库连接，SQLAlchemy用一个字符串表示连接信息，格式如下：<code>数据库类型+数据库驱动名称://用户名:口令@机器地址:端口/数据库库名</code></strong></li>
</ul>

<pre><code class="language-python"># 第3步：创建DBSession对象
session = DBSession()

# 第4步：创建User，添加到session
new_user = User(id=&#39;5&#39;, name=&#39;Bob&#39;)
session.add(new_user)

# 第5步：提交(保存)到数据库
session.commit()

# 第6步：关闭session
session.close()
</code></pre>

<ul>
<li>DBSession对象可以视为当前数据库连接</li>
<li>向数据库表中添加一行记录（添加一个User对象），需要先获取session，然后把对象添加到session，最后提交并关闭</li>
</ul>

<pre><code class="language-python">session = DBSession()

# 创建Query查询，filter是where条件；
# 调用one()返回唯一行，调用all()返回所有行；
# 从数据库中查询出来的不再是tuple，而是User对象
user = session.query(User).filter(User.id==&#39;5&#39;).one()

print(&#39;type:&#39;, type(user)) # type: &lt;class &#39;__main__.User&#39;&gt;
print(&#39;name:&#39;, user.name) # name: Bob
session.close()
</code></pre></li>
<li><p>数据库的多个表可以用外键实现一对多、多对多等关联；相应的，ORM框架也可以提供两个对象之间的一对多、多对多等功能</p>

<pre><code class="language-python">from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, String, ForeignKey
from sqlalchemy.orm import relationship

Base = declarative_base()

class User(Base):
    __tablename__ = &#39;user&#39;

    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    # 一对多
    book = relationship(&#39;Book&#39;)

class Book(Base):
    __tablename__ = &#39;book&#39;

    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    # &quot;多&quot;的一方的book表是通过外键关联到user表的
    user_id = Column(String(20), ForeignKey(&#39;user.id&#39;))

# 当查询到一个User对象时，其books属性是一个包含若干个Book对象的list
</code></pre></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(13常见内建模块(下)、14常用第三方模块)]]></title>
    <link href="http://www.justisit.com/15125773962250.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773962250.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">13. 常见内建模块(下)</a>
<ul>
<li>
<a href="#toc_1">13.5 hashlib</a>
</li>
<li>
<a href="#toc_2">13.6 itertools</a>
</li>
<li>
<a href="#toc_3">13.7 ParserCreate（XML）</a>
</li>
<li>
<a href="#toc_4">13.8 HTMLParser（HTML）</a>
</li>
<li>
<a href="#toc_5">13.9 urllib</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">14. 常用第三方模块</a>
<ul>
<li>
<a href="#toc_7">14.1 概述</a>
</li>
<li>
<a href="#toc_8">14.2 PIL</a>
</li>
<li>
<a href="#toc_9">14.3 virturalenv</a>
</li>
</ul>
</li>
</ul>


<h4 id="toc_0">13. 常见内建模块(下)</h4>

<h5 id="toc_1">13.5 hashlib</h5>

<ul>
<li><p>hashlib提供了常见的摘要算法（如MD5、SHA等）；摘要算法又称为哈希算法、散列算法，通过把任意长度的数据转换为一个长度固定的字符串（16进制表示的字符串）</p>

<pre><code class="language-python">import hashlib

md5 = hashlib.md5()
# 先转成字节，再进行hash
md5.update(&#39;how to use md5 in python hashlib?&#39;.encode(&#39;utf-8&#39;))
m = md5.hexdigest()
print(m)  # d26a53750bc40b38b65a520292f69306

# 若数据量较大，可分多次调用update()，最后计算的结果是一样的
md5 = hashlib.md5()
md5.update(&#39;how to use md5 in &#39;.encode(&#39;utf-8&#39;))
md5.update(&#39;python hashlib?&#39;.encode(&#39;utf-8&#39;))
m = md5.hexdigest()
print(m)  # d26a53750bc40b38b65a520292f69306
</code></pre></li>
</ul>

<span id="more"></span><!-- more -->

<ul>
<li>MD5生成的结果是固定的128bit，通常用一个32位的16进制字符串表示；SHA1的结果是160bit，通常用一个40位的16进制字符串表示</li>
<li><p>比SHA1更安全的算法是SHA256和SH512；不过，越安全的算法不仅生成越慢，而且摘要长度更长</p>

<pre><code class="language-python">sha1 = hashlib.sha1()
sha1.update(&#39;how to use md5 in &#39;.encode(&#39;utf-8&#39;))
sha1.update(&#39;python hashlib?&#39;.encode(&#39;utf-8&#39;))
m = sha1.hexdigest()
print(m)  # b752d34ce353e2916e943dc92501021c8f6bca8c
</code></pre></li>
<li><p>摘要算法应用：</p>

<ul>
<li>网站存储用户登录的用户名和口令信息，其中口令信息是口令的摘要（如MD5），防止数据库泄漏或被人为查看；用户登录时对用户输入的明文口令先进行MD5运算，之后再和数据库存储的MD5进行对比</li>
<li>常见字符串（如123）的MD5、SHA1容易被破解，一般会对原始口令加一个复杂字符串后再进行MD5、SHA1，俗称“加盐（Salt）”，这样就很难通过MD5、SHA1反推常见字符串明文口令</li>
<li>若两个用户使用相同口令，则MD5值一样，这时可以使用用户登录名作为Salt，这样相同口令加不同的Salt得到不同的MD5值</li>
</ul></li>
<li><p><strong>摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改；但是它的单向计算特性决定了可以在不存储明文口令的情况下++验证++用户口令</strong></p>

<pre><code class="language-python"># 举例：模拟用户注册登录
import hashlib

db = {}
def calc_md5(password, salt):
    md5 = hashlib.md5()
    md5.update(password.encode(&#39;utf-8&#39;))
    md5.update(salt.encode(&#39;utf-8&#39;))
    return md5.hexdigest()

def register(username, password):
    db[username] = calc_md5(password, username)
    print(&#39;register successfully!&#39;)
    print(db)
    login(username, password)

def login(username, password):
    if username in db:
        if db[username] == calc_md5(password, username):
            print(&#39;%s login successfully!&#39; % username)
        else:
            print(&#39;password incorrect!&#39;)
    else:
        print(&#39;%s don\&#39;t exist!&#39; % username)
        print(&#39;registing..&#39;)
        register(username, password)

if __name__ == &#39;__main__&#39;:
    username = input(&#39;Your username: &#39;)
    password = input(&#39;Your password: &#39;)
    login(username, password)
</code></pre></li>
</ul>

<h5 id="toc_2">13.6 itertools</h5>

<ul>
<li>itertools模块提供一些非常有用的处理迭代功能的函数，它们的返回值不是list，而是Iterator，只有进行循环迭代的时候才开始真正计算</li>
<li><p>“无限”迭代器：count()、cycle()、repeat()</p>

<pre><code class="language-python">import itertools

# count()：创建一个无限的迭代器，遍历时无法停止，只能强行退出
natuals = itertools.count(1) # 1表示从数字1开始
for n in natuals:
    print(n)

# cycle()：把一个序列中的元素无限重复下去（字符串也是序列的一种）
cs = itertools.cycle(&#39;ABC&#39;)
for c in cs:
    print(c)

# repeat()：把一个元素无限重复下去，第2个参数可以限定重复次数
ns = itertools.repeat(&#39;A&#39;, 3)
for n in ns:
    print(n)
</code></pre>

<pre><code class="language-python">natuals = itertools.count(1)
# 通常使用takewhile()等函数根据条件判断来截取出一个有限的序列
ns = itertools.takewhile(lambda x: x &lt; 10, natuals)
l = list(ns)
print(l)
</code></pre></li>
<li><p>迭代组合：chian()、groupby()</p>

<pre><code class="language-python"># chian()：把一组迭代对象串联起来，形成一个更大的迭代器
for c in itertools.chain(&#39;ABC&#39;, &#39;XYZ&#39;):
    print(c) # 迭代效果：&#39;A&#39; &#39;B&#39; &#39;C&#39; &#39;X&#39; &#39;Y&#39; &#39;Z&#39;

# groupby()：把迭代对象中“相邻的”并且重复的元素挑出来放在一起
for key, group in itertools.groupby(&#39;AAABBBCCAAA&#39;):
    print(key, list(group))
# 输出结果
A [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;]
B [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;]
C [&#39;C&#39;, &#39;C&#39;]
A [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;]
</code></pre></li>
<li><p>groupby()的挑选规则实际上是通过函数完成的，只要两个元素的函数返回值相同，这两个元素就被认为是在一组的，函数返回值作为这组的key</p>

<pre><code class="language-python"># 忽略大小写分组
for key, group in itertools.groupby(&#39;AaaBBbcCAAa&#39;, lambda c: c.upper()):
    print(key, list(group))

# 输出结果
A [&#39;A&#39;, &#39;a&#39;, &#39;a&#39;]
B [&#39;B&#39;, &#39;B&#39;, &#39;b&#39;]
C [&#39;c&#39;, &#39;C&#39;]
A [&#39;A&#39;, &#39;A&#39;, &#39;a&#39;]
</code></pre></li>
</ul>

<h5 id="toc_3">13.7 ParserCreate（XML）</h5>

<ul>
<li>操作XML有两种方法：DOM和SAX

<ul>
<li>DOM：将整个XML读入内存解析为树；优点是可以任意遍历树的节点，缺点是占用内存大解析慢</li>
<li>SAX：流模式，边读边解析；优点是占用内存小解析快，缺点是需要自己处理事件；一般情况下，优先考虑SAX</li>
</ul></li>
<li>在Python中使用SAX解析XML，只需要类似start_element、end_element、char_data三个回调函数（函数名可以任意）就可以解析了</li>
<li><p>当SAX解析器读到一个节点时，比如，<code>&lt;p name=&quot;p&quot;&gt;python&lt;/p&gt;</code> 会产生3个事件：start_element事件（读取到<code>&lt;p name=&quot;p&quot;&gt;</code>时）、char_data事件（读取到<code>python</code>时）、end_element事件（读取到<code>&lt;/p&gt;</code>时）</p>

<pre><code class="language-python"># 解析XML
from xml.parsers.expat import ParserCreate

class MySaxHandler(object):
    def start_element(self, name, attrs):
        print(&#39;sax:start_element: %s, attrs: %s&#39; % (name, attrs))

    def end_element(self, name):
        print(&#39;sax:end_element: %s&#39; % name)

    def char_data(self, text):
        print(&#39;sax:char_data: %s&#39; % text)

xml = r&#39;&#39;&#39;&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;/python&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/ruby&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&#39;&#39;&#39;

parser = ParserCreate()
# 设置处理函数
handler = MySaxHandler()
parser.StartElementHandler = handler.start_element
parser.EndElementHandler = handler.end_element
parser.CharacterDataHandler = handler.char_data
parser.Parse(xml)

# 读取大段字符串时，CharacterDataHandler可能被多次调用，
# 可以人为先保存一下，之后在EndElementHandler中合并
</code></pre></li>
<li><p>生成XML最简单有效的方法就是拼接字符串</p>

<pre><code class="language-python"># 生成XML
l = []
l.append(r&#39;&lt;?xml version=&quot;1.0&quot;?&gt;&#39;)
l.append(r&#39;&lt;root&gt;&#39;)
l.append(&#39;abc&#39;)
l.append(r&#39;&lt;/root&gt;&#39;)
s = &#39;&#39;.join(l)
print(s)
</code></pre>

<pre><code class="language-python"># 练习：解析天气XML
data = r&#39;&#39;&#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot; ?&gt;
&lt;rss version=&quot;2.0&quot; xmlns:yweather=&quot;http://xml.weather.yahoo.com/ns/rss/1.0&quot; xmlns:geo=&quot;http://www.w3.org/2003/01/geo/wgs84_pos#&quot;&gt;
    &lt;channel&gt;
        &lt;title&gt;Yahoo! Weather - Beijing, CN&lt;/title&gt;
        &lt;lastBuildDate&gt;Wed, 27 May 2015 11:00 am CST&lt;/lastBuildDate&gt;
        &lt;yweather:location city=&quot;Beijing&quot; region=&quot;&quot; country=&quot;China&quot;/&gt;
        &lt;yweather:units temperature=&quot;C&quot; distance=&quot;km&quot; pressure=&quot;mb&quot; speed=&quot;km/h&quot;/&gt;
        &lt;yweather:wind chill=&quot;28&quot; direction=&quot;180&quot; speed=&quot;14.48&quot; /&gt;
        &lt;yweather:atmosphere humidity=&quot;53&quot; visibility=&quot;2.61&quot; pressure=&quot;1006.1&quot; rising=&quot;0&quot; /&gt;
        &lt;yweather:astronomy sunrise=&quot;4:51 am&quot; sunset=&quot;7:32 pm&quot;/&gt;
        &lt;item&gt;
            &lt;geo:lat&gt;39.91&lt;/geo:lat&gt;
            &lt;geo:long&gt;116.39&lt;/geo:long&gt;
            &lt;pubDate&gt;Wed, 27 May 2015 11:00 am CST&lt;/pubDate&gt;
            &lt;yweather:condition text=&quot;Haze&quot; code=&quot;21&quot; temp=&quot;28&quot; date=&quot;Wed, 27 May 2015 11:00 am CST&quot; /&gt;
            &lt;yweather:forecast day=&quot;Wed&quot; date=&quot;27 May 2015&quot; low=&quot;20&quot; high=&quot;33&quot; text=&quot;Partly Cloudy&quot; code=&quot;30&quot; /&gt;
            &lt;yweather:forecast day=&quot;Thu&quot; date=&quot;28 May 2015&quot; low=&quot;21&quot; high=&quot;34&quot; text=&quot;Sunny&quot; code=&quot;32&quot; /&gt;
            &lt;yweather:forecast day=&quot;Fri&quot; date=&quot;29 May 2015&quot; low=&quot;18&quot; high=&quot;25&quot; text=&quot;AM Showers&quot; code=&quot;39&quot; /&gt;
            &lt;yweather:forecast day=&quot;Sat&quot; date=&quot;30 May 2015&quot; low=&quot;18&quot; high=&quot;32&quot; text=&quot;Sunny&quot; code=&quot;32&quot; /&gt;
            &lt;yweather:forecast day=&quot;Sun&quot; date=&quot;31 May 2015&quot; low=&quot;20&quot; high=&quot;37&quot; text=&quot;Sunny&quot; code=&quot;32&quot; /&gt;
        &lt;/item&gt;
    &lt;/channel&gt;
&lt;/rss&gt;
&#39;&#39;&#39;

from xml.parsers.expat import ParserCreate

class WeatherSaxHandler(object):
    def start_element(self, name, attrs):
        if name == &#39;yweather:location&#39;:
            self.city = attrs[&#39;city&#39;]
            self.country = attrs[&#39;country&#39;]
        elif name == &#39;yweather:forecast&#39;:
            if not hasattr(self, &#39;today&#39;):  # 要求xml中today的天气在前面
                self.today = {&#39;text&#39;: attrs[&#39;text&#39;], &#39;low&#39;: int(attrs[&#39;low&#39;]), &#39;high&#39;: int(attrs[&#39;high&#39;])}
            elif hasattr(self, &#39;today&#39;) and (not hasattr(self, &#39;tomorrow&#39;)):
                self.tomorrow = {&#39;text&#39;: attrs[&#39;text&#39;], &#39;low&#39;: int(attrs[&#39;low&#39;]), &#39;high&#39;: int(attrs[&#39;high&#39;])}

def parse_weather(xml):
    handler = WeatherSaxHandler()
    parser = ParserCreate()
    parser.StartElementHandler = handler.start_element
    parser.Parse(xml)
    return {
        &#39;city&#39;: handler.city,
        &#39;country&#39;: handler.country,
        &#39;today&#39;: {
            &#39;text&#39;: handler.today[&#39;text&#39;],
            &#39;low&#39;: handler.today[&#39;low&#39;],
            &#39;high&#39;: handler.today[&#39;high&#39;]
        },
        &#39;tomorrow&#39;: {
            &#39;text&#39;: handler.tomorrow[&#39;text&#39;],
            &#39;low&#39;: handler.tomorrow[&#39;low&#39;],
            &#39;high&#39;: handler.tomorrow[&#39;high&#39;]
        }
    }

weather = parse_weather(data)
assert weather[&#39;city&#39;] == &#39;Beijing&#39;, &#39;%s失败&#39; % weather[&#39;city&#39;]
assert weather[&#39;country&#39;] == &#39;China&#39;, &#39;%s失败&#39; % weather[&#39;country&#39;]
assert weather[&#39;today&#39;][&#39;text&#39;] == &#39;Partly Cloudy&#39;, &#39;%s失败&#39; % weather[&#39;today&#39;][&#39;text&#39;]
assert weather[&#39;today&#39;][&#39;low&#39;] == 20, &#39;%s失败&#39; % weather[&#39;today&#39;][&#39;low&#39;]
assert weather[&#39;today&#39;][&#39;high&#39;] == 33, &#39;%s失败&#39; % weather[&#39;today&#39;][&#39;high&#39;]
assert weather[&#39;tomorrow&#39;][&#39;text&#39;] == &#39;Sunny&#39;, &#39;%s失败&#39; % weather[&#39;tomorrow&#39;][&#39;text&#39;]
assert weather[&#39;tomorrow&#39;][&#39;low&#39;] == 21, &#39;%s失败&#39; % weather[&#39;tomorrow&#39;][&#39;low&#39;]
assert weather[&#39;tomorrow&#39;][&#39;high&#39;] == 34, &#39;%s失败&#39; % weather[&#39;tomorrow&#39;][&#39;high&#39;]
print(&#39;pass&#39;)
print(&#39;Weather:&#39;, str(weather))
</code></pre></li>
</ul>

<h5 id="toc_4">13.8 HTMLParser（HTML）</h5>

<ul>
<li><p>HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML；Python提供了HTMLParser来解析HTML</p>

<pre><code class="language-python">from html.parser import HTMLParser

class MyHTMLParser(HTMLParser):
    def handle_starttag(self, tag, attrs):
        print(&#39;&lt;%s&gt;&#39; % tag)

    def handle_endtag(self, tag):
        print(&#39;&lt;/%s&gt;&#39; % tag)

    def handle_startendtag(self, tag, attrs):
        print(&#39;&lt;%s/&gt;&#39; % tag)

    def handle_data(self, data):
        print(data)

    def handle_comment(self, data):
        print(&#39;&lt;!--&#39;, data, &#39;--&gt;&#39;)

    def handle_entityref(self, name):  # 处理一些特殊字符，以&amp;开头，比如&amp;nbsp
        print(&#39;&amp;%s:&#39; % name)

    def handle_charref(self, name):  # 处理特殊字符串，以&amp;#开头的，一般是内码表示的字符
        print(&#39;&amp;#%s:&#39; % name)

html = &#39;&#39;&#39;&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;!-- test html parser --&gt;
    &lt;p&gt;Some &lt;a href=\&quot;#\&quot;&gt;html&lt;/a&gt; HTML&amp;nbsp;tutorial...&lt;br&gt;END&lt;/p&gt;
&lt;/body&gt;&amp;nbsp;&lt;/html&gt;&#39;&#39;&#39;

parser = MyHTMLParser()
parser.feed(html)
</code></pre></li>
<li><p>feed()方法可以多次调用，不需要一次把整个HTML字符串都传入，可以分批传入</p></li>
<li><p>特殊字符有两种，一种是英文表示的 <code>&amp;nbsp;</code> ，一种是数字表示的 <code>&amp;#1234;</code> ；它们都可以通过HTMLParser被解析出来</p>

<pre><code class="language-python"> # 练习：解析Python官网发布的会议时间、名称、地点
from html.parser import HTMLParser

class MyHTMLParser(HTMLParser):
    def __init__(self):
        super(MyHTMLParser, self).__init__()
        self._flag = &#39;&#39;

    def handle_starttag(self, tag, attrs):
         # 标签的属性被解析成数组（元素为单个属性tuple）
        if tag == &#39;h3&#39; and (&#39;class&#39;, &#39;event-title&#39;) in attrs:
            self._flag = &#39;Title: &#39;
        elif tag == &#39;span&#39; and (&#39;class&#39;, &#39;event-location&#39;) in attrs:
            self._flag = &#39;Location: &#39;
        elif tag == &#39;time&#39;:
            self._flag = &#39;Time: &#39;
        elif tag == &#39;span&#39; and (&#39;class&#39;, &#39;say-no-more&#39;) in attrs:
            self._flag = &#39;year&#39;

    def handle_data(self, data):
        if self._flag == &#39;Title: &#39;:
            print(&#39;-&#39; * 50)
            print(self._flag, data.strip())
        elif self._flag == &quot;Location: &quot;:
            print(self._flag, data.strip())
        elif self._flag == &#39;Time: &#39;:
            # 加参数end，打印之后不换行
            print(self._flag, data.strip(), end=&#39;~~~&#39;)
        elif self._flag == &#39;year&#39;:
            print(data.strip())
        # 在获取到数据后，必须重置当前读取的标签
        #（不可以在handle_starttag中重置，可能出现标签嵌套的情况）
        # &lt;h3 class=&quot;event-title&quot;&gt;&lt;a href=&quot;/events/python-events/360/&quot;&gt;PyCon Namibia 2016
        self._flag = &#39;&#39;

parser = MyHTMLParser()
with open(&#39;python-events.htm&#39;, &#39;r&#39;) as html:
    parser.feed(html.read())
</code></pre></li>
</ul>

<h5 id="toc_5">13.9 urllib</h5>

<ul>
<li><p>urllib的request模块可以指定URL发送HTTP请求，并返回HTTP的响应</p>

<pre><code class="language-python">from urllib import request

with request.urlopen(&#39;https://api.douban.com/v2/book/2129650&#39;) as f:
    print(&#39;Status:&#39;, f.status, f.reason)
    for k, v in f.getheaders():  # 打印响应头
        print(&#39;%s: %s&#39; % (k, v))
    print(&#39;Data:&#39;, f.read().decode(&#39;utf-8&#39;))
</code></pre></li>
<li><p>若要模拟浏览器发送请求需要使用Request对象；通过向Request对象添加HTTP头部相关信息，就可以伪装成浏览器发送请求</p>

<pre><code class="language-python"># 模拟iPhone6去请求豆瓣首页
from urllib import request

req = request.Request(&#39;http://www.douban.com/&#39;)
# User-Agent是客户端用来标识浏览器
req.add_header(&#39;User-Agent&#39;, &#39;Mozilla/6.0 (iPhone; &#39;
                             &#39;CPU iPhone OS 8_0 like Mac OS X) &#39;
                             &#39;AppleWebKit/536.26 (KHTML, like Gecko) &#39;
                             &#39;Version/8.0 Mobile/10A5376e Safari/8536.25&#39;)

with request.urlopen(req) as f:
    print(&#39;Status:&#39;, f.status, f.reason)
    for k, v in f.getheaders():
        print(&#39;%s: %s&#39; % (k, v))
    print(&#39;Data:&#39;, f.read().decode(&#39;utf-8&#39;))
</code></pre></li>
<li><p>若以POST形式发送网络请求，只需要增加参数data，数据以bytes形式传入</p>

<pre><code class="language-python">from urllib import request, parse

req = request.Request(&#39;https://passport.weibo.cn/sso/login&#39;)
req.add_header(&#39;Referer&#39;, &#39;https://passport.weibo.cn/signin/login?entry=mweibo&#39;
                          &#39;&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#39;)

login_data = parse.urlencode([(&#39;username&#39;, &#39;tom@tom.com&#39;), (&#39;password&#39;, &#39;123&#39;)])

with request.urlopen(req, data=login_data.encode(&#39;utf-8&#39;)) as f:
    print(&#39;Status:&#39;, f.status, f.reason)
    for k, v in f.getheaders():
        print(&#39;%s: %s&#39; % (k, v))
    print(&#39;Data:&#39;, f.read().decode(&#39;utf-8&#39;))
</code></pre></li>
<li><p>若需要更复杂的请求控制，比如通过一个Proxy去访问，就需要使用ProxyHandler来处理</p>

<pre><code class="language-python">proxy_handler = urllib.request.ProxyHandler({&#39;http&#39;: &#39;http://www.example.com:3128/&#39;})

proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()
proxy_auth_handler.add_password(&#39;realm&#39;, &#39;host&#39;, &#39;username&#39;, &#39;password&#39;)

opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)
with opener.open(&#39;http://www.example.com/login.html&#39;) as f:
    pass
</code></pre></li>
</ul>

<h4 id="toc_6">14. 常用第三方模块</h4>

<h5 id="toc_7">14.1 概述</h5>

<ul>
<li>除了内置模块外，Python还有大量的第三方模块；基本上，所有的第三方模块都会在PyPI - the Python Package Index（<code>https://pypi.python.org/pypi/</code>）上注册，只有找到对应的模块名字，即可用pip安装</li>
</ul>

<h5 id="toc_8">14.2 PIL</h5>

<ul>
<li><p>PIL（Python Imaging Library）是Python平台上功能强大使用简单的图像处理标准库</p>

<ul>
<li>由于PIL仅支持Python2.7，一群志愿者在PIL的基础上创建了支持Python 3的兼容版本Pillow</li>
<li>安装Pillow：pip3 install pillow</li>
<li>Pillow支持图像缩放、切片、旋转、滤镜、输出文字、调色板等功能</li>
</ul>

<pre><code class="language-python"># 图片缩放
from PIL import Image

img = Image.open(&#39;git.jpg&#39;)  # 打开一个jpge文件，注意路径
w, h = img.size  # 获取图像尺寸
print(&#39;Original image size: %sx%s&#39; % (w, h))

img.thumbnail((w // 2, h // 2))  # 缩放到50%，//整除
print(&#39;Resize image size: %sx%s&#39; % (w // 2, h // 2))
img.save(&#39;thumbnail.jpg&#39;, &#39;jpeg&#39;)  # 把缩放后的图像用jpeg格式保存

# 模糊效果
from PIL import Image, ImageFilter

img = Image.open(&#39;git.jpg&#39;)
img2 = img.filter(ImageFilter.BLUR)  # 应用模糊滤镜
img2.save(&#39;blur.jpg&#39;, &#39;jpeg&#39;)
</code></pre></li>
<li><p>PIL的ImageDraw提供了一系列绘图方法，比如可以用来生成字母验证码图片</p>

<pre><code class="language-python">from PIL import Image, ImageDraw, ImageFont, ImageFilter
import random

# 随机字母
def rndChar():
    return chr(random.randint(65, 90))

# 随机颜色1
def rndColor():
    return random.randint(64, 255), random.randint(64, 255), random.randint(64, 255)

# 随机颜色2
def rndColor2():
    return random.randint(32, 127), random.randint(32, 127), random.randint(32, 127)

# 240 * 60
width = 60 * 4
height = 60

image = Image.new(&#39;RGB&#39;, (width, height), (255, 255, 255))
draw = ImageDraw.Draw(image)  # 创建Draw对象
for x in range(width):  # 填充每个像素
    for y in range(height):
        draw.point((x, y), fill=rndColor())

font = ImageFont.truetype(&#39;Arial.ttf&#39;, 36)  # 创建Font对象
for t in range(4):  # 输出文字
    draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())

image = image.filter(ImageFilter.BLUR)  # 模糊
image.save(&#39;code.jpg&#39;, &#39;jpeg&#39;)
</code></pre></li>
</ul>

<h5 id="toc_9">14.3 virturalenv</h5>

<ul>
<li>在开发Python（比如使用Python3）应用程序时，所有的第三方的包都会被pip3安装到Python3的site-package目录下；比如应用A需要的jinja2.7，应用B需要的jinja2.6，此时，最好让每个应用都各自拥有一套“独立”的Python运行环境</li>
<li><p>virtualenv就是用来创建一套“隔离”的Python运行环境；安装virtualenv：<code>pip3 install virturalenv</code> ；注意使用pip3进行安装，这样创建的“隔离”的运行环境才是Python3的</p>

<pre><code class="language-python"># 假设开发一个新的项目，需要一套独立的Python运行环境
# 第一步，创建目录
XXPro:Desktop xx$ mkdir myproject

# 第二步，创建一个独立的Python运行环境，命名为myvenv
XXPro:Desktop xx$ cd myproject/
XXPro:myproject xx$ virtualenv --no-site-packages myvenv
Using base prefix 。。。。。。 wheel...done.
XXPro:myproject xx$ ls
myvenv

# 第三步：进入独立的Python运行环境（使用source命令）
XXPro:myproject xx$ source myvenv/bin/activate
# 注意命令提示符变了，有个(myvenv)的前缀，表示当前环境是一个名为myvenv的Python环境
(myvenv) XXPro:myproject xx$ python  # 直接使用python进入的是Python3
Python 3.5.1 。。。。。。 for more information.
&gt;&gt;&gt; from PIL import Image  # 此时发现无法导入之前pip3的PIL
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named &#39;PIL&#39;
&gt;&gt;&gt; exit()

# 第四步：为独立的Python运行环境安装第三方库
(myvenv) XXPro:myproject xx$ pip install pillow  
Collecting pillow 。。。。。。 installed pillow-3.2.0
# 在myvenv环境下，用pip安装的包都被安装到myvenv这个环境下，系统Python环境不受影响；
# 也就是说，myvenv环境是专门针对myproject这个应用创建的
(myvenv) XXPro:myproject xx$ python
Python 3.5.1 。。。。。。 for more information.
&gt;&gt;&gt; from PIL import Image  # 可以使用PIL
&gt;&gt;&gt; exit()

# 第五步：退出当前的myvenv环境（使用deactivate命令）
(myvenv) XXPro:myproject xx$ deactivate 
XXPro:myproject xx$ python  # 进入的是系统的Python2
Python 2.7.10 。。。。。。 more information.
&gt;&gt;&gt; exit()
</code></pre></li>
<li><p>virtualenv命令创建一个独立的Python运行环境，参数--no-site-packages表示不将系统的安装的第三方模块复制过来</p></li>
<li><p>独立的Python环境存放在当前目录下的环境名称目录中（比如上面的myvenv），之后使用source命令进入该环境</p></li>
<li><p>针对每个应用创建独立的Python运行环境，可以解决不同应用间使用的库多版本的冲突问题</p></li>
<li><p>virturalenv创建“独立”的Python运行环境原理：把系统Python复制一份到virtualenv环境，用命令“source myvenv/bin/activate”进入一个virtualenv环境时，virtualenv会修改环境变量，让命令python和pip均指向当前的virtualenv环境<br/>
Python3.3开始新增内置的创建虚拟环境的venv，其操作和virtualenv类似，创建一个“隔离环境”：<code>python3 -m venv myvenv</code></p></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(12正则表达式、13常见内建模块(上))]]></title>
    <link href="http://www.justisit.com/15125773962190.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773962190.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">12. 正则表达式</a>
<ul>
<li>
<a href="#toc_1">12.1 基础</a>
</li>
<li>
<a href="#toc_2">12.2 re模块</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">13. 常见内建模块(上)</a>
<ul>
<li>
<a href="#toc_4">13.1 datetime</a>
</li>
<li>
<a href="#toc_5">13.2 collections</a>
</li>
<li>
<a href="#toc_6">13.3 base64</a>
</li>
<li>
<a href="#toc_7">13.4 struct</a>
</li>
</ul>
</li>
</ul>


<h4 id="toc_0">12. 正则表达式</h4>

<h5 id="toc_1">12.1 基础</h5>

<ul>
<li>匹配字符：

<ul>
<li>\d匹配一个数字，\D匹配一个非数字</li>
<li>\w匹配一个数字字母，\W匹配一个非数字字母</li>
<li>\s匹配一个空白符（包含空格Tab等空白符），\S匹配一个非空白符</li>
<li>.匹配任意一个字符</li>
<li>[]表示精确匹配范围，例如[a-zA-Z]匹配一个字母、[0-9a-zA-Z_]匹配找一个数字、字母或下划线</li>
<li>特殊字符使用\进行转义，例如-</li>
</ul></li>
<li>匹配长度：

<ul>
<li>*表示任意个字符（包含0个）</li>
<li>+表示至少一个</li>
<li>?表示0个或1个</li>
<li>{n}表示n个，{n, m}表示n~m个，例如[a-zA-Z_][0-9a-zA-Z_]{0, 19}匹配长度为1-20个字符（前面1个是字母或下划线，后面最多19个数字、字母或下划线）</li>
</ul></li>
<li>^表示行的开头，例如<sup>\d表示必须以数字开头</sup></li>
<li>\(表示行的结束，\d\)表示必须以数字结束，py可以匹配python，但是<sup>py$就只能匹配py</sup></li>
<li>A|B表示可以匹配A或B，但有时候需要加小括号()进行限制长度（此时也就会出现了分组）；例如(P|p)ython可以匹配Python或python，P|python只能匹配P或python</li>
<li>单个字符的或匹配，也可以使用字符集[]来实现，例如[Pp]ython可以匹配Python或python</li>
</ul>

<span id="more"></span><!-- more -->

<h5 id="toc_2">12.2 re模块</h5>

<ul>
<li><p>Python中的re模块提供了正则表达式的功能；注意Python的字符串本身也用\进行转义</p>

<pre><code class="language-python">s = &#39;ABC\\-001&#39; # 字符串为&#39;ABC\-001&#39;
# 使用Python的r前缀，就不用考虑转义的问题了
s = r&#39;ABC\\-001&#39; # 字符串为&#39;ABC\\-001&#39;  
</code></pre></li>
<li><p>re.match()：从字符串的起点进行匹配，成功返回一个Match，否则返回None</p></li>
<li><p>re.search()：在字符串内查找匹配，只找到一个就匹配返回，成功返回一个Match，否则返回None；re.search(r&#39;<sup>a&#39;,</sup> &#39;cba&#39;)与re.match(r&#39;a&#39;, &#39;cba&#39;)是等价的</p></li>
<li><p>re.sub()：用于替换字符串中的匹配项</p></li>
<li><p>re.split()：分割字符串，使用正则表更灵活（可以识别连续空格）</p></li>
<li><p>re.findall()：以list形式返回全部匹配的子串</p>

<pre><code class="language-python">import re

m = re.match(r&#39;a&#39;, &#39;cba&#39;)
print(m)  # None
m = re.search(r&#39;a&#39;, &#39;cba&#39;)
print(m)  # &lt;_sre.SRE_Match object; span=(2, 3), match=&#39;a&#39;&gt;

m = re.match(r&#39;\d{3}-\d{3,8}$&#39;, &#39;010-12345&#39;)
print(m)

# 将字符串中所有的空格替换成-
re.sub(r&#39;\s+&#39;, &#39;-&#39;, str)

l = &#39;a b    c&#39;.split(&#39; &#39;)
print(l)  # [&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;]

l = re.split(r&#39;\s+&#39;, &#39;a b    c&#39;)
print(l)  # [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

# split()还可以屏蔽一些特殊字符
l = re.split(r&#39;[\s\\,\\;]+&#39;, &#39;a,b, c;;    d&#39;)
print(l)  # [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
</code></pre></li>
<li><p>分组：使用()表示要提取的分组（Group），即提取子串</p>

<ul>
<li>若正则表达式中定义了组（使用了“()”）并且匹配成功

<ul>
<li>可以在Match对象上用group(1)、group(2)提取出第1、2个子</li>
<li>&#39;\1&#39;、&#39;\2&#39;也可以表示分组中的第1、2个子串</li>
<li>groups()返回所有的子串组成的tuple</li>
<li>group()或group(0)返回整个正则表达式匹配上的子串（不要求正则中是否定义了组）</li>
</ul></li>
<li>若匹配不成功，返回None，调用group(0)、group(1)会报错</li>
</ul>

<pre><code class="language-python"># ^(\d{3})-(\d{3,8})$定义两个组用于提取出区号和号码
m = re.match(r&#39;^(\d{3})-(\d{3,8})$&#39;, &#39;010-12345&#39;)

print(m) # &lt;_sre.SRE_Match object; span=(0, 9), match=&#39;010-12345&#39;&gt;
print(m.group(0)) # 010-12345
print(m.group(1)) # 010
print(m.group(2)) # 12345
</code></pre></li>
<li><p>贪婪匹配：正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符</p>

<pre><code class="language-python">m = re.match(r&#39;^(\d+)(0*)$&#39;, &#39;102300&#39;).groups()
print(m)  # (&#39;102300&#39;, &#39;&#39;)

# 加个?就让\d+采用非贪婪匹配（也就是尽可能少匹配）
# 注意：单个?表示的是0个或1个
m = re.match(r&#39;^(\d+?)(0*)$&#39;, &#39;102300&#39;).groups()
print(m)  # (&#39;1023&#39;, &#39;00&#39;)
</code></pre></li>
<li><p>当在Python中使用正则表达式时，re模块内部会干两件事情：</p>

<ul>
<li>a. 编译正则表达式，若该表达式的字符串本身不合法，会报错</li>
<li>b. 用编译后的正则表达式去匹配字符串</li>
</ul></li>
<li><p>若一个正则表达式需要被重复使用多次，可以预编译该正则表达式，之后重复使用时就不需要编译这个步骤，直接进行匹配</p>

<pre><code class="language-python"># 编译，生成Regular Expression对象（包含正则表达式）
re_phone = re.compile(r&#39;^(\d{3})-(\d{3,8})$&#39;) 
# 匹配使用
m = re_phone.match(&#39;010-12345&#39;).groups()

print(m)  # (&#39;010&#39;, &#39;12345&#39;)
</code></pre></li>
<li><p>re提供的函数都有个可省略的flags参数（匹配模式），其有以下几个常用取值：</p>

<ul>
<li>re.I(IGNORECASE；忽略大小写)</li>
<li>re.M(MULTILINE；多行模式，改变&#39;<sup>&#39;和&#39;$&#39;的行为)</sup></li>
<li>re.S(DOTALL；点任意匹配模式，改变&#39;.&#39;的行为)；</li>
<li>多个匹配模式使用或运算符|进行组合</li>
</ul></li>
</ul>

<h4 id="toc_3">13. 常见内建模块(上)</h4>

<ul>
<li>Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用</li>
</ul>

<h5 id="toc_4">13.1 datetime</h5>

<ul>
<li><p>datetime模块是Python处理日期和时间的标准库，datetime模块还包含一个datetime类</p>

<pre><code class="language-python">from datetime import datetime

# 获取当前日期和时间
now = datetime.now()  # 返回类型为datatime
print(now)
print(type(now))

# 获取指定日期和时间
dt = datetime(2015, 10, 1, 9, 20)  # 用参数直接构造一个datetime
print(dt)
</code></pre></li>
<li><p>将1970.1.1 00:00:00 UTC+00:00的时刻称为epoch time，记为0；当前时间相对于epoch time的秒数称为timestamp（1970年之前为负数）；timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00 = 1970-1-1 08:00:00 UTC+8:00</p></li>
<li><p>由于timestamp和时区没有关系，全球各地的计算机在任意时刻的timestamp是完全相同的，所以计算机存储的当前时间是以timestamp表示的</p></li>
<li><p>Python中的timestamp是一个浮点数，小数位表示毫秒数；某些编程语言（如Java和JS）的timestamp使用整数表示毫秒数，此时只需要把timestamp除以1000就得到Python的timestamp</p>

<pre><code class="language-python"># 将datetime转timestamp
#（若datetime的时区属性为None，转换时时区取当前时区）
now = datetime.now()
print(now.timestamp())

# 将timestamp转为datetime（当前时区时间）
#（timestamp没有时区概念，datetime有时区概念）
ts = 0
print(datetime.fromtimestamp(ts))  # 1970-01-01 08:00:00

# 将timestamp转为datetime（UTC标准时间）
print(datetime.utcfromtimestamp(ts))  # 1970-01-01 00:00:00
</code></pre></li>
<li><p>datetime格式化：字符串&#39;%Y-%m-%d %H:%M:%S&#39;规定了日期和时间部分的格式</p>

<pre><code class="language-python"># datetime转str
now = datetime.now()
print(now.strftime(&#39;%a, %b %d %H:%M&#39;))

# str转datetime（没有时区信息）
dt = datetime.strptime(&#39;2015-6-1 18:20:12&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;)
print(dt)
</code></pre></li>
<li><p>对日期和时间进行加减就是把datetime往后往前计算得到新的datetime；加减可直接用+、-运算符操作timedelta类</p>

<pre><code class="language-python">from datetime import timedelta

print(now)
newNow = now + timedelta(hours=10)  # 加10小时
print(newNow)

newNow = now - timedelta(days=1)  # 减1天
print(newNow)

newNow = now + timedelta(days=2, hours=12)  # 加2天12小时
print(newNow)
</code></pre></li>
<li><p><strong>datetime有一个时区属性tzinfo，默认为None</strong>，所以无法区分该datetime是哪个时区的，需要人为设置一个时区</p>

<pre><code class="language-python">from datetime import datetime, timedelta, timezone

# 强制设置时区（使用replace()方法）
# 举例1
tz_utc_8 = timezone(timedelta(hours=8))  # 创建时区UTC + 8:00
now = datetime.now()
print(now)  # 2015-11-05 12:39:20.526329
dt = now.replace(tzinfo=tz_utc_8)  # 强制设置UTC + 8:00
print(dt)  # 2015-11-05 12:39:20.526329+08:00

# 举例2
# utcnow()可以获取当前的UTC时间
utc_now = datetime.utcnow()  # 时区属性tzinfo为None
print(utc_now)  # 2015-11-05 04:41:30.332392
utc_dt = utc_now.replace(tzinfo=timezone.utc)  # 强制转为UTC + 0:00时区
print(utc_dt)  # 2015-11-05 04:41:30.332392+00:00

# 时区转换
# astimezone()方法将一个时区的datetime转到另一个时区的datetime
bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8))) 
print(bj_dt)  # 2015-11-05 12:41:30.332392+08:00
tokyo_dt = bj_dt.astimezone(timezone(timedelta(hours=9)))
print(tokyo_dt)  # 2015-11-05 13:41:30.332392+09:00
</code></pre></li>
<li><p>datetime不含有时区信息时表示为当前本地时间；存储datetime的最佳方法是将其转为timestamp再存储</p>

<pre><code class="language-python"># 练习：将日期时间字符串及时区信息字符串转为timestamp
import re
from datetime import datetime, timezone, timedelta

def to_timestamp(dt_str, tz_str):
    d = datetime.strptime(dt_str, &quot;%Y-%m-%d %H:%M:%S&quot;)
    h = int(re.match(r&#39;UTC([+|-]\d+):&#39;, tz_str).group(1))
    tz = timezone(timedelta(hours=h))
    d = d.replace(tzinfo=tz)  # 在调用d.timestamp()前，先调用设置时区
    return d.timestamp()

t1 = to_timestamp(&#39;2015-6-1 08:10:30&#39;, &#39;UTC+7:00&#39;)
assert t1 == 1433121030.0, &#39;函数返回值:%s&#39; % t1

t2 = to_timestamp(&#39;2015-5-31 16:10:30&#39;, &#39;UTC-09:00&#39;)
assert t2 == 1433121030.0, &#39;函数返回值:%s&#39; % t2

print(&#39;Pass&#39;)
</code></pre></li>
</ul>

<h5 id="toc_5">13.2 collections</h5>

<ul>
<li>collections是Python内建的一个集合模块，提供了许多有用的集合类</li>
<li><p>a. namedtuple</p>

<ul>
<li>tuple是不可变集合，使用tuple可以表示一个坐标(x, y)，但是无法直接以x、y属性形式去访问值，而定义一个class又小题大做</li>
<li>namedtuple是一个函数，可以创建一个自定义的tuple对象，之后可以以属性形式而不是索引形式去访问tuple的某个元素，使用非常方便</li>
</ul>

<pre><code class="language-python">from collections import namedtuple

Point = namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])
p = Point(1, 2)
print(&#39;x:&#39;, p.x)
print(&#39;y:&#39;, p.y)
print(isinstance(p, Point)) # True
print(isinstance(p, tuple)) # True

Circle = namedtuple(&#39;Circle&#39;, [&#39;x&#39;, &#39;y&#39;, &#39;r&#39;])；
</code></pre></li>
<li><p>b. duque</p>

<ul>
<li>使用list存储数据时，按索引访问元素很快，但是插入删除元素就比较慢（list是线性存储）</li>
<li>deque是双向链表，可以高效地插入删除元素，适合用于队列和栈</li>
<li>deque除了实现list的append()和pop()外，还支持appendleft()和popleft()可以高效地向队列的头部添加删除元素，也可以按照索引取值</li>
</ul>

<pre><code class="language-python">from collections import deque

q = deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
q.append(&#39;x&#39;)
q.appendleft(&#39;y&#39;)
print(q)
print(q[2])
</code></pre></li>
<li><p>c. defaultdict</p>

<ul>
<li>使用dict时，若key不存在则抛出KeyError；若希望key不存在时就返回一个默认值，可以使用defaultdict</li>
<li>默认值是由创建defaultdict对象时传入的函数调用返回的</li>
<li>除了在key不存在时返回一个默认值，defaultdict的使用和dict是完全一样</li>
</ul>

<pre><code class="language-python">from collections import defaultdict

dd = defaultdict(lambda: &#39;N/A&#39;)  # 传入提供默认值的函数
dd[&#39;key1&#39;] = &#39;abc&#39;
print(dd[&#39;key1&#39;]) # abc
print(dd[&#39;key2&#39;]) # N/A
</code></pre></li>
<li><p>d. OrderDict</p>

<ul>
<li>dict的key是无序的，在对dict做迭代时无法确定key的顺序；若要保持key的顺序可以用OrderDict</li>
</ul>

<pre><code class="language-python">from collections import OrderedDict

l = [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]

d = dict(l)
print(d)

od = OrderedDict(l)  # 通过list构造dict
print(od)

od = OrderedDict()
# key会按照插入的顺序排序，不是key本身排序
od[&#39;z&#39;] = 1
od[&#39;y&#39;] = 2
od[&#39;x&#39;] = 3
print(list(od.keys()))
</code></pre>

<pre><code class="language-python"># 使用OrderedDict实现一个FIFO的dict，当容量超出限制时，先删除最早添加的元素
from collections import OrderedDict

class LastUpdateOrderedDict(OrderedDict):
    def __init__(self, capacity):
        super(LastUpdateOrderedDict, self).__init__()
        self.__capcity = capacity

    def __setitem__(self, key, value):
        contains_key = 1 if key in self else 0  # Python三元表达式 
        if len(self) - contains_key &gt;= self.__capcity:
            # last为True是LIFO即为堆栈，反之是FIFO即为队列
            last = self.popitem(last=False)
            print(&#39;remove:&#39;, last)
        if contains_key:
            del self[key]  # 可以不删除，直接覆盖
            print(&#39;set:&#39;, (key, value))
        else:
            print(&#39;add:&#39;, (key, value))
        OrderedDict.__setitem__(self, key, value)  # 调用父类方法，添加元素
</code></pre>

<pre><code class="language-python"># 补充（两个list合并成dict）：
list1 = [&#39;key1&#39;, &#39;key2&#39;, &#39;key3&#39;]
list2 = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]
d = dict(zip(list1, list2))
print(d)
</code></pre></li>
<li><p>e. Counter</p>

<ul>
<li>一个简单的计数器，实际上是dict的一个子类</li>
</ul>

<pre><code class="language-python"># 统计字符出现的个数
from collections import Counter

c = Counter()
for ch in &#39;programming&#39;:
    c[ch] += 1
print(c)  

# Counter({&#39;r&#39;: 2, &#39;g&#39;: 2, &#39;m&#39;: 2, &#39;i&#39;: 1, &#39;n&#39;: 1, &#39;o&#39;: 1, &#39;a&#39;: 1, &#39;p&#39;: 1})
</code></pre></li>
</ul>

<h5 id="toc_6">13.3 base64</h5>

<ul>
<li>若使用记事本打开exe、jpg等二进制文件会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符；若让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法，base64是一种常见的二进制编码方法</li>
<li>base64用64个可打印字符可以表示任意二进制数据</li>
<li>base64编码原理

<ul>
<li>a. 先准备一个包含64个字符的数组表[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, .... &#39;a&#39;,...&#39;0&#39;,... &#39;+&#39;,&#39;/&#39;]</li>
<li>b. 对二进制数据进行处理，每3个字节为一大组（3*8=24bit），再每6个bit分隔为一小组，共4小组</li>
<li>c. 根据得到的4个小组对应的数值（小于64）做索引，在上面的数组表中查找获取相应的4个字符，这些字符就是编码之后的字符</li>
<li>d. 若分大组时剩余的字节数不是3的倍数（8、16bit）则无法被6整除，需要在末尾补bit0（分别补4、2个bit0后为12、18bit，最后分别生成2、3个字符）；之后再在编码的末尾添加=号（剩余字节数为1时补2个=，剩余字节数为2时补1个=），让其满足编码后的字符数（含=）恰好是4的倍数，解码的时候=号会自动去掉</li>
</ul></li>
<li>base64编码会把3字节的二进制数据编码为4字节的文本数据，文件大小增加33%</li>
<li><p>Python内置了支持base64编码解码的base64模块</p>

<pre><code class="language-python">import base64

en = base64.b64encode(b&#39;binary\x00string&#39;)  # 编码，一共6+1+6个字节
print(en)  # b&#39;YmluYXJ5AHN0cmluZw==&#39;
de = base64.b64decode(b&#39;YmluYXJ5AHN0cmluZw==&#39;)  # 解码
print(de)
</code></pre></li>
<li><p>使用标准的base64编码可能出现字符/和+，但是字符/和+在URL中不能直接作为参数，所以出现了一种“url safe”的base64编码（其实就是把字符/和+分别变成_和-）</p>

<pre><code class="language-python">en = base64.b64encode(b&#39;i\xb7\x1d\xfb\xef\xff&#39;)
print(en)  # b&#39;abcd++//&#39;

sf_en = base64.urlsafe_b64encode(b&#39;i\xb7\x1d\xfb\xef\xff&#39;)
print(sf_en)  # b&#39;abcd--__&#39;
sf_de = base64.urlsafe_b64decode(b&#39;abcd--__&#39;)
print(sf_de)  # b&#39;i\xb7\x1d\xfb\xef\xff&#39;
</code></pre></li>
<li><p>编码中也可能也出现字符=，但字符=在URL、Cookie中会造成歧义；所以，很多base64编码会把字符=去掉，解码时先添加字符=再进行解码（base64编码本质就是让3字节变为4字节（字符），所以只需手动添加字符=让字符串的长度是4的倍数即可）</p></li>
<li><p>可以自定义64个字符的排序顺序，这样就是自定义base64编码，不过通常没有必要</p></li>
<li><p>base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行</p></li>
<li><p>base64适用于小段内容的编码，比如数字证书签名、Cookie、URL等</p>

<pre><code class="language-python"># 处理去掉=的base64的解码
import base64

def safe_base64_decode(s):
    # 3 % 4 = 3，-3 / 4 = 1； b&#39;=&#39; * 2结果为b&#39;==&#39;
    s += (-len(s) % 4) * b&#39;=&#39;
    return base64.b64decode(s)

assert b&#39;abcd&#39; == safe_base64_decode(b&#39;YWJjZA==&#39;), safe_base64_decode(&#39;YWJjZA==&#39;)
assert b&#39;abcd&#39; == safe_base64_decode(b&#39;YWJjZA&#39;), safe_base64_decode(&#39;YWJjZA&#39;)
print(&#39;Pass&#39;)
</code></pre></li>
<li><p>base64编码补充： </p>

<ul>
<li>早期的一些邮件服务器只支持文本信息，不支持二进制信息和文件，而base64编码后的结果都是ASCII纯文本的，适合用电子邮件来传送二进制数据</li>
<li>网页中的图片可以使用base64编码减少了HTTP请求（不是所有浏览器都支持），比如&lt;img src=&quot;data:image/gif;base64,R0lGODlhAwADAIABAL6+v=&quot;/&gt;，</li>
<li>在URL中若使用标准的base64编码，还需要进行urlencode，处理特殊字符+和/，或者将编码后的字符串进行特殊字符替换；建议直接使用urlsafe_b64encod()</li>
<li>urlencode：将除了-_.之外的其他非字母数字字符，编码成百分号%后跟2位十六进制数，空格则编码为加号+</li>
</ul></li>
</ul>

<h5 id="toc_7">13.4 struct</h5>

<ul>
<li><p>Python没有专门处理字节的数据类型，虽然str既可以表示字符串，又可以表示字节（b&#39;\x00\x9c&#39;）</p>

<pre><code class="language-python"># 把一个32位无符号整数变成字节（4个bytes），需要使用位运算（若是浮点数就无解了）
n = 10240099
print(&#39;%x&#39; % n)  # 9c4063

b1 = (n &amp; 0xff000000) &gt;&gt; 24
b2 = (n &amp; 0xff0000) &gt;&gt; 16
b3 = (n &amp; 0xff00) &gt;&gt; 8
b4 = n &amp; 0xff
print(&#39;%x, %x, %x, %x&#39; % (b1, b2, b3, b4))  # 0, 9c, 40, 63
bs = bytes([b1, b2, b3, b4])
print(bs)  # b&#39;\x00\x9c@c&#39;
</code></pre></li>
<li><p>struct模块可以解决bytes和二进制数据类型的转换（二进制文件的编码解码存储；这一部分操作通常是系统底层自动完成）；decode、endcode解决的是bytes和str的转换</p>

<pre><code class="language-python">import struct

# pack: 把任意数据类型变成bytes
# 第1参数是处理指令；&gt;表示字节顺序是big-endian，也就是网络序，
# I表示4字节无符号整数，H表示2字节无符号整数，f表示4字节float，d表示8字节double...
b = struct.pack(&#39;&gt;I&#39;, 10240099)
print(b)  # b&#39;\x00\x9c@c&#39;

# 多个参数：参数个数要和处理指令中的一致
# &gt;IH表示要转换的依次为：4字节无符号整数、2字节无符号整数
b = struct.pack(&#39;&gt;IH&#39;, 10240099, 32896)
print(b)  # b&#39;\x00\x9c@c\x80\x80&#39;

# unpack：把bytes变成相应的数据类型
s = struct.unpack(&#39;&gt;I&#39;, b&#39;\x00\x9c@c&#39;)
print(s)  # (10240099,)

s = struct.unpack(&#39;&gt;IH&#39;, b&#39;\x00\x9c@c\x80\x80&#39;) 
print(s)  # (10240099, 32896)
</code></pre></li>
<li><p>尽管Python不适合编写底层操作字节流的代码，但是对性能要求不高的地方使用struct还是比较方便</p>

<pre><code class="language-python"># 举例：使用struct分析Windows的位图文件（.bmp)，读取前30个字节来分析
s = b&#39;\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00&#39; \
    b&#39;\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01&#39; \
    b&#39;\x00\x00\x01\x00\x18\x00&#39;
s = struct.unpack(&#39;&lt;ccIIIIIIHH&#39;, s)
print(s)  # (b&#39;B&#39;, b&#39;M&#39;, 691256, 0, 54, 40, 640, 360, 1, 24)

BMP格式采用小端方式存储数据，文件头的结构按顺序如下：
两个字节：&#39;BM&#39;表示Windows位图，&#39;BA&#39;表示OS/2位图；
一个4字节整数：表示位图大小；
一个4字节整数：保留位，始终为0；
一个4字节整数：实际图像的偏移量；
一个4字节整数：Header的字节数；
一个4字节整数：图像宽度；
一个4字节整数：图像高度；
一个2字节整数：始终为1；
一个2字节整数：颜色数。
</code></pre></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(11进程和线程)]]></title>
    <link href="http://www.justisit.com/15125773962077.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773962077.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">11. 进程和线程</a>
</li>
<li>
<a href="#toc_1">11.1 概述</a>
</li>
<li>
<a href="#toc_2">11.2 多进程</a>
<ul>
<li>
<a href="#toc_3">a. fork()函数</a>
</li>
<li>
<a href="#toc_4">b. Process（multiprocessing模块）</a>
</li>
<li>
<a href="#toc_5">c. Pool（multiprocessing模块）</a>
</li>
<li>
<a href="#toc_6">d. subprocess</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">11.3 进程间通信</a>
</li>
<li>
<a href="#toc_8">11.4 多线程</a>
<ul>
<li>
<a href="#toc_9">a. Lock（线程同步）</a>
</li>
<li>
<a href="#toc_10">b. 多核CPU（多线程执行）</a>
</li>
<li>
<a href="#toc_11">c. ThreadLocal（数据独立）</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">11.5 进程 VS 线程</a>
<ul>
<li>
<a href="#toc_13">a. 计算密集型 VS IO密集型</a>
</li>
<li>
<a href="#toc_14">b. 异步IO</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">11.6 分布式进程</a>
</li>
</ul>


<h4 id="toc_0">11. 进程和线程</h4>

<h4 id="toc_1">11.1 概述</h4>

<ul>
<li>多任务：简单地说就是系统可以同时运行多个任务</li>
<li>对于系统来说，一个任务就是一个进程（Process）

<ul>
<li>单核CPU：系统轮流让各个任务交替执行，由于CPU的执行速度太快，感觉所有任务都是在同时执行</li>
<li>多核CPU：真正实现并行执行多任务，由于任务数量远远多于CPU的核心数量，所以系统会自动把多任务轮流调度到每个核心上执行</li>
</ul></li>
<li>有些进程要同时干多件事（比如Word，同时进行打字、拼写检查、打印等），就需要同时运行多个“子任务”，进程内的这些“子任务”称之为线程（Thread）

<ul>
<li>线程是最小的执行单元</li>
<li>由于每个进程至少要干一件事，所以，一个进程至少有一个线程</li>
<li>多个线程也是可以同时执行，执行方式和多个进程类似，由系统在多个线程之间快速切换；但真正地同时执行多线程需要多核CPU</li>
</ul></li>
<li>同时执行多个任务有以下解决方案：

<ul>
<li>a. 多进程模式：启动多个进程，每个进程虽然只有一个线程，但多个进程可以一起执行多个任务</li>
<li>b. 多线程模式：启动一个进程，在一个进程内启动多个线程，这样多个线程可以一起执行多个任务</li>
<li>c. 多进程+多线程模式：启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了；这种模型更复杂，实际很少采用</li>
</ul></li>
<li>同时执行多个任务，通常各个任务之间并不是没有关联的，而是需要互相通信和协调的；多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂</li>
<li>Python既支持多进程，又支持多线程</li>
</ul>

<span id="more"></span><!-- more -->

<h4 id="toc_2">11.2 多进程</h4>

<h5 id="toc_3">a. fork()函数</h5>

<ul>
<li>普通的函数调用，调用一次，返回一次</li>
<li>Uinx/Linux系统提供了一个fork()函数（Windows没有该函数）；但是fork()调用一次，返回两次，系统会自动把当前进程（称为父进程）复制了一份（称为子进程），然后分别在父进程和子进程内返回

<ul>
<li>父进程返回子进程的ID，子进程永远返回0；一个父进程可以fork出很多子进程，所以父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID</li>
<li>Python的os模块封装了常见的系统调用，其中就包含fork</li>
</ul></li>
<li><p>有了fork()，一个进程在接到新任务时就可以复制出一个子进程来处理新任务；常见的Apcache Server就是由父进程监听端口，当有新的http请求时，就fork出子进程来处理新的http请求</p>

<pre><code class="language-python">import os

print(&quot;Process (%s) start...&quot;, os.getpid())

pid = os.fork()
if pid == 0: # child process
    print(&#39;I am child process (%s) and my parent is %s.&#39; % (os.getpid(), os.getppid()))
else:
    print(&#39;I (%s) just created a child process (%s)&#39; % (os.getpid(), pid))

# 输出结果
Process (%s) start... 1388
I (1388) just created a child process (1389)
I am child process (1389) and my parent is 1388.
</code></pre></li>
</ul>

<h5 id="toc_4">b. Process（multiprocessing模块）</h5>

<ul>
<li><p>Python是跨平台的，提供了multiprocessing模块支持跨平台的多进程；其中Process类代表一个子进程</p>

<pre><code class="language-python">import os
from multiprocessing import Process

# 子进程要执行的代码
def run_proc(name):
    print(&#39;Run child process %s (%s)...&#39; % (name, os.getpid()))

if __name__ == &#39;__main__&#39;:
    print(&quot;Parent process %s.&quot; % os.getpid())
    # 创建一个子进程（Process实例）
    p = Process(target=run_proc, args=(&#39;ABC&#39;, )) 
    print(&#39;Child process will start.&#39;)
    # start()方法启动子进程
    p.start()
    # join()方法等待该子进程结束后再继续往下运行（通常用于进程间的同步）
    p.join() 
    print(&#39;Child process end.&#39;)

# 输出结果
Parent process 1516.
Child process will start.
Run child process ABC (1517)...
Child process end. # 后打印，由于p.join()导致的
</code></pre></li>
</ul>

<h5 id="toc_5">c. Pool（multiprocessing模块）</h5>

<ul>
<li><p>若要启动大量的子进程，可以用进程池Pool批量创建子进程</p>

<pre><code class="language-python">import os, time, random
from multiprocessing import Pool

def long_time_task(name):
    print(&#39;Run task %s (%s)...&#39; % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print(&#39;Task %s run %.2f seconds.&#39; % (name, (end - start)))

if __name__ == &#39;__main__&#39;:
    print(&#39;Parent processs %s.&#39; % os.getpid())
    pl = Pool(4)
    for i in range(5):
        pl.apply_async(long_time_task, args=(i,))
    print(&#39;Waiting for all subprocesses dones...&#39;)
    # 调用close()之后就不能添加新的Process
    pl.close()
    # 调用join()之前必须先调用close()
    pl.join()
    print(&#39;All subprocesses done.&#39;)

# 输入结果是task 0, 1, 2, 3是立即执行的，task 4要等待前面某个task完成后才执行
# 这是因为设置Pool的大小为4（不设置，默认是当前电脑的CPU核数），因此最多同时执行4个子进程
# 可以设置其他数值，比如5，这样5个子进程可以同时执行
</code></pre></li>
</ul>

<h5 id="toc_6">d. subprocess</h5>

<ul>
<li>很多情况下，其他多进程并不是我们自己创建的子进程，而是外部进程</li>
<li><p>之前其他进程是自己创建的子进程，很容易控制子进程的输入和输出；对于外部进程，subprocess模块提供启动外部进程、控制其输入和输出的功能</p>

<pre><code class="language-python"># 举例：在python代码中运行命令&quot;nslookup www.python.org&quot;
import subprocess

# 调用nslookup并添加参数，返回结果码
r = subprocess.call([&#39;nslookup&#39;, &#39;www.python.org&#39;]) 
print(&#39;Exit code:&#39;, r)

# 若子进程还需要输入，则可以通过commuicate()方法输入
proc = subprocess.Popen([&#39;nslookup&#39;], stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
out, err = proc.communicate(b&#39;set q=mx\npython.org\nexit\n&#39;)
print(out.decode(&#39;utf-8&#39;))
print(&#39;Exit code&#39;, p.returncode)

# 上面的代码相当于：在命令行执行&quot;nslookup&quot;后，再手动输入以下内容
set q=mx
python.org
exit
</code></pre></li>
</ul>

<h4 id="toc_7">11.3 进程间通信</h4>

<ul>
<li><p>系统提供了很多机制来实现进程间的通信；Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式供进程间交换数据</p>

<pre><code class="language-python"># 以Queue方式交换数据
# 在父进程中创建两个进程，一个往Queue中写数据，一个从Queue中读数据
from multiprocessing import Process, Queue
import os, time, random

# 写数据的进程
def write(q):
    print(&#39;Process to write: %s&#39; % os.getpid())
    for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:
        print(&#39;Put %s to queue...&#39; % value)
        q.put(value)  # 向Queue中写数据
        time.sleep(random.random())

# 读数据的进程
def read(q):
    print(&#39;Process to read: %s&#39; % os.getpid())
    while True:
        value = q.get(True)  # 从Queue中读数据
        print(&#39;Get %s from queue.&#39; % value)

if __name__ == &#39;__main__&#39;:
    # multiprocess.Queue为跨进程通信队列，各子进程共有
    q = Queue() 
    # 父进程创建Queue，并传给各个子进程
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    pw.start()  # 启动子进程pw写入
    pr.start()  # 启动子进程pr读取
    pw.join()  # 等待进程pw结束
    pr.terminate()  # 进程pr是死循环，只能强行终止（在pw结束后，此时写入已完毕）
</code></pre></li>
</ul>

<h4 id="toc_8">11.4 多线程</h4>

<ul>
<li>Python的线程是真正的&quot;Posix Thread&quot;，而不是模拟出来的</li>
<li>Python提供了_thread、threading两个模块支持多线程；_thread是低级模块，threading是高级模块（对_thread进行了封装；绝大多数情况下使用）</li>
<li><p>启动一个线程：创建Threading实例并把一个函数传入，然后调用start()开始执行</p>

<pre><code class="language-python">import time, threading

# 新线程执行的代码
def loop():
    print(&#39;thread %s is running...&#39; % threading.current_thread().name) # current_thread()函数返回当前线程的实例
    n = 0
    while n &lt; 5:
        n += 1
        print(&#39;thread %s &gt;&gt; %s&#39; % (threading.current_thread().name, n))
        time.sleep(1)
    print(&#39;thread %s ended.&#39; % threading.current_thread().name)

print(&#39;thread %s is running...&#39; % threading.current_thread().name)
t = threading.Thread(target=loop, name=&#39;LoopThread&#39;)
t.start()
t.join()  # join()也能阻塞线程
print(&#39;thread %s ended.&#39; % threading.current_thread().name)
</code></pre></li>
<li><p>任何进程默认就会启动一个线程，被称为主线程（线程实例名字叫&quot;MainThread&quot;）；主线程又可以启动新的子线程（线程实例名字在创建时指定，若不指定则自动命名为&quot;Thread-1&quot;、&quot;Thread-2&quot;...）</p></li>
</ul>

<h5 id="toc_9">a. Lock（线程同步）</h5>

<ul>
<li><strong>进程间通信主要是指多个进程间的数据交互,而线程间同步主要指维护多个线程之间数据准确、一致性</strong></li>
<li><p>在多进程中，变量在每个进程各自有一份拷贝，互不影响；而在多线程中，变量是所有线程共享，都可以被任何一个线程修改</p>

<pre><code class="language-python"># 模拟由于多线程，导致的数据错乱
import time, threading

balance = 0  # 假设银行存款

# 先存后取,结果应该为0
def change_it(n):
    # 声明为全局变量，这样可以就在函数内部&#39;修改&#39;变量值；
    # 否则，Python会认为该变量是函数内局部的，函数之外（主块）
    # 的同名变量是另一个变量，修改该变量（内部的）不会对外部的产生影响
    global balance  
    balance += n
    balance -= n

def run_thread(n):
    for i in range(1000000):
        change_it(n)

t1 = threading.Thread(target=run_thread, args=(2, ))
t2 = threading.Thread(target=run_thread, args=(8, ))
t1.start()
t2.start()
t1.join()
t2.join()
print(balance)
</code></pre>

<pre><code class="language-python"># 为确保balance计算正确，要给change_it()上一把锁；
# 当某个线程开始执行change_it()时获取了锁，因此其他线程不能同时
# 执行change_it()，只能等到锁被释放后，获取到该锁以后才能改
import time, threading

lock = threading.Lock()
balance = 0

def change_it(n):
    global balance
    balance += n
    balance -= n

def run_thread(n):
    for i in range(1000000):
        # 先要获取锁
        lock.acquire()
        try:
            change_it(n)
        finally:
            # 改完后一定要释放锁
            lock.release()

t1 = threading.Thread(target=run_thread, args=(2, ))
t2 = threading.Thread(target=run_thread, args=(8, ))
t1.start()
t2.start()
t1.join()
t2.join()
print(balance)
</code></pre></li>
<li><p>通过threading.Lock()创建一个锁；由于锁只有一个，同一时刻最多只有一个线程持有该锁，所以不会造成修改的冲突</p></li>
<li><p>获取到锁的线程用完后一定要释放锁，否则那些等待锁的线程将永远等待下去，成为死线程；用try...finally来确保锁一定会被释放</p></li>
<li><p>锁的好处是确保某段关键代码只能由一个线程从头到尾完整地执行，坏处是阻止了多线程并发执行</p></li>
<li><p>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成<strong>死锁</strong>，导致多个线程全部挂起，既不能执行，也无法结束，只能由系统强制终止</p></li>
</ul>

<h5 id="toc_10">b. 多核CPU（多线程执行）</h5>

<ul>
<li><p>若想让N核CPU的核心全部跑满，就必须启动N个死循环线程；比如，在多核CPU中，有2个死循环线程，会监控到占用200%的CPU，也就是占用2个CPU核心</p>

<ul>
<li>使用Python启动CPU核心数量的多个线程，比如在4核CPU上，会监控到CPU占用率为102%，也就是使用1核</li>
<li>使用C、C++、Java来改写相同的死循环，却可以把全部核心跑满（4核就用400%，8核就用800%），而Python却不可以</li>
</ul>

<pre><code class="language-python"># 尝试使用Python编写一个死循环（谨慎使用）
import threading, multiprocessing

def loop():
    x = 0
    while True:
        x = x ^ 1

for i in range(multiprocessing.cpu_count()):
    t = threading.Thread(target=loop)
    t.start()
</code></pre></li>
<li><p>Python的线程虽然是真正的线程，但是解释器执行代码时，有一个GIL锁（Gloabal Interpreter Lock)</p></li>
<li><p>任何线程执行前，必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行</p></li>
<li><p>GIL全局锁实际上把所有线程的执行代码都给上了锁，所以多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核</p></li>
<li><p>GIL是Python解释器设计的历史遗留问题，通常我们使用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器</p></li>
<li><p>Python虽然不能利用多线程实现多核任务（即不能并行；但可以并发），但是可以通过多进程实现多核任务；多个Python进程有各自独立的GIL锁，互不影响</p></li>
</ul>

<h5 id="toc_11">c. ThreadLocal（数据独立）</h5>

<ul>
<li><p>每个线程都有自己的数据；一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有当前线程可见，不会影响其他线程，而全局变量的修改必须加锁；但是使用局部变量，在函数调用的时候传递起来很麻烦</p>

<pre><code class="language-python">def process_thread():
    # std是局部变量，每个函数调用都必须传入
    # 这里不能使用全局变量，因为每个线程（process_thread）要处理不同的Student对象
    std = Student(name)
    func1(std)
    func2(std)
    func3(std)
    func4(std)
</code></pre></li>
<li><p>解决方案：使用一个全局的dict存放所有的Student对象，然后以thread自身作为key获取该线程对应的Student对象</p>

<pre><code class="language-python">global_dict = {}

def process_thread():
    std = Student(name)
    # 把std存放到全局变量globalDict中
    global_dict[threading.current_thread()] = std
    func1() 
    func2()
    func3()
    func4()
# funX()函数中使用s = global_dict[threading.current_thread()]的方式进行获取
</code></pre></li>
<li><p>Python的ThreadLocal提供上面的代码的封装，不用人为创建用于查找的dict，ThreadLocal自动做这件事情</p>

<pre><code class="language-python">import threading

class Student(object):
    def __init__(self, name):
        self.name = name

# a. 创建一个全局的ThreadLocal对象
local_student = threading.local()

def process_thread(name):
    # b. 绑定ThreadLocal的student
    local_student.std = Student(name)
    func1()

def func1():
    # c. 获取当前线程相关的student
    std = local_student.std
    print(&#39;Hello, %s, %s&#39; % (std.name, threading.current_thread().name))

t1 = threading.Thread(target=process_thread, args=(&#39;Tom&#39;, ), name=&#39;Thread-A&#39;)
t2 = threading.Thread(target=process_thread, args=(&#39;Jack&#39;, ), name=&#39;Thread-B&#39;)
t1.start()
t2.start()
# local\_student是全局变量，但是它的每个属性（如std）
# 是线程的局部变量，可以不用加锁任意读写互不干扰
</code></pre></li>
<li><p>ThreadLocal常见使用场景：为每个线程绑定一个数据库连接、HTTP请求、用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源</p></li>
</ul>

<h4 id="toc_12">11.5 进程 VS 线程</h4>

<ul>
<li>要实现多任务，通常会设计Master-Worker模式，Master（一个）负责分配任务，Worker（多个）负责执行任务；若用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker；若用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker</li>
<li>a. 多进程Master-Worker：

<ul>
<li>优点是稳定性高，一个子进程崩溃不会影响主进程和其他子进程（若主进程挂了则其他子进程也都会挂，但主进程只负责分配任务，挂掉的概率低）</li>
<li>缺点是创建进程的代价大（在Uinx/Linux使用fork调用还行，在Windows下创建进程开销巨大）；而且系统能同时运行的进程数也是有限制的，大量进程的系统调度也会成问题</li>
</ul></li>
<li>b. 多进程Master-Worker：

<ul>
<li>优点是通常比多进程快（但不明显）</li>
<li>缺点是任何一个线程挂掉都可能导致整个进程的崩溃，因为所有线程共享进程的内存</li>
</ul></li>
<li>无论是多进程还是多线程，只有任务数量一多，系统可能就主要忙着切换任务（保护现场、准备新环境），根本没有多少时间去执行任务，效率就上不去了</li>
</ul>

<h5 id="toc_13">a. 计算密集型 VS IO密集型</h5>

<ul>
<li>是否采用多任务还要考虑任务类型，可以任务分为计算密集型和IO密集型</li>
<li>计算密集型：

<ul>
<li>需要大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码，要高效利用CPU</li>
<li>任务同时进行的数量应当等于CPU的核心数；同时代码运行效率也很重要（Python运行效率很低，最好使用C语言编写）</li>
</ul></li>
<li>IO密集型：

<ul>
<li>涉及到网络、硬盘IO任务，消耗CPU很少，任务的大部分时间都在等待IO操作完成（IO速度远远低于CPU和内存速度）；</li>
<li>任务越多，CPU效率越高，但也有一个限度；最合适的语言就是开发效率高的语言，而不是运行速度极快的语言</li>
</ul></li>
</ul>

<h5 id="toc_14">b. 异步IO</h5>

<ul>
<li>由于CPU和IO之间的巨大速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程、单线程会导致别的任务无法并行执行，因此需要多进程、多线程支持任务并发执行</li>
<li>现在的系统对IO操作已做了巨大的改进，最大的特点就是支持异步IO</li>
<li>异步IO

<ul>
<li>可以用单进程、单线程模型来执行多任务，这种全新的模型称为事件驱动模型</li>
<li>Nginx就是支持异步IO的Web服务器，在单核CPU上采用单进程模型就可以高效支持多任务，在多核CPU上可以运行和CPU核心数相同的多个进程，充分利用多核CPU</li>
<li>使用异步IO来实现多任务是一个主要趋势</li>
</ul></li>
<li>Python中的<strong>单进程</strong>的<strong>异步编程模型</strong>称为<strong>协程（Coroutine）</strong></li>
</ul>

<h4 id="toc_15">11.6 分布式进程</h4>

<ul>
<li>在Process和Thread中应当优选Process，因为Process更稳定，而且Process可以分布在多台机器上，而Thread最多只能分布到同一台机器的多个CPU上</li>
<li><p>Python的multiprocessing模块不仅支持多进程，而且其managers子模块还支持把多进程分布到多台机器上；一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信</p>

<ul>
<li>之前的Queue不仅可以让两个进程在同一机器上进行通信，也可以让这两个进程在两个机器进行通信；继续使用原来的Queue，使用managers模块把Queue通过网络暴露出去，就可以让其他机器的进程访问该Queue了</li>
<li>服务进程负责启动Queue，把Queue注册到网络上，然后往Queue里面写入任务</li>
</ul>

<pre><code class="language-python"># 服务进程：task_master.py
import random, queue
from multiprocessing.managers import BaseManager

class QueueManager(BaseManager):  # 从BaseManager继承的QueueManager
    pass

task_queue = queue.Queue()    # 发送任务的队列
result_queue = queue.Queue()  # 接收结果的队列

# 把两个Queue都注册到网络上（name、callable参数关联的Queue对象）
QueueManager.register(&#39;get_task_queue&#39;, callable=lambda: task_queue)
QueueManager.register(&#39;get_result_queue&#39;, callable=lambda: result_queue)

# 绑定端口5000，设置验证码authkey进行机器验证
manager = QueueManager(address=(&#39;&#39;, 5000), authkey=b&#39;abc&#39;)
manager.start()  # 启动

# 获取通过网络访问的Queue对象
task = manager.get_task_queue()
result = manager.get_result_queue()

# 放几个任务进去
for i in range(10):
    n = random.randint(0, 10000)
    print(&#39;Put task %d...&#39; % n)
    task.put(n)

# 从result队列中读取结果
print(&#39;Try get result...&#39;)
for i in range(10):
    r = result.get(timeout=10)
    print(&#39;Result: %s&#39; % r)

manager.shutdown()  # 关闭
print(&#39;master exit...&#39;)
</code></pre></li>
<li><p>当在一台机器上编写多进程时，创建的Queue可以直接拿来使用；但是在分布式多进程情况下，不可以直接对原始的task_queue进行“添加任务到Queue”操作，必须使用通过manager.get_task_queue()获取Queue，进行添加（否则绕过了QueueManager对Queue的封装，注册Queue也就没有意义）；result_queue同理</p>

<pre><code class="language-python"># 任务进程：task_worker.py
import time, queue
from multiprocessing.managers import BaseManager

class QueueManager(BaseManager):  # 创建类似的QueueManager
    pass

# 由于只能从网络上获取Queue，所以注册时只提供name
# 注意服务进程和任务进程的注册Queue的名称要一致，否则报错
QueueManager.register(&#39;get_task_queue&#39;)
QueueManager.register(&#39;get_result_queue&#39;)

# 连接到服务器，也就是运行task_master.py的机器
# 任务进程需要通过网络连接到服务进程，要指定服务进程的IP
server_addr = &#39;127.0.0.1&#39;
print(&#39;Connect to server %s...&#39; % server_addr)
# 端口和验证码注意要和task_master.py设置的一致
manager = QueueManager(address=(server_addr, 5000), authkey=b&#39;abc&#39;)
manager.connect()  # 网络连接

# 获取通过网络访问的Queue对象
task = manager.get_task_queue()
result = manager.get_result_queue()

# 从task队列取任务，并把结果写入result队列
for i in range(10):
    try:
        n = task.get(timeout=1)
        print(&#39;run task %d...&#39; % n)
        r = &#39;%d * %d = %d&#39; % (n, n, n * n)
        time.sleep(1)
        result.put(r)
    except Queue.Empty:
        print(&#39;task queue is empty.&#39;)

# 处理结束，注意不要调用manager.shutdown()
print(&#39;worker exit...&#39;)
</code></pre></li>
<li><p>task_worker.py中并没有创建Queue，Queue对象在task_master.py进程中；使用QueueManager实现能够通过网络访问Queue</p></li>
<li><p>Queue的作用就是用来传递任务和接收结果，每个任务的描述数量要尽量小；比如，发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，再由Worker进程去路径位置读取日志文件</p></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3笔记(10IO编程)]]></title>
    <link href="http://www.justisit.com/15125773962028.html"/>
    <updated>2017-12-07T00:23:16+08:00</updated>
    <id>http://www.justisit.com/15125773962028.html</id>
    <content type="html"><![CDATA[<ul>
<li>
<a href="#toc_0">10. IO编程</a>
</li>
<li>
<a href="#toc_1">10.1 概述</a>
</li>
<li>
<a href="#toc_2">10.2 读写文件</a>
<ul>
<li>
<a href="#toc_3">a. 读文件</a>
</li>
<li>
<a href="#toc_4">b. 写文件</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">10.3 StringIO、BytesIO</a>
</li>
<li>
<a href="#toc_6">10.4 操作文件和目录</a>
</li>
<li>
<a href="#toc_7">10.5 序列化</a>
<ul>
<li>
<a href="#toc_8">a. JSON</a>
</li>
<li>
<a href="#toc_9">b. JSON进阶</a>
</li>
</ul>
</li>
</ul>


<h4 id="toc_0">10. IO编程</h4>

<h4 id="toc_1">10.1 概述</h4>

<ul>
<li>流只能单向流动；既收又发数据就必须建立两个流（输入流、输出流）</li>
<li>在IO编程中，存在着速度严重不匹配额问题，解决方式有两种：

<ul>
<li>a. CPU暂停执行后续代码，等待数据读取或写入完毕后再执行（同步IO模式）</li>
<li>b. CPU不等待继续执行后续代码，数据读取或写入一边进行着（异步IO模式）</li>
</ul></li>
<li>同步IO和异步IO的区别是否等待IO执行的结果；使用异步IO来编写的程序性能远远高于同步IO，但是异步IO的缺点是编程模型复杂，异步IO需要“通知”别人其已执行完毕，“通知”有两种：

<ul>
<li>a. 回调，IO主动告诉别人</li>
<li>b. 轮询，别人不断去检查IO是否执行完毕</li>
</ul></li>
<li>操作IO的能力是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外</li>
<li>本章讨论的IO编程都是同步模式的</li>
</ul>

<span id="more"></span><!-- more -->

<h4 id="toc_2">10.2 读写文件</h4>

<ul>
<li>读写磁盘上的文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘</li>
<li>读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后使用系统提供的接口从这个文件对象中读取数据、或者把数据写入这个文件对象</li>
</ul>

<h5 id="toc_3">a. 读文件</h5>

<ul>
<li>打开文件：<code>f = open(&#39;modeltest.py&#39;, &#39;r&#39;)</code> ，传入文件名和标示符（&#39;r&#39;表示读）；若文件不存在，这会抛出一个IOError（FileNotFoundError）异常</li>
<li>读文件：read()方法可以一次性读取文件的全部内容到内存中</li>
<li>关闭文件：调用close()方法关闭文件；文件使用完毕后必须关闭，因为文件对象会占用系统的资源，并且系统同一时间能打开的文件数量也是有限的</li>
<li><p>由于文件读写可能产生IOError，一旦异常错误会导致后面的close()方法不被调用了，所以要处理异常（在此位置关闭文件）</p>

<pre><code class="language-python"># try...finally来实现
try:
    f = open(&#39;modeltest.py&#39;, &#39;r&#39;)  # 默认调用read()方法时返回文本字符串（以UTF-8解码）
    print(f.read())
finally:
    if f:
        f.close()
</code></pre></li>
<li><p>Python引入了<code>with</code>语句可以自动调用close()方法，不需要认为调用close()方法，简化代码书写</p>

<pre><code class="language-python">with open(&#39;modeltest.py&#39;, &#39;r&#39;) as f:
    print(f.read())
</code></pre></li>
<li><p>调用read(size)方法，每次最多读取size个字节的内容；不加size参数则读取全部内容</p></li>
<li><p>调用readline()可以每次读取一行内容；调用readlines()一次读取所有内容并按行返回list</p></li>
<li><p>若文件小则调用read()，若不确定文件大小则反复调用read(size)比较保险，若是配置文件则调用readlines()最方便</p>

<pre><code class="language-python">with open(&#39;modeltest.py&#39;, &#39;r&#39;) as f:
    for line in f.readlines():
        print(line.strip())  # 将末尾的&#39;\n&#39;删掉
</code></pre></li>
<li><p>像open()函数返回的这种有read()方法的对象，在Python中统称为file-like Object；file-like Object除了file，还可以是内存的字节流、网络流、自定义流等，其不要求从特定类继承，只要有read()方法即可；比如，StringIO就是内存中创建的file-like Object，常用作临时缓冲</p></li>
<li><p>上面讲的都是调用read()方法时返回文本字符串（以UTF-8解码），若要调用read()方法时返回二进制数据，比如读取图片、视频等，则使用&#39;rb&#39;模式打开文件即可</p>

<pre><code class="language-python">with open(&#39;git.jpg&#39;, &#39;rb&#39;) as f:
    print(f.read())
# 返回数据
b&#39;\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00..&#39;

with open(&#39;orm.py&#39;, &#39;r&#39;) as f:
    print(f.read())  # 返回数据：class Field(object): 
with open(&#39;orm.py&#39;, &#39;rb&#39;) as f:
    print(f.read())  # 返回数据：b&#39;class Field(object):\r\n
</code></pre></li>
<li><p>字符编码：若要以指定编码读取文本文件，需要给open()函数传入encoding参数（二进制文件不需要encoding参数）；比如，读取UTF-8编码的文件</p>

<pre><code class="language-python">with open(&#39;orm.py&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
    print(f.read())
</code></pre></li>
<li><p>有些编码不规范的文本文件，可能夹杂了一些非法编码的字符，此时打开文件会抛出“UnicodeDecodeError”异常；open()函数还可接收一个errors参数，表示若遇到编码错误后该如何处理，最简单的方式是直接忽略</p>

<pre><code class="language-python">with open(&#39;orm.py&#39;, &#39;r&#39;, errors=&#39;ignore&#39;) as f:
    print(f.read())
</code></pre></li>
</ul>

<h5 id="toc_4">b. 写文件</h5>

<ul>
<li>在调用open()函数时，写文本文件传入标示符&#39;w&#39;、写二进制文件则传入标示符&#39;wb&#39;、追加文件则传入标示符&#39;a&#39;</li>
<li>可以反复调用write()写文件，最后必须调用close()关闭文件

<ul>
<li>当调用write()写文件时，系统不会立即把数据写入磁盘，而是先将数据放到内存缓存起来，空闲的时候再写入磁盘；只有调用close()方法，才能保证系统将数据全部写入磁盘</li>
</ul></li>
<li><strong>文件在磁盘中保存都是二进制数据的；有些二进制数据文件通过字符解码可以显示成有意义的文字，这些文字就是文本，那么这个文件就被称为文本文件；另一些二进制数据文件通过字符解码显示成无意义的文字，这个文字就不是文本，那么这个文件就被称为二进制文件，需要按照其他的特殊解码才能有意义，比如图片</strong></li>
<li><p><strong>编码是为了节约空间、标记数据类型，所以硬盘存储、网页传输都需要先编码</strong></p>

<pre><code class="language-python">with open(&#39;test.txt&#39;, &#39;w&#39;) as f:
    f.write(&#39;hello world&#39;)
</code></pre></li>
</ul>

<h4 id="toc_5">10.3 StringIO、BytesIO</h4>

<ul>
<li><p>数据的读写操作的不一定是文件，也可以是内存；StringIO就是在内存中读写str</p>

<pre><code class="language-python">from io import StringIO

f = StringIO()
f.write(&#39;hello&#39;)  # 写入数据
f.write(&#39; &#39;)
f.write(&#39;world&#39;)
print(f.getvalue())  # getValue()获取写入后的数据

# 用一个str初始化StringIO，之后就可以像操作文件的方式操作StringIO
f = StringIO(&#39;Hello\nWorld&#39;)  
while True:
    s = f.readline()
    if s == &#39;&#39;:
        break
    print(s.strip())
</code></pre></li>
<li><p>StringIO操作的只能是str，若需要操作二进制数据就需要使用BytesIO</p>

<pre><code class="language-python">from io import BytesIO

f = BytesIO()
# 注意写入的不是str，而是经过UTF-8编码的bytes
f.write(&#39;中文&#39;.encode(&#39;utf-8&#39;)) 
print(f.getvalue())

f = BytesIO(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)
print(f.read())
</code></pre></li>
</ul>

<h4 id="toc_6">10.4 操作文件和目录</h4>

<ul>
<li><p>要操作文件、目录，可以在命令行下输入系统提供的各种命令来完成，比如dir、cp等命令；其实系统提供的命令只是调用了系统提供的接口函数，Python内置的os模块也可以直接调用系统提供的接口函数</p>

<pre><code class="language-python">import os  # 导入os模块，注意os模块的某些函数与特定操作系统相关的

print(os.name)  # 系统类型，Linux、Unix、OSX是posix，Windows是nt
print(os.uname())  # 详细系统信息（Windows不支持）
print(os.environ)  # 系统的所有环境变量
print(os.environ.get(&#39;PATH&#39;))  # 获取环境变量PATH的值
print(os.environ.get(&#39;X&#39;, &#39;default&#39;))  # 获取环境变量X的值
</code></pre></li>
<li><p>操作文件、目录的函数有些在os模块中，有些在os.path模块中</p>

<pre><code class="language-python">os.mkdir(new) # 创建目录
os.rmdir(new) # 删除目录

base = os.path.abspath(&#39;.&#39;)  # 获取当前的绝对路径
print(base)
newpath = os.path.join(base, &#39;test&#39;)  # 拼接路径
print(newpath)
</code></pre></li>
<li><p>操作文件路径时不要直接拼接、拆分字符串，应该使用join()、split()函数，这样可以正确处理不同系统的文件路径分隔符</p></li>
<li><p>文件路径的拼接、拆分函数并不要求目录和文件真实存在，它们只是对字符串进行操作</p>

<pre><code class="language-python"># split拆分一个路径为两部分，后面一部分为最后级别的目录或文件名
print(os.path.split(&#39;/Users/scott/Desktop/task_master.py&#39;))  
# 结果：(&#39;/Users/scott/Desktop&#39;, &#39;task_master.py&#39;)

# splitext拆分一个路径为两部分，后面一部分为文件的扩展名
print(os.path.splitext(&#39;/Users/scott/Desktop/task_master.py&#39;))  
# 结果：(&#39;/Users/scott/Desktop/task_master&#39;, &#39;.py&#39;)

os.rename(&#39;test.txt&#39;, &#39;abc.txt&#39;)  # 文件重命名
os.remove(&quot;abc.txt&quot;)  # 删除文件
</code></pre></li>
<li><p>os模块没有提供复制文件的函数</p></li>
<li><p>shutil模块提供了copyfile()函数用于复制文件；该模块中还有其他实用函数，可以看作是os模块的补充</p>

<pre><code class="language-python">import shutil

shutil.copyfile(&quot;orm.py&quot;, &#39;orm.txt&#39;)  # 复制文件
</code></pre></li>
<li><p>os.listdir()函数可以列举文件；并且可以进一步进行过滤</p>

<pre><code class="language-python"># 列出当前目录下的所有目录
l = [x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)]
print(l)

# 列出当前目录下的所有的.py文件
l = [x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1]==&#39;.py&#39;]
print(l)
</code></pre>

<pre><code class="language-python"># 练习1：利用os模块编写一个实现ls -l输出程序
import os
from datetime import datetime

print(&#39;      Size    Last Modified       Name&#39;)
print(&#39;--------------------------------------------&#39;)
for f in os.listdir(os.path.abspath(&#39;.&#39;)):
    size = os.path.getsize(f)
    time = datetime.fromtimestamp(os.path.getmtime(f)).strftime(&#39;%Y-%m-%d %H:%M&#39;)
    flag = &#39;/&#39; if os.path.isdir(f) else &#39;&#39;
    print(&#39;%10d    %s    %s%s&#39; % (size, time, f, flag))

# 练习2： 打印当前目录及其子目录包含指定字符串的文件
import os

def search_key(path, key):
    fs = [x for x in os.listdir(path)]
    result = []
    for f in fs:
        f = os.path.join(path, f)
        if os.path.isdir(f):
              # listA.extend(listB)即复制listB中的元素到listA中
              # 注意这里不能使用append（若用append，则增加的是数组，而不是数组中的元素）
            result.extend(search_key(f, key))
        elif key in f:  # 判断字符串中是否包含指定字符串，可以用in来判断
            result.append(f)
    return result

l = search_key(os.path.abspath(&#39;.&#39;), &#39;xx&#39;)
print(l)
</code></pre></li>
</ul>

<h4 id="toc_7">10.5 序列化</h4>

<ul>
<li>把内存中的数据变为可存储数据的过程称之为序列化，在Python中叫pickling（pickle：腌渍泡菜等），其他语言中称为serialization、marshalling、flattening等；<strong>序列化之后，就可以把序列化后的内容写入磁盘或者网络传输到其他设备上</strong></li>
<li>反过来，把序列化的数据重新读到内存里的过程称之为反序列化，即unpickling</li>
<li>Python提供了picke模块来实现序列化、反序列化</li>
<li><p>picke.dump()函数（dump：倾倒、倾销）将对象序列化后写入一个file-like Object；picke.dumps()函数将对象序列化成一个bytes数据</p>

<pre><code class="language-python">import pickle

d = dict(name=&#39;Tom&#39;, age=20, score=99)
# 方式一：
with open(&#39;dump.txt&#39;, &#39;wb&#39;) as f:
    pickle.dump(d, f)
# dump.txt存放着Python保存的对象内部信息

# 方式二：
b = pickle.dumps(d)
print(b)
</code></pre></li>
<li><p>pickle.load()函数从一个file-like Object中直接反序列化出对象；pickle.loads()函数将一个bytes数据序列化出对象</p>

<pre><code class="language-python"># 方式一：
with open(&#39;dump.txt&#39;, &#39;rb&#39;) as f:
    d = pickle.load(f)      
print(d)

# 方式二：
d = pickle.loads(b) 
print(d)
</code></pre></li>
<li><p><strong>反序列化得到的对象只是内容和之前的一样，但是和之前的对象没有任何关系</strong></p></li>
<li><p>pickle是Python特有的序列化技术，不同语言的序列化后的数据不兼容；并且不同版本Python的pickle的数据可能彼此不兼容</p></li>
</ul>

<h5 id="toc_8">a. JSON</h5>

<ul>
<li><p>Python内置的json模块提供了Python对象到JSON字符串的转换</p>

<pre><code class="language-python">import json

# Obj TO Json str方式一：
# 将Python对象序列化成JSON字符串后写入file-like Object
with open(&#39;json.txt&#39;, &#39;w&#39;) as f:
    json.dump(d, f)

# Obj TO Json str方式二：
# 将对象序列化成JSON字符串，内容是标准的JSON字符串
d = dict(name=&#39;Tom&#39;, age=20, score=99)
s = json.dumps(d)  
print(s)

# Json str TO Obj方式一：
# 从file-like Object中读取JSON字符串后，反序列化为Python对象
with open(&#39;json.txt&#39;, &#39;r&#39;) as f:
    d = json.load(f)  
    print(d)

# Json str TO Obj方式二：
# 将JSON字符串反序列化为Python对象
json_str = &#39;{&quot;score&quot;: 99, &quot;age&quot;: 20, &quot;name&quot;: &quot;Tom&quot;}&#39;
d = json.loads(json_str) 
print(d)
</code></pre></li>
</ul>

<h5 id="toc_9">b. JSON进阶</h5>

<ul>
<li><p>对自定义对象进行序列化、反序列化需要设置“转换函数”（告诉dump如何去序列化），否则报TypeError错误</p>

<pre><code class="language-python">import json

class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score

# 转换函数        
def student2dict(stu):
    return {
        &#39;name&#39;: stu.name,
        &#39;age&#39;: stu.age,
        &#39;score&#39;: stu.score
    }
def dict2student(d):
     return Student(d[&#39;name&#39;], d[&#39;age&#39;], d[&#39;score&#39;])

# Obj TO Json str
# 序列化通过default参数设置转换函数
s = Student(&#39;Tom&#39;, 20, 10)
# 方式一：
print(json.dumps(s, default=student2dict)) 
# 方式二：
# 不人为自定义转换函数，使用lambda obj: obj.__dict__
# 通常class的实例都有一个__dict__属性（dict），
# 存储着属性name及value（定义了__slots__的class除外）
print(json.dumps(s, default=lambda obj: obj.__dict__))

# Json str TO Obj
# 反序列化通过object__hook参数设置转换函数
json_str = &#39;{&quot;score&quot;: 99, &quot;age&quot;: 20, &quot;name&quot;: &quot;Tom&quot;}&#39;
s = json.loads(json_str, object_hook=dict2student)
print(s)
</code></pre></li>
</ul>
]]></content>
  </entry>
  

</feed>
