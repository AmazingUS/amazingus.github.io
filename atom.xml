<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[TIME TO GO]]></title>
  <link href="http://www.justisit.com/atom.xml" rel="self"/>
  <link href="http://www.justisit.com/"/>
  <updated>2017-12-04T23:27:04+08:00</updated>
  <id>http://www.justisit.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="">ME</generator>
  
  <entry>
    <title type="html"><![CDATA[Ruby环境搭建教程]]></title>
    <link href="http://www.justisit.com/Ruby%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B.html"/>
    <updated>2016-08-12T00:11:39+08:00</updated>
    <id>http://www.justisit.com/Ruby%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">一、安装</a>
</li>
<li>
<a href="#toc_1">二、rbenv</a>
</li>
<li>
<a href="#toc_2">三、gem模块</a>
</li>
<li>
<a href="#toc_3">四、gemset模块</a>
</li>
</ul>


<h4 id="toc_0">一、安装</h4>

<ul>
<li>Ruby安装方式有多种方式，可以通Ruby安装包、Homebrew、rbenv或RVM等；</li>
<li><p>rbenv和RVM都可进行Ruby多版本管理，等同于Node.js中的nvm、Python中的pyenv；这里使用rbenv进行安装（rbenv的GitHub Star比RVM的多）；</p>

<ul>
<li><p>第1步：安装rbenv</p>

<pre><code>brew install rbenv
</code></pre>

<p><img src="media/14709318994406/install_rbenv.png" alt="install_rbenv" style="width:595px;"/></p></li>
<li><p>第2步：安装某个版本的Ruby；</p>

<pre><code>rbenv install &lt;VERSION&gt;
</code></pre></li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->

<h4 id="toc_1">二、rbenv</h4>

<ul>
<li><p>rbenv的原理及使用和Python中的pyenv几乎是一样的；</p>

<pre><code>rbenv version # 查看当前Ruby版本（以ruby --version为准）
rbenv versions # 查看已安装的Ruby版本（system为系统默认安装的）

rbenv install -l # 查看可以安装的Ruby版本
rbenv uninstall &lt;VERSION&gt; # 安装某个版本的Ruby
rbenv rehash # 刷新shims（有时install或切换版本后需要执行一下）
rbenv uninstall &lt;VERSION&gt; # 卸载某个版本的Ruby

rbenv global [VERSION] # 查看或设置全局的Ruby版本
rbenv local [VERSION] # 查看或设置目录的Ruby版本
rbenv shell [VERSION] # 查看或设置当Shell的Ruby版本
rbenv &lt;local | shell&gt; --unset # 取消某个级别设置的Ruby版本
</code></pre></li>
</ul>

<h4 id="toc_2">三、gem模块</h4>

<ul>
<li><p>gem（RubyGems）是Ruby的包管理工具（其也是一个包），类似于Node.js的npm、Python的pip；</p>

<pre><code>gem -v # 查看gem版本
gem environment # 查看gem的环境信息
gem help [COMMAND] # 查看相关帮助

gem list # 查看已安装的包
gem outdated # 查看需要更新的包
gem search &lt;PACKAGE&gt; # 查找包，如gem search rails

gem install &lt;PACKAGE&gt; [-v &lt;VERSION&gt;] # 安装包，例如gem install rails -v 4.0
gem uninstall &lt;PACKAGE&gt; # 卸载包（不会卸载其依赖包）
gem update --system # 更新RubyGems（gem）
gem update [&lt;PACKAGE&gt;] # 更新所有、某个包（会保留老版本的包）
gem cleanup # 清除所有包的旧版本，保留最新版本

gem dependency &lt;PACKAGE&gt; # 查看已安装包的依赖包
</code></pre>

<pre><code># Gem的安装源配置在~/.gemrc文件中，所有版本的Ruby/Gem共用
gem sources -l # 查看gem的安装源
gem sources -a &lt;URL&gt; # 增加一个gem的安装源
gem sources -r &lt;URL&gt; # 删除某个gem的安装源
gem sources -c # 删除所有gem的安装源
</code></pre></li>
</ul>

<h4 id="toc_3">四、gemset模块</h4>

<ul>
<li>gemset可以为不同项目设置独立的虚拟的gem环境，其等同于Python中的virtualenv；</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python3环境搭建教程]]></title>
    <link href="http://www.justisit.com/14702376488769.html"/>
    <updated>2016-08-03T23:20:48+08:00</updated>
    <id>http://www.justisit.com/14702376488769.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">一、安装、卸载</a>
</li>
<li>
<a href="#toc_1">二、pyenv</a>
</li>
<li>
<a href="#toc_2">三、pip模块</a>
</li>
<li>
<a href="#toc_3">四、pyenv、virtualenv配合</a>
</li>
<li>
<a href="#toc_4">五、参考</a>
</li>
</ul>


<h4 id="toc_0">一、安装、卸载</h4>

<ul>
<li>Python的安装方式有多种方式，可以通过Python安装包、Homebrew、pyenv等；</li>
<li><p>建议使用pyenv进行安装，pyenv可以很好地进行Python多版本管理，等同于NodeJS中的nvm；这里使用pyenv进行安装；</p>

<ul>
<li><p>第1步：安装pyenv；</p>

<pre><code>brew install pyenv
</code></pre>

<p><img src="media/14702376488769/pyenv_install.png" alt="pyenv_instal"/></p>

<span id="more"></span><!-- more -->

<ul>
<li>（必须）向~/.bash_profile文件中添加 <code>if which pyenv &gt; /dev/null; then eval &quot;$(pyenv init -)&quot;; fi</code>，保存后，执行 <code>source ~/.bash_profile</code> 应用配置；否则执行pyenv shell时报错：pyenv: no such command &#39;shell&#39;；</li>
<li>（可选）使用pyenv安装的Python版本默认存放在/Users/USERNAME/.pyenv/versions/目录中，而不是Homebrew的相关目录中；向~/.bash_profile文件中添加 <code>export PYENV_ROOT=/usr/local/var/pyenv</code>，让其安装到Homebrew的/usr/local/var/pyenv/versions/目录中；</li>
</ul></li>
<li><p>第2步：安装某个版本的Python；</p>

<pre><code>pyenv install &lt;VERSION&gt;
</code></pre></li>
<li><p>第3步：安装完成后，执行brew doctor进行检查；若出现以下警告：<code>Warning: &quot;config&quot; scripts exist outside your system or Homebrew directories...</code>，则需要向~/.bash_profile文件中添加 <code>alias brew=&#39;&quot;env&quot; PATH=${PATH//$(pyenv root)\/shims:/} brew&#39;</code> 即可解决；<br/>
<img src="media/14702376488769/pyenv_warning.png" alt="pyenv_warning" style="width:617px;"/></p></li>
</ul></li>
<li><p>通过pyenv安装Python，卸载也需要通过pyenv进行卸载；若手动直接安装Python则需要手动卸载（相关命令如下）；</p>

<pre><code>sudo rm -rf /Applications/Python X.X
sudo rm -rf /Library/Frameworks/Python.framework

sudo rm /var/db/receipts/org.python.*
~/.base_profile中删除关于Python相关的PATH值
</code></pre>

<ul>
<li><p>Shell命令补充：删除无效文件链接（新建脚本文本，内容如下，添加执行权限）</p>

<pre><code># 遍历所有软链接
for a in `find /usr/local/bin -type l`
do  
# stat –L：若链接无效返回1，有效返回0
stat -L $a &gt;/dev/null 2&gt;/dev/null
if [ $? -gt 0 ]  # -gt大于，-eq等于
then
echo $a
rm $a
fi
done
</code></pre></li>
</ul></li>
</ul>

<h4 id="toc_1">二、pyenv</h4>

<ul>
<li><p>某些系统工具依赖于Python，切换Python的版本可能导致这些工具无法使用；为了解决此问题，pyenv提供了切换Python版本的三种级别（shell &gt; local &gt; global）；</p>

<ul>
<li>shell：对当前shell的临时设定Python版本，退出后失效；</li>
<li>local：对当前目录及子目录（子目录没有.python_version的情况下）设定Python版本，会在当前目录下创建.python_version；</li>
<li>global：直接对系统全局默认的Python进行修改，不建议使用；</li>
</ul>

<pre><code>pyenv version # 查看当前pyenv版本（以python --version为准）
pyenv versions # 查看已安装的Python版本（system为系统默认安装的）

pyenv install -l # 查看可以安装的Python版本
pyenv install &lt;VERSION&gt; # 安装某个版本的Python
pyenv rehash # 刷新shims（install之后使用）
pyenv uninstall &lt;VERSION&gt; # 卸载某个版本的Python

pyenv global [VERSION] # 查看或设置全局的Python版本
pyenv local [VERSION] # 查看或设置目录的Python版本
pyenv shell [VERSION] # 查看或设置Shell的Python版本
pyenv &lt;local | shell&gt; --unset # 取消某个级别设置的Python版本
</code></pre>

<p><img src="media/14702376488769/pyenv_local.png" alt="pyenv_loca" style="width:344px;"/></p></li>
<li><p><strong>pyenv和virtualenv的比较：</strong></p>

<ul>
<li><strong>pyenv是系统级别的多版本管理；对于使用同一版本Python的所有项目，都是使用相同的Python环境，模块被安装在系统目录下，共用同一套模块；</strong></li>
<li><strong>virtualenv是项目级别的多版本管理；不同项目中的Python是独立的（即使使用相同的Python版本），一个项目中的模块只能在该项目中使用，模块被安装在当前项目目录中；</strong></li>
</ul></li>
</ul>

<h4 id="toc_2">三、pip模块</h4>

<ul>
<li><p>pip是Python的模块管理工具（其也是一个模块），类似于Node.js的npm；</p>

<pre><code>pip list # 查看已安装的模块
pip list &lt;--outdated | -o&gt; # 查看需要更新的模块

pip freeze # 只列出由pip安装的模块
pip freeze &gt; &lt;FILE_NAME&gt; # 将由pip安装的模块，写入到模块依赖描述文件中
# 例如pip freez &gt; requirements.txt

pip install &lt;PACKAGE&gt; # 安装模块
pip install -r requirements.txt # 根据模块依赖描述文件安装模块
pip install &lt;PACKAGE&gt; --user # 安装模块到用户目录中
pip uninstall &lt;PACKAGE&gt; # 卸载模块
pip install &lt;--upgrade | -U&gt; &lt;PACKAGE&gt; # 更新模块，例如pip install -U pip

pip show &lt;PACKAGE&gt; # 查看已安装的某个模块信息 
</code></pre></li>
<li><p>macOS系统默认安装的Python2.X没有安装pip，需要自己安装（相关步骤如下）；</p>

<pre><code>wget https://bootstrap.pypa.io/get-pip.py # 下载pip安装脚本

sudo python get-pip.py # 执行脚本进行安装
</code></pre></li>
</ul>

<h4 id="toc_3">四、pyenv、virtualenv配合</h4>

<ul>
<li>virtualenv也是一个模块，需要通过pip进行安装；所以在某个版本Python上安装了virtualenv，只能在该版本Python环境下执行virtualenv命令；</li>
<li><p>但是可以在执行virtualenv命令时加-p参数，指定创建虚拟环境时所使用的Python版本；不加-p参数则使用当前virtualenv的Python版本；</p>

<pre><code># 使用指定Python的版本，创建Python虚拟环境vvv
virtualenv -p /Users/scott/.pyenv/versions/3.5.2/bin/pip3 vvv 

source vvv/bin/activate # 激活虚拟环境
deactivate # 关闭虚拟环境
</code></pre></li>
<li><p>创建Python虚拟环境，除了使用给每个版本的Python都安装的virtualenv模块外，还可以使用pyenv-virualenv插件；</p>

<ul>
<li><p>pyenv-virualenv插件是pyenv插件化的“virtualenv”；它是pyenv的插件，不属于某个版本的Python，为所有版本的Python提供创建虚拟环境的功能；</p>

<pre><code>brew install pyenv-virtualenv
</code></pre></li>
<li><p>向~/.bash_profile文件中添加 <code>if which pyenv-virtualenv-init &gt; /dev/null; then eval &quot;$(pyenv virtualenv-init -)&quot;; fi</code>，保存后，执行 <code>source ~/.bash_profile</code> 应用配置；</p></li>
<li><p><strong>使用pyenv-virtualenv创建的Python虚拟环境与直接使用virtualenv创建的效果一样，只是虚拟环境的文件目录被设置在~/.pyenv/versions/目录下，而virtualenv设置在当前目录下；</strong></p>

<pre><code>pyenv virtualenv &lt;VERSION&gt; &lt;ENV_NAME&gt; # 创建一个虚拟环境

pyenv virtualenvs # 查看已创建的虚拟环境
pyenv versions # 查看Python版本
# 在pyenv看来，虚拟环境是一个“特殊”的Python版本

pyenv activate &lt;ENV_NAME&gt; # 激活虚拟环境，也可使用&quot;pyenv shell &lt;ENV_NAME&gt;&quot;命令
pyenv deatcive # 关闭虚拟环境，也可使用&quot;pyenv shell &lt;OTHER_VERSION&gt;&quot;命令

pyenv uninstall &lt;ENV_NAME&gt; # 卸载（删除）虚拟环境
</code></pre></li>
</ul></li>
</ul>

<h4 id="toc_4">五、参考</h4>

<ul>
<li>1. pyenv的安装和使用：<code>http://v2in.com/pyenv-installation-and-usage.html</code></li>
<li>2. 搭建基本的 Python 开发环境：<code>http://www.dreamxu.com/build-a-basic-python-development-environment/</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Homebrew使用教程]]></title>
    <link href="http://www.justisit.com/14694520920617.html"/>
    <updated>2016-07-25T21:08:12+08:00</updated>
    <id>http://www.justisit.com/14694520920617.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">一. 概述</a>
</li>
<li>
<a href="#toc_1">二、安装、卸载</a>
</li>
<li>
<a href="#toc_2">三、brew常用命令</a>
</li>
<li>
<a href="#toc_3">四、Homebrew-cask</a>
</li>
<li>
<a href="#toc_4">五、常用开发工具</a>
<ul>
<li>
<a href="#toc_5">5.1 MySQL</a>
</li>
<li>
<a href="#toc_6">5.2 Oracle Java</a>
</li>
<li>
<a href="#toc_7">5.3 Tomcat</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">六、管理工具</a>
<ul>
<li>
<a href="#toc_9">6.1 Cakebrew</a>
</li>
<li>
<a href="#toc_10">6.2 LaunchRocket</a>
</li>
</ul>
</li>
</ul>


<h4 id="toc_0">一. 概述</h4>

<ul>
<li>Homebrew（简称brew）是macOS中的软件管理工具，可以方便地安装、更新、卸载软件，类似Ubuntu系统中的apt-get；</li>
<li>macOS默认安装了Python、Ruby、Perl、Apache/PHP等开发程序，但是版本比较旧；若直接使用新版本替换系统的旧版本，会引发一些问题，Homebrew可以很好地将其安装的开发工具与系统默认的隔离开来；</li>
</ul>

<h4 id="toc_1">二、安装、卸载</h4>

<ul>
<li>brew是基于Ruby运行的工具，必须先安装Ruby；</li>
<li><p>在终端中执行以下指令（可在 <code>https://brew.sh/</code> 页面中获取）即可自动安装，路径为/usr/local/Homebrew/，其中/usr/local/Homebrew/Library/是brew系统的自身目录；</p>

<pre><code class="language-ruby">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>

<span id="more"></span><!-- more -->

<ul>
<li>brew会创建/usr/local/Cellar/目录，用于存放通过其安装的程序，文件夹结构为“程序名/版本号”；</li>
<li>/usr/local/bin/目录存放程序的启动链接（相当于快捷方式）；brew也会在此创建通过其安装的程序的启动链接</li>
<li>brew安装的程序的配置文件默认存放在/usr/local/etc/目录中；</li>
</ul></li>
<li><p>在终端中执行以下指令（可在 <code>https://docs.brew.sh/FAQ.html</code> 页面中获取）即可自动卸载；</p>

<pre><code class="language-ruby">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;
</code></pre></li>
</ul>

<h4 id="toc_2">三、brew常用命令</h4>

<ul>
<li><p>可以使用 <code>brew doctor</code> 命令检测操作brew（安装、卸载程序等）后是否有什么问题；比如，若报以下警告，按照提示进行解决，之后再执行 <code>source .bash_profile</code> ；<br/>
<img src="media/14694520920617/brew_warning.png" alt="brew_warning"/></p></li>
<li><p>执行 <code>brew install</code> 之后，要注意终端输出日志，从而采取操作的操作（caveats: 警告、附加说明）；<br/>
<img src="media/14694520920617/caveats.png" alt="caveats"/></p>

<pre><code>brew -h | --help # 查看brew帮助（使用--时，命令要写全）
brew -v | --version # 查看brew当前的版本
brew update # 更新brew

brew list # 查看通过brew安装的程序
brew outdated # 查看哪些程序可以更新
brew search &lt;NAME&gt; # 搜索某个程序，例如brew search wget；NAME支持正则表达式，例如brew search /wge*/

brew install &lt;NAME&gt; # 安装某个程序，例如brew install wget
brew uninstall | remove &lt;NAME&gt; # 卸载某个程序（不会卸载相关包依赖），例如brew uninstall wget
brew upgrade [NAME] # 更新所有程序（或某个程序）

brew info &lt;NAME&gt; # 查看某个程序的相关信息
brew deps &lt;NAME&gt; # 查看某个程序的包依赖
brew home [NAME] # 使用浏览器打开brew（或某个程序）的主页
</code></pre></li>
</ul>

<h4 id="toc_3">四、Homebrew-cask</h4>

<ul>
<li>Homebrew-cask是Homebrew的一个扩展，用于安装图形界面程序（例如Chrome、QQMusic等），其命令为 <code>brew cask ...</code> ；</li>
<li>brew用于安装不带界面的命令行工具，brew cask用于安装带界面的应用软件；</li>
<li>Homebrew-cask有两个安装索引源，一个是稳定版本 <code>https://github.com/phinze/homebrew-cask</code> ，一个是开发版本 <code>https://github.com/caskroom/homebrew-versions</code> ；安装了Homebrew即可直接使用Homebrew-cask稳定版本的索引源；</li>
<li><p>Homebrew-cask和Homebrew的搜索、安装、卸载、更新等操作是独立的；</p>

<pre><code>brew cask list # 查看通过Homebrew-cask安装的程序
brew cask search &lt;NAME&gt; # 搜索某个程序，例如brew cask search qqmusic

brew cask install &lt;NAME&gt; # 安装某个程序（路径为/Applications目录），例如brew cask install qqmusic
brew cask uninstall | remove &lt;NAME&gt; # 卸载某个程序，例如brew cask uninstall qqmusic
····
</code></pre></li>
<li><p>注意：Homebrew-cask<strong>没有提供<code>brew cask upgrade [NAME]</code>的命令升级程序版本</strong>，只能重新安装程序；</p></li>
</ul>

<h4 id="toc_4">五、常用开发工具</h4>

<h5 id="toc_5">5.1 MySQL</h5>

<ul>
<li><p>安装MySQL后，根据相关的信息配置MySQL；</p>

<pre><code>brew install msysql
</code></pre>

<p><img src="media/14694520920617/brew_install_mysql.png" alt="brew_install_mysq"/></p>

<ul>
<li>首先执行 <code>mysql.server start</code> 或 <code>brew servers start mysql</code> 启动MySQL（关闭使用stop命令），之后才可以连接数据库（<code>mysql -uroot</code>）；否则会报错：<code>Can&#39;t connect to local MySQL server through socket &#39;/tmp/mysql.sock&#39; (2)</code> ；</li>
<li>MySQL默认没有设置密码；若需要设置密码，执行 <code>mysql_secure_installation</code> ，此时会提醒安装“VALIDATE PASSWORD PLUGIN”，选择<strong>NO</strong>，否则无法设置简单密码，之后按照后续提示进行操作即可；</li>
</ul></li>
<li><p>MySQL的数据库文件默认存放在/usr/local/var/mysql/目录中，可执行SQL语句进行查看：<code>show global variables like &quot;%datadir%&quot;;</code> ；当卸载时，若要完全删除MySQL，必须手动删除该数据库文件；<br/>
<img src="media/14694520920617/datadir.png" alt="datadi" style="width:373px;"/></p></li>
<li><p>通过brew安装MySQL，卸载时通过brew卸载即可；若是手动安装，则需要手动卸载（命令如下）；</p>

<pre><code>sudo rm /usr/local/mysql
sudo rm -rf /usr/local/mysql*
sudo rm -rf /Library/StartupItems/MySQLCOM
sudo rm -rf /Library/PreferencePanes/My*
sudo rm -rf ~/Library/PreferencePanes/My*
sudo rm -rf /Library/Receipts/mysql*
sudo rm -rf /Library/Receipts/MySQL*
sudo rm -rf /var/db/receipts/com.mysql.* 
vim /etc/hostconfig  (and removed the line MYSQLCOM=-YES-)

sudo rm -rf /usr/local/var/mysql # 删除数据库文件
</code></pre></li>
</ul>

<h5 id="toc_6">5.2 Oracle Java</h5>

<ul>
<li><p>注意是使用Homebrew-cask进行安装（可以执行 <code>brew search java</code> 命令查询安装源是Homebrew，还是Homebrew-cask）；若之前手动安装过Oracle Java，需要先进行手动卸载（命令如下；参考 <code>https://docs.oracle.com/javase/9/install/installation-jdk-and-jre-macos.htm</code> ）；</p>

<pre><code>brew cask install java # 安装Oracle Java
brew cask uninstall java # 卸载Oracle Java
</code></pre></li>
<li><p>Uninstalling the JDK on macOS<br/>
<img src="media/14694520920617/uninstall_jdk.png" alt="uninstall_jdk"/></p></li>
<li><p>Uninstalling the JRE on macOS<br/>
<img src="media/14694520920617/uninstall_jre.png" alt="uninstall_jre"/></p>

<pre><code>sudo rm -rf /Library/Java

sudo rm -rf /Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin
sudo rm -rf /Library/PreferencePanes/JavaControlPanel.prefPane

sudo rm -rf /Library/LaunchAgents/com.oracle.java.Java-Updater.plist
sudo rm -rf /Library/LaunchDaemons/com.oracle.java.JavaUpdateHelper.plist
sudo rm -rf /Library/Preferences/com.oracle.java.Helper-Tool.plist
sudo rm -rf /Library/PrivilegedHelperTools/com.oracle.java.JavaUpdateHelper
sudo rm /var/db/receipts/com.oracle.*
...
</code></pre>

<ul>
<li><p>Shell命令补充：查找匹配、删除文件</p>

<pre><code># 全盘查找带“编程”的目录（d）、普通文件（f）、链接文件（l）等文件
find / -name &quot;*编程*&quot;
# 当前目录查找带“编程”的普通文件
find . -name &quot;*编程*&quot; -type f

# 当前目录查找带“编程”的普通文件，并删除（不带打印）
find . -name &quot;*编程*&quot; -type f | xargs rm -rf
</code></pre></li>
</ul></li>
</ul>

<h5 id="toc_7">5.3 Tomcat</h5>

<ul>
<li><p>Tomcat后运行服务后，默认网址为 <code>http://localhost:8080/</code> ；</p>

<pre><code>brew install tomcat # 安装tomcat

catalina run # 在当前窗口中运行tomcat
catalina start # 运行tomcat
catalina stop # 关闭tomcat
</code></pre></li>
</ul>

<h4 id="toc_8">六、管理工具</h4>

<h5 id="toc_9">6.1 Cakebrew</h5>

<ul>
<li>Cakebrew是一个图形化的Homebrew，通过该工具不使用brew命令就可以进行Homebrew的管理；<code>https://www.cakebrew.com/</code>
<img src="media/14694520920617/cakebrew.png" alt="cakebre" style="width:560px;"/></li>
</ul>

<h5 id="toc_10">6.2 LaunchRocket</h5>

<ul>
<li>LaunchRocket可以管理通过Homebrew安装的service，查看service的运行状态；<code>https://github.com/jimbojsb/launchrocket</code></li>
<li>注意：先将service关闭后，再通过LaunchRocket进行管理；
<img src="media/14694520920617/launchrocket.png" alt="launchrocket" style="width:664px;"/></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.js环境搭建教程]]></title>
    <link href="http://www.justisit.com/Node.js%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B.html"/>
    <updated>2016-07-26T00:08:47+08:00</updated>
    <id>http://www.justisit.com/Node.js%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">一、安装、卸载</a>
</li>
<li>
<a href="#toc_1">二、nvm</a>
</li>
<li>
<a href="#toc_2">三、nmp模块</a>
</li>
<li>
<a href="#toc_3">四、n模块</a>
</li>
<li>
<a href="#toc_4">五、package.json</a>
</li>
<li>
<a href="#toc_5">六、HTTP Demo</a>
</li>
</ul>


<h4 id="toc_0">一、安装、卸载</h4>

<ul>
<li>Node.js的安装方式有多种方式，可以通过Node.js安装包、Homebrew、nvm等；</li>
<li><p>nvm（Node Version Manager）可以很好地进行Node.js多版本管理；在这里使用nvm进行安装Node.js</p>

<ul>
<li><p>第1步：安装nvm（安装方式也有多种，这里使用brew）；</p>

<pre><code>brew install nvm
</code></pre>

<p><img src="media/14694629279396/nvm_caveats.png" alt="nvm_caveats" style="width:634px;"/></p>

<span id="more"></span><!-- more -->

<ul>
<li>a. 创建目录 <code>mkdir ~/.nvm</code>；</li>
<li>b. 在~/.bash_profil文件中添加<code>export NVM_DIR=&quot;$HOME/.nvm&quot;
. &quot;$(brew --prefix nvm)/nvm.sh&quot;</code>，保存后，执行 <code>source ~/.bash_profile</code> 应用配置；否则无法执行nvm命令；</li>
</ul></li>
<li><p>第2步：使用nvm安装Node.js（默认会自动安装一些必要的模块，如npm等）；</p></li>
</ul></li>
<li><p>通过nvm安装Node.js，卸载也需要通过nvm进行卸载；若手动直接安装Node.js则需要手动卸载（相关命令如下）;</p>

<ul>
<li><p>手动直接安装，node命令被自动安装在/usr/local/bin/node/目录中，npm命令在/usr/local/lib/node_modules/npm/目录中；</p>

<pre><code>sudo rm /usr/local/bin/node # 删除node
sudo rm -rf /usr/local/lib/node_modules # 删除全局node_modules

cd  /usr/local/bin &amp;&amp; ls -l | grep &quot;../lib/node_modules/&quot; | awk &#39;{print $9}&#39;| xargs rm # 删除node_modules注册的软链接
sudo rm /var/db/receipts/org.nodejs.*
最后删除~/.npm、~/.npmrc等文件；
</code></pre></li>
</ul></li>
</ul>

<h4 id="toc_1">二、nvm</h4>

<ul>
<li><p>nvm是Node.js多版本管理工具，类似于Python的pyenv；</p>

<pre><code>nvm ls # 查看本地安装及使用的node版本
nvm ls-remote # 查看远程可以安装的node版本

nvm install stable # 安装最新稳定版node
nvm install &lt;VERSION&gt; # 安装指定版本的node，例如nvm install 6.0.0
nvm uninstall &lt;VERSION&gt; # 卸载指定的node版本，例如nvm install 6.0.0
# 注意：正在使用的版本无法卸载；

nvm use &lt;VERSION&gt; # 切换到某个版本node，例如nvm use 6.0.0
nvm alias default &lt;VERSION&gt; # 修改node的默认版本，例如nvm alias default 6.3.1

nvm which &lt;VERSION&gt; # 查看指定版本node的安装路径
</code></pre>

<p><img src="media/14694629279396/nvm_change_node_version.png" alt="nvm_change_node_version" style="width:362px;"/></p></li>
</ul>

<h4 id="toc_2">三、nmp模块</h4>

<ul>
<li>NPM（node package manager）用于管理Node.js的模块，比如安装、卸载、更新、查看、搜索、发布等，相当于Python的pip；</li>
<li><p>Node.js的模块的安装分两种：</p>

<ul>
<li>a. 本地安装：模块会被安装到当前目录下的node_modules目录中，只能在当前目录下使用；</li>
<li>b. 全局安装：模块会被安装到Node.js的lib/node_modules中，可以在所有目录下使用；</li>
</ul>

<pre><code>npm &lt;list | ls&gt; [-g] # 查看本地（全局）已安装模块（以层级关系显示所依赖的模块）
npm ls --depth=0 # 查看本地已安装模块（只显示顶层的安装模块）
npm outdated [-g] [&lt;PACKAGE&gt;] # 查看本地（全局）的某个或所有模块是否为最新版本

npm install # 根据当前目录中的package.json文件声明的依赖模块进行安装
# 本地（全局）安装(某个版本的)模块，例如npm install -g express@4.0
npm install [-g] &lt;PACKAGE&gt;[@版本号]
# 本地安装模块，并且在package.json中添加该模块到依赖中，这样就不用提交node_modules文件夹
npm install &lt;PACKAGE&gt; --save
npm uninstall [-g] &lt;PACKAGE&gt; # 删除本地（全局）模块，并且删除依赖（Ruby/Gem不删除）
npm update [-g] [PACKAGE] # 更新本地（全局）的某个或所有模块

npm &lt;show | info&gt; &lt;PACKAGE&gt; [字段名] # 查看模块详情（不论是否安装），例如npm show hexo、npm show hexo dependencies
npm search &lt;PACKAGE&gt; # 搜索某个模块（不建议使用）
</code></pre></li>
<li><p>第一行的路径为安装路径，@前面的为模块的name，@后面的数字为模块的版本号，下面的模块为其所依赖的模块；</p>

<p><img src="media/14694629279396/npm_install.png" alt="npm_instal" style="width:315px;"/></p></li>
<li><p><strong>npm的本地安装路径问题：<code>http://www.zhihu.com/question/33302274/</code></strong></p>

<ul>
<li><strong>npm会从当前目录往父目录找，找到哪个目录有node_modules文件夹就认为这才是真正的项目目录，模块被安装到那里；</strong></li>
<li><strong>需要保证从当前的目录开始一直到根目录都没有node_modules文件夹，npm才会“正常”地把模块安装到到当前目录下的node_modules文件夹中（没有则创建）；</strong></li>
</ul></li>
<li><p>执行npm install或uninstall等操作时，需要当前目录中有package.json文件（用于管理项目的依赖项、元数据）；一般情况下，本地安装是没有该文件，需要手动创建，否则会报警告 <code>npm WARN ENOENT ENOENT: no such file or directory, open...package.json</code>；消除警告，有两种方式解决：</p>

<p><img src="media/14694629279396/npm_install_warn.png" alt="npm_install_warn" style="width:596px;"/></p>

<ul>
<li><p>a. 使用 <code>npm init</code> 引导模式输入相关数据初始化一个；</p></li>
<li><p>b. 使用 <code>npm init -y</code> 直接生成相关数据，但还会报少量警告（自动生成的数据不全）；</p></li>
<li><p>c. 使用npm-autoinit（自动生成插件）并配置运行npm指令时执行自动生成命令； 但是使用nvm进行多版本Node.js切换时会报缺少相关文件错误，这是因为不同版本Node.js的npm配置文件都是同一个（~/.npmrc），而该插件只安装在某个版本Node.js上；解决办法是在切换到的Node.js版本上也安装该插件；</p>

<pre><code>npm install -g npm-autoinit # 安装自动生成插件
npm config set onload-script npm-autoinit/autoinit # 运行npm指令时执行自动生成命令
</code></pre></li>
</ul></li>
<li><p>npm相关配置命令</p>

<pre><code>npm config &lt;list | ls&gt; [-l] # 查看所有配置信息
npm [config] set XXX # 设置相关配置（config关键字可省略）
# 也可以直接修改用户目录下.npmrc文件；

# proxy相关
npm [congfig] set proxy=http://www.abc.com:8080/ 
npm [config] get proxy # 查看proxy
npm config delete proxy # 删除proxy（config关键字不可省略）
# 也可以在install命令后加--registry参数临时设置代理，
# 如npm install express --registry=http://registry.npm.taobao.org
</code></pre></li>
<li><p>npm发布包相关命令</p>

<pre><code>npm adduser # 注册registry帐号
npm login # 登录

mpm publish # 发布项目
</code></pre></li>
</ul>

<h4 id="toc_3">四、n模块</h4>

<ul>
<li>n模块是一个Node.js多版本管理工具，类似于nvm；<strong>但是强烈建议不使用n模块进行多版本管理</strong>；</li>
<li><p>nvm与n模块比较：</p>

<ul>
<li>a. nvm是一个独立于Node.js/npm的外部shell脚本；n模块是一个Node.js全局的模块，需要使用npm全局安装；</li>
<li>b. 使用nvm安装的Node.js，npm安装的模块路径为 <code>/Users/USERNAE/.nvm/versions/node/VERSION/lib/node_modules</code> ；使用n安装（或直接安装）的Node.js，npm安装的模块路径为 <code>/usr/local/lib/node_modules</code> ，Node.js被安装在/usr/local/lib/，；</li>
<li>c.使用n切换不同版本的Node.js，会使用相同的全局npm目录，无法根据不同的Node.js版本使用不同的全局模块；</li>
</ul>

<pre><code>npm install -g n # 安装n（必须全局安装，否则无法在终端中执行n命令）

n # 查看当前通过n安装的Node版本
n stable # 安装最新稳定版Node
n &lt;VERSION&gt; # 安装指定的Node版本
n use &lt;VERSION&gt; # 切换到某个Node版本
n rm &lt;VERSION&gt; # 卸载某个Node版本
</code></pre></li>
</ul>

<h4 id="toc_4">五、package.json</h4>

<ul>
<li>package.json文件用于管理项目的依赖项、元数据；该文件有以下相关必填和非必填字段，下面只列举部分：

<ul>
<li>1). name：package的名字（不能含有关键字或特殊字符，如node、js等；若需要发布就要唯一）；</li>
<li>2). version：package的版本；</li>
<li>3). dependencies：package的依赖模块；</li>
<li>4). devDependencies：package的开发依赖模块；</li>
<li>5). main：模块入口文件的相对路径；</li>
<li>6). engines：依赖的Node.js版本；</li>
</ul></li>
<li>版本号格式：<code>主版本号(Major).副版本号(Minor).补丁版本号(Patch)</code> ，例如1.2.3；</li>
<li>~表示使用最接近的版本，空格、x、*表示任意版本；

<ul>
<li>~1表示1.0.0~1.1.0之间的版本；</li>
<li>~1.1表示1.1.0~1.2.0之间的版本；</li>
<li>~1.1.1表示1.1.1~1.2.0之间的版本；</li>
</ul></li>
</ul>

<h4 id="toc_5">六、HTTP Demo</h4>

<ul>
<li><p>创建一个example.js文件写入以下内容并运行（<code>node example.js</code>），打开浏览器进行访问；</p>

<pre><code>http = require(&#39;http&#39;);

http.createServer(function(req, res) {
    res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
    res.end(&#39;Hello World!\n&#39;);
}).listen(1337, &#39;127.0.0.1&#39;);

console.log(&#39;Server running at http://127.0.0.1:1337/&#39;);
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hexo博客搭建使用]]></title>
    <link href="http://www.justisit.com/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B.html"/>
    <updated>2016-07-31T22:18:50+08:00</updated>
    <id>http://www.justisit.com/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">一. 搭建步骤</a>
</li>
<li>
<a href="#toc_1">二. Hexo使用</a>
</li>
<li>
<a href="#toc_2">三. 备份管理</a>
</li>
<li>
<a href="#toc_3">四. 重新安装</a>
</li>
</ul>


<h4 id="toc_0">一. 搭建步骤</h4>

<ol>
<li><p>安装Git；</p></li>
<li><p>安装Node.js；</p></li>
<li><p>通过Node.js安装hexo-cli模块（可以执行hexo命令）；</p>

<pre><code>sudo npm install hexo-cli -g
</code></pre></li>
<li><p>Hexo创建博客；</p>

<pre><code>hexo init &lt;BLOG_FOLDER&gt; # 创建博客，会自动安装Hexo所需要的模块

cd &lt;BLOG_FOLDER&gt;
npm ls --depth=0 # 查看安装的本地模块
</code></pre></li>
</ol>

<span id="more"></span><!-- more -->

<ol>
<li><p>启动本地服务器预览；</p>

<pre><code>hexo s # 启动本地Server

# 在浏览器中打开http://localhost:4000/进行查看
</code></pre></li>
<li><p>开启GitHub Pages；</p></li>
<li><p>配置博客根目录中的_config.yml文件（为了部署到远程服务器上，比如GitHub Pages）；</p>

<pre><code># 注意空格
deploy: 
    type: git
    repository: &lt;REPO_URL&gt;
    branch: &lt;BRANCH_NAME&gt;
</code></pre></li>
<li><p>安装Hexo部署插件；</p>

<pre><code>npm install hexo-deployer-git --save
</code></pre></li>
<li><p>发布到远程服务器；</p>

<pre><code>hexo d # 部署Hexo生成的文件

# 在浏览器中打开“http://USERNAME.github.io/”进行查看
</code></pre></li>
<li><p>GitHub Pages绑定自定义域名（可选）；</p>

<ul>
<li>1) 在域名管理处添加CNAME记录，记录值为GitHub Pages地址（USERNAME.github.io）；</li>
<li>2) 在博客的source文件夹中，创建CNAME文件（touch CNAME），写入域名信息（如www.abc.com）；注意不要添加协议前缀，如http://、https://）；</li>
</ul></li>
</ol>

<h4 id="toc_1">二. Hexo使用</h4>

<ul>
<li><p>相关命令如下（命令可以简写）；</p>

<pre><code>hexo n &lt;POST_NAME&gt; # hexo new &quot;POST_NAME&quot;，新建一篇博文
hexo g # hexo generate，生成静态文件
hexo s # hexo server，启动本地服务器进行预览
hexo d # hexo deploy，发布到远程服务器（如GitHub Pages）
</code></pre></li>
</ul>

<h4 id="toc_2">三. 备份管理</h4>

<ul>
<li>由于Hexo将博文的<strong>源文件（.md、配置文件等）</strong>转为<strong>网页文件</strong>”，而直接操作网页文件会十分麻烦；为了防止源文件丢失或需要在不同电脑上写作，需要进行备份管理源文件；

<ul>
<li>a. 方案一：源文件、网页文件使用同一仓库管理

<ul>
<li>使用GitHub Pages时创建两个Branch，一个Branch用于部署网页文件（通过<code>hexo d</code>命令），一个Branch用于备份源文件（通过<code>git push</code>命令）；</li>
<li>缺点：由于GitHub免费的仓库是public的，Hexo文件中一些涉及key会被暴露；</li>
</ul></li>
<li>b. 方案二：源文件、网页文件使用不同仓库管理

<ul>
<li>使用GitHub Pages部署网页文件，使用git.oschina的private仓库备份源文件；</li>
</ul></li>
</ul></li>
</ul>

<h4 id="toc_3">四. 重新安装</h4>

<ul>
<li>当重新安装Hexo或需要在不同电脑上进行写作，并且此时有源文件，需要执行以下步骤：

<ul>
<li>1). 按上面的【搭建步骤】进行安装Hexo；</li>
<li>2). 将源文件复制到博客目录的source/_posts文件夹中即可；</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CocoaPods使用教程]]></title>
    <link href="http://www.justisit.com/CocoaPods%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html"/>
    <updated>2016-08-17T01:16:55+08:00</updated>
    <id>http://www.justisit.com/CocoaPods%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">一、概述</a>
</li>
<li>
<a href="#toc_1">二、安装、初始化</a>
</li>
<li>
<a href="#toc_2">三、卸载</a>
</li>
<li>
<a href="#toc_3">四、pod命令</a>
</li>
<li>
<a href="#toc_4">五、项目中移除CocoaPods</a>
</li>
<li>
<a href="#toc_5">六、Podfile文件</a>
</li>
</ul>


<h4 id="toc_0">一、概述</h4>

<ul>
<li>CocoaPods是iOS平台的第三方框架的管理工具，类似于Android中的Gradle；但是没有Gradle强大，Gradle不仅可以自动下载配置所需要的框架，还可以进行自动化构建；</li>
<li>CocoaPods基于Ruby，是Ruby的一个包（库）；需要确保使用最新的Ruby/Gem进行安装CocoaPods，或者直接安装CocoaPods APP；</li>
</ul>

<h4 id="toc_1">二、安装、初始化</h4>

<ol>
<li><p>安装最新的Ruby（建议使用rbenv安装）；</p></li>
<li><p>更换Ruby的Gem的源（建议使用<code>https://ruby.taobao.org/</code>）；</p></li>
</ol>

<span id="more"></span><!-- more -->

<ol>
<li><p>安装CocoaPods；</p>

<pre><code>gem install cocoapods
</code></pre>

<ul>
<li>重启终端，执行 <code>pod --version</code>，检查CocoaPods是否被安装正确；</li>
<li><p>若使用macOS默认的Ruby安装CocoaPods，会报错误 <code>... Operation not permitted - /usr/bin/fuzzy_match</code>，这是由于OS X 10.11引入了Rootless机制导致的，不仅仅只是对CocoaPods有副作用，解决办法如下：</p>

<pre><code>sudo gem install -n /usr/local/bin cocoapods
</code></pre></li>
</ul></li>
<li><p>（可选）更换CocoaPods的镜像索引文件的源；</p>

<ul>
<li><p>CocoaPods使用之前必须先将第三方框架的镜像索引文件（spec repo）缓存到本地，文件存放在GitHub上；</p>

<pre><code>pod repo remove master
pod repo add master https://git.oschina.net/akuandev/Specs.git
</code></pre></li>
</ul></li>
<li><p>获取CocoaPods的镜像索引文件；</p>

<pre><code>pod setup
</code></pre>

<ul>
<li>执行该命令后，终端卡在 <code>Setting up CocoaPods master repo</code> ，Cocoapods正在将镜像索引文件下载到 <code>~/.cocoapods</code> 目录中；可到该目录中执行 <code>du -sh *</code> 查看此刻已下载进度；</li>
</ul></li>
</ol>

<h4 id="toc_2">三、卸载</h4>

<ul>
<li><p>使用gem卸载CocoaPods的相关包后，还需要进行以下操作：清理镜像索引文件、删除pod执行文件、重启终端；</p>

<pre><code>gem list | grep cocoapods # 查找与cocoapods相关的包
sudo gem uninstall &lt;PACKAGE&gt; # 删除上面查找到的cocoapods的相关包

rm -rf ~/.cocoapods # 删除镜像索引文件

which pod # 查找cocoapods的pod可执行文件的路径
rm /usr/local/bin/pod # 删除可执行文件pod

# 重启终端
</code></pre></li>
</ul>

<h4 id="toc_3">四、pod命令</h4>

<ul>
<li><p>使用CocoaPods前，需要在工程目录下创建一个名为<code>Podfile</code>的文本文件（描述需要使用哪些第三方框架及使用这些框架的Target）；</p></li>
<li><p>执行 <code>pod install</code> 或 <code>pod update</code> 命令时，CocoaPods默认每次都会先主动更新CocoaPods的镜像索引文件，加参数 <code>--no-repo-update</code> 则略过此步，以加速执行速度；</p></li>
<li><p>添加参数 <code>--no-repo-update</code> 执行，有时报以下类似错误 <code>Unable to satisfy the following requirements: - `XXXX`, `~&gt; 2.4` required by `Podfile`</code> ，这是由于本地的镜像索引文件过时导致的，此时应不加参数执行，或主动更新镜像索引文件（ <code>pod repo update</code> ；若更新失败，可删除镜像索引文件，重新执行 <code>pod setup</code> ）</p>

<pre><code class="language-ruby">pod [COMMAND] help # 查看命令帮助

pod search &lt;NAME&gt; # 搜索类库，例如pod search AFNetworking
pod install [--no-repo-update] # 初次根据Podfile安装类库
pod update [--no-repo-update] # Podfile文件更新了，更新工程类库
</code></pre></li>
<li><p><strong>若执行pod相关命令报以下类似警告 <code>...target overrides the `OTHER_LDFLAGS` build setting defined...</code> ，则说明pod自动生成的一些配置信息没有生效，这是由于工程自身的配置信息覆盖掉pod自动生成的配置信息；</strong></p>

<ul>
<li>相关原理：

<ul>
<li>CocoaPods根据所需要相关类库信息自动生成一个新的名为Pods.xcodeproj工程，然后编译出一个libPods.a的静态库文件，引入到原有工程中，并自动设置相关配置信息（比如<code>Header Search Paths</code>、<code>Library Search Paths</code>、<code>Other Linker Flags</code>），同时也创建一个和原有工程同名的工程组文件*.xcworkspace；</li>
<li>Xcode工程文件的配置信息（比如经常修改的<code>Header Search Paths等</code>）可以在多个地方可以修改：

<ul>
<li>a. <code>Project</code> 中的 <code>Configurations</code>（需创建*.xcconfig文件；有Project级别、Target级别）</li>
<li>b. <code>Project</code> 中的 <code>Build Settings</code> ；</li>
<li>c. <code>Target</code> 中的 <code>Build Settings</code> ；</li>
<li>优先级依次变高，相同的配置项优先级高的会覆盖优先级低的，若要继承优先级低的配置则需要使用<code>$(inherited)</code>表示；</li>
</ul></li>
<li>pod自动生成的配置信息就是配置在 <code>Project</code> 中的 <code>Configurations</code> 的 <code>Target级别*.xcconfig文件</code> ；</li>
</ul></li>
<li><strong>解决办法：</strong>

<ul>
<li><strong>a. 方法一：删除是相同项的工程自身的配置信息；</strong></li>
<li><strong>b. 方法二：使用<code>$(inherited)</code>继承优先级低的pod自动生成的配置信息；</strong></li>
</ul></li>
</ul></li>
</ul>

<h4 id="toc_4">五、项目中移除CocoaPods</h4>

<ol>
<li>删除工程文件夹下的Podfile、Podfile.lock、Pods、*.xcworkspace文件（夹）；</li>
<li>打开原有工程文件，删除Pods文件夹，删除Frameworks文件夹中的libPods.a文件，删除 <code>Build Phases</code> 选项中的 <code>[CP]Check Pods Manifest.lock</code>、<code>[CP]Copy Pods Resources</code>、[<code>CP]Embeded Pods Frameworks</code> 等与CocoaPods相关项；</li>
<li>移除使用的相关类库代码；若有必要还需移除相关配置信息（比如Header Search Paths等）；</li>
</ol>

<h4 id="toc_5">六、Podfile文件</h4>

<ul>
<li>之前Podfile文件需要自己手动创建，现在可以执行 <code>pod init</code> 命令自动创建该文件（需要当前的目录中有Xcode工程文件）；</li>
<li><p>不同版本的CocoaPods的Podefile文件格式有所差异，同时要注意空格符、iOS版本等规范；最新的Podefile文件的格式如下：（<code>inhibit_all_warnings!</code>表示消除CocoaPods引入的类库中的警告）</p>

<pre><code>inhibit_all_warnings!
platform :ios, &#39;7.0&#39;

target &#39;Sample&#39; do
    pod &#39;AFNetworking&#39;, &#39;2.4.0&#39;
    pod &#39;SDWebImage&#39;, &#39;3.7.5&#39;
end
</code></pre></li>
<li><p>类库的版本格式：</p>

<pre><code>pod &#39;AFNetworking&#39; # 不指定版本，每次都获取最新版本  
pod &#39;AFNetworking&#39;, &#39;2.0&#39; # 只使用2.0版本  
pod &#39;AFNetworking&#39;, &#39;&gt;= 2.0&#39; # 使用大于等于2.0的版本  
pod &#39;AFNetworking&#39;, &#39;~&gt;0.1&#39; # 使用大于等于0.1但小于1.0的版本  
</code></pre></li>
</ul>

]]></content>
  </entry>
  
</feed>
